"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/immutable";
exports.ids = ["vendor-chunks/immutable"];
exports.modules = {

/***/ "(ssr)/./node_modules/immutable/dist/immutable.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/immutable/dist/immutable.es.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collection: () => (/* binding */ Collection),\n/* harmony export */   Iterable: () => (/* binding */ Iterable),\n/* harmony export */   List: () => (/* binding */ List),\n/* harmony export */   Map: () => (/* binding */ Map),\n/* harmony export */   OrderedMap: () => (/* binding */ OrderedMap),\n/* harmony export */   OrderedSet: () => (/* binding */ OrderedSet),\n/* harmony export */   PairSorting: () => (/* binding */ PairSorting),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   Record: () => (/* binding */ Record),\n/* harmony export */   Repeat: () => (/* binding */ Repeat),\n/* harmony export */   Seq: () => (/* binding */ Seq),\n/* harmony export */   Set: () => (/* binding */ Set),\n/* harmony export */   Stack: () => (/* binding */ Stack),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromJS: () => (/* binding */ fromJS),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getIn: () => (/* binding */ getIn$1),\n/* harmony export */   has: () => (/* binding */ has),\n/* harmony export */   hasIn: () => (/* binding */ hasIn$1),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   isAssociative: () => (/* binding */ isAssociative),\n/* harmony export */   isCollection: () => (/* binding */ isCollection),\n/* harmony export */   isImmutable: () => (/* binding */ isImmutable),\n/* harmony export */   isIndexed: () => (/* binding */ isIndexed),\n/* harmony export */   isKeyed: () => (/* binding */ isKeyed),\n/* harmony export */   isList: () => (/* binding */ isList),\n/* harmony export */   isMap: () => (/* binding */ isMap),\n/* harmony export */   isOrdered: () => (/* binding */ isOrdered),\n/* harmony export */   isOrderedMap: () => (/* binding */ isOrderedMap),\n/* harmony export */   isOrderedSet: () => (/* binding */ isOrderedSet),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRecord: () => (/* binding */ isRecord),\n/* harmony export */   isSeq: () => (/* binding */ isSeq),\n/* harmony export */   isSet: () => (/* binding */ isSet),\n/* harmony export */   isStack: () => (/* binding */ isStack),\n/* harmony export */   isValueObject: () => (/* binding */ isValueObject),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   mergeDeep: () => (/* binding */ mergeDeep$1),\n/* harmony export */   mergeDeepWith: () => (/* binding */ mergeDeepWith$1),\n/* harmony export */   mergeWith: () => (/* binding */ mergeWith),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   removeIn: () => (/* binding */ removeIn),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setIn: () => (/* binding */ setIn$1),\n/* harmony export */   update: () => (/* binding */ update$1),\n/* harmony export */   updateIn: () => (/* binding */ updateIn$1),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/**\n * MIT License\n * \n * Copyright (c) 2014-present, Lee Byron and other contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */ var DELETE = \"delete\";\n// Constants describing the size of trie nodes.\nvar SHIFT = 5; // Resulted in best performance after ______?\nvar SIZE = 1 << SHIFT;\nvar MASK = SIZE - 1;\n// A consistent shared value representing \"not set\" which equals nothing other\n// than itself, and nothing that could be provided externally.\nvar NOT_SET = {};\n// Boolean references, Rough equivalent of `bool &`.\nfunction MakeRef() {\n    return {\n        value: false\n    };\n}\nfunction SetRef(ref) {\n    if (ref) {\n        ref.value = true;\n    }\n}\n// A function which returns a value representing an \"owner\" for transient writes\n// to tries. The return value will only ever equal itself, and will not equal\n// the return of any subsequent call of this function.\nfunction OwnerID() {}\nfunction ensureSize(iter) {\n    if (iter.size === undefined) {\n        iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n}\nfunction wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^32âˆ’1.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== \"number\") {\n        var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n        if (\"\" + uint32Index !== index || uint32Index === 4294967295) {\n            return NaN;\n        }\n        index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n}\nfunction returnTrue() {\n    return true;\n}\nfunction wholeSlice(begin, end, size) {\n    return (begin === 0 && !isNeg(begin) || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);\n}\nfunction resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n}\nfunction resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n}\nfunction resolveIndex(index, size, defaultIndex) {\n    // Sanitize indices using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    return index === undefined ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === undefined || size === index ? index : Math.min(size, index) | 0;\n}\nfunction isNeg(value) {\n    // Account for -0 which is negative, but not less than 0.\n    return value < 0 || value === 0 && 1 / value === -Infinity;\n}\nvar IS_COLLECTION_SYMBOL = \"@@__IMMUTABLE_ITERABLE__@@\";\nfunction isCollection(maybeCollection) {\n    return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);\n}\nvar IS_KEYED_SYMBOL = \"@@__IMMUTABLE_KEYED__@@\";\nfunction isKeyed(maybeKeyed) {\n    return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);\n}\nvar IS_INDEXED_SYMBOL = \"@@__IMMUTABLE_INDEXED__@@\";\nfunction isIndexed(maybeIndexed) {\n    return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);\n}\nfunction isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n}\nvar Collection = function Collection(value) {\n    // eslint-disable-next-line no-constructor-return\n    return isCollection(value) ? value : Seq(value);\n};\nvar KeyedCollection = /*@__PURE__*/ function(Collection) {\n    function KeyedCollection(value) {\n        // eslint-disable-next-line no-constructor-return\n        return isKeyed(value) ? value : KeyedSeq(value);\n    }\n    if (Collection) KeyedCollection.__proto__ = Collection;\n    KeyedCollection.prototype = Object.create(Collection && Collection.prototype);\n    KeyedCollection.prototype.constructor = KeyedCollection;\n    return KeyedCollection;\n}(Collection);\nvar IndexedCollection = /*@__PURE__*/ function(Collection) {\n    function IndexedCollection(value) {\n        // eslint-disable-next-line no-constructor-return\n        return isIndexed(value) ? value : IndexedSeq(value);\n    }\n    if (Collection) IndexedCollection.__proto__ = Collection;\n    IndexedCollection.prototype = Object.create(Collection && Collection.prototype);\n    IndexedCollection.prototype.constructor = IndexedCollection;\n    return IndexedCollection;\n}(Collection);\nvar SetCollection = /*@__PURE__*/ function(Collection) {\n    function SetCollection(value) {\n        // eslint-disable-next-line no-constructor-return\n        return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n    if (Collection) SetCollection.__proto__ = Collection;\n    SetCollection.prototype = Object.create(Collection && Collection.prototype);\n    SetCollection.prototype.constructor = SetCollection;\n    return SetCollection;\n}(Collection);\nCollection.Keyed = KeyedCollection;\nCollection.Indexed = IndexedCollection;\nCollection.Set = SetCollection;\nvar IS_SEQ_SYMBOL = \"@@__IMMUTABLE_SEQ__@@\";\nfunction isSeq(maybeSeq) {\n    return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);\n}\nvar IS_RECORD_SYMBOL = \"@@__IMMUTABLE_RECORD__@@\";\nfunction isRecord(maybeRecord) {\n    return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);\n}\nfunction isImmutable(maybeImmutable) {\n    return isCollection(maybeImmutable) || isRecord(maybeImmutable);\n}\nvar IS_ORDERED_SYMBOL = \"@@__IMMUTABLE_ORDERED__@@\";\nfunction isOrdered(maybeOrdered) {\n    return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);\n}\nvar ITERATE_KEYS = 0;\nvar ITERATE_VALUES = 1;\nvar ITERATE_ENTRIES = 2;\nvar REAL_ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = \"@@iterator\";\nvar ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\nvar Iterator = function Iterator(next) {\n    this.next = next;\n};\nIterator.prototype.toString = function toString() {\n    return \"[Iterator]\";\n};\nIterator.KEYS = ITERATE_KEYS;\nIterator.VALUES = ITERATE_VALUES;\nIterator.ENTRIES = ITERATE_ENTRIES;\nIterator.prototype.inspect = Iterator.prototype.toSource = function() {\n    return this.toString();\n};\nIterator.prototype[ITERATOR_SYMBOL] = function() {\n    return this;\n};\nfunction iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [\n        k,\n        v\n    ];\n    iteratorResult ? iteratorResult.value = value : iteratorResult = {\n        value: value,\n        done: false\n    };\n    return iteratorResult;\n}\nfunction iteratorDone() {\n    return {\n        value: undefined,\n        done: true\n    };\n}\nfunction hasIterator(maybeIterable) {\n    if (Array.isArray(maybeIterable)) {\n        // IE11 trick as it does not support `Symbol.iterator`\n        return true;\n    }\n    return !!getIteratorFn(maybeIterable);\n}\nfunction isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === \"function\";\n}\nfunction getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n}\nfunction getIteratorFn(iterable) {\n    var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === \"function\") {\n        return iteratorFn;\n    }\n}\nfunction isEntriesIterable(maybeIterable) {\n    var iteratorFn = getIteratorFn(maybeIterable);\n    return iteratorFn && iteratorFn === maybeIterable.entries;\n}\nfunction isKeysIterable(maybeIterable) {\n    var iteratorFn = getIteratorFn(maybeIterable);\n    return iteratorFn && iteratorFn === maybeIterable.keys;\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction isArrayLike(value) {\n    if (Array.isArray(value) || typeof value === \"string\") {\n        return true;\n    }\n    return value && typeof value === \"object\" && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? Object.keys(value).length === 1 : // in the array-like may be found (which could be undefined).\n    value.hasOwnProperty(value.length - 1));\n}\nvar Seq = /*@__PURE__*/ function(Collection) {\n    function Seq(value) {\n        // eslint-disable-next-line no-constructor-return\n        return value === undefined || value === null ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);\n    }\n    if (Collection) Seq.__proto__ = Collection;\n    Seq.prototype = Object.create(Collection && Collection.prototype);\n    Seq.prototype.constructor = Seq;\n    Seq.prototype.toSeq = function toSeq() {\n        return this;\n    };\n    Seq.prototype.toString = function toString() {\n        return this.__toString(\"Seq {\", \"}\");\n    };\n    Seq.prototype.cacheResult = function cacheResult() {\n        if (!this._cache && this.__iterateUncached) {\n            this._cache = this.entrySeq().toArray();\n            this.size = this._cache.length;\n        }\n        return this;\n    };\n    // abstract __iterateUncached(fn, reverse)\n    Seq.prototype.__iterate = function __iterate(fn, reverse) {\n        var cache = this._cache;\n        if (cache) {\n            var size = cache.length;\n            var i = 0;\n            while(i !== size){\n                var entry = cache[reverse ? size - ++i : i++];\n                if (fn(entry[1], entry[0], this) === false) {\n                    break;\n                }\n            }\n            return i;\n        }\n        return this.__iterateUncached(fn, reverse);\n    };\n    // abstract __iteratorUncached(type, reverse)\n    Seq.prototype.__iterator = function __iterator(type, reverse) {\n        var cache = this._cache;\n        if (cache) {\n            var size = cache.length;\n            var i = 0;\n            return new Iterator(function() {\n                if (i === size) {\n                    return iteratorDone();\n                }\n                var entry = cache[reverse ? size - ++i : i++];\n                return iteratorValue(type, entry[0], entry[1]);\n            });\n        }\n        return this.__iteratorUncached(type, reverse);\n    };\n    return Seq;\n}(Collection);\nvar KeyedSeq = /*@__PURE__*/ function(Seq) {\n    function KeyedSeq(value) {\n        // eslint-disable-next-line no-constructor-return\n        return value === undefined || value === null ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);\n    }\n    if (Seq) KeyedSeq.__proto__ = Seq;\n    KeyedSeq.prototype = Object.create(Seq && Seq.prototype);\n    KeyedSeq.prototype.constructor = KeyedSeq;\n    KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {\n        return this;\n    };\n    return KeyedSeq;\n}(Seq);\nvar IndexedSeq = /*@__PURE__*/ function(Seq) {\n    function IndexedSeq(value) {\n        // eslint-disable-next-line no-constructor-return\n        return value === undefined || value === null ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);\n    }\n    if (Seq) IndexedSeq.__proto__ = Seq;\n    IndexedSeq.prototype = Object.create(Seq && Seq.prototype);\n    IndexedSeq.prototype.constructor = IndexedSeq;\n    IndexedSeq.of = function of() {\n        return IndexedSeq(arguments);\n    };\n    IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {\n        return this;\n    };\n    IndexedSeq.prototype.toString = function toString() {\n        return this.__toString(\"Seq [\", \"]\");\n    };\n    return IndexedSeq;\n}(Seq);\nvar SetSeq = /*@__PURE__*/ function(Seq) {\n    function SetSeq(value) {\n        // eslint-disable-next-line no-constructor-return\n        return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();\n    }\n    if (Seq) SetSeq.__proto__ = Seq;\n    SetSeq.prototype = Object.create(Seq && Seq.prototype);\n    SetSeq.prototype.constructor = SetSeq;\n    SetSeq.of = function of() {\n        return SetSeq(arguments);\n    };\n    SetSeq.prototype.toSetSeq = function toSetSeq() {\n        return this;\n    };\n    return SetSeq;\n}(Seq);\nSeq.isSeq = isSeq;\nSeq.Keyed = KeyedSeq;\nSeq.Set = SetSeq;\nSeq.Indexed = IndexedSeq;\nSeq.prototype[IS_SEQ_SYMBOL] = true;\n// #pragma Root Sequences\nvar ArraySeq = /*@__PURE__*/ function(IndexedSeq) {\n    function ArraySeq(array) {\n        this._array = array;\n        this.size = array.length;\n    }\n    if (IndexedSeq) ArraySeq.__proto__ = IndexedSeq;\n    ArraySeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n    ArraySeq.prototype.constructor = ArraySeq;\n    ArraySeq.prototype.get = function get(index, notSetValue) {\n        return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n    ArraySeq.prototype.__iterate = function __iterate(fn, reverse) {\n        var array = this._array;\n        var size = array.length;\n        var i = 0;\n        while(i !== size){\n            var ii = reverse ? size - ++i : i++;\n            if (fn(array[ii], ii, this) === false) {\n                break;\n            }\n        }\n        return i;\n    };\n    ArraySeq.prototype.__iterator = function __iterator(type, reverse) {\n        var array = this._array;\n        var size = array.length;\n        var i = 0;\n        return new Iterator(function() {\n            if (i === size) {\n                return iteratorDone();\n            }\n            var ii = reverse ? size - ++i : i++;\n            return iteratorValue(type, ii, array[ii]);\n        });\n    };\n    return ArraySeq;\n}(IndexedSeq);\nvar ObjectSeq = /*@__PURE__*/ function(KeyedSeq) {\n    function ObjectSeq(object) {\n        var keys = Object.keys(object).concat(Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []);\n        this._object = object;\n        this._keys = keys;\n        this.size = keys.length;\n    }\n    if (KeyedSeq) ObjectSeq.__proto__ = KeyedSeq;\n    ObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);\n    ObjectSeq.prototype.constructor = ObjectSeq;\n    ObjectSeq.prototype.get = function get(key, notSetValue) {\n        if (notSetValue !== undefined && !this.has(key)) {\n            return notSetValue;\n        }\n        return this._object[key];\n    };\n    ObjectSeq.prototype.has = function has(key) {\n        return hasOwnProperty.call(this._object, key);\n    };\n    ObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {\n        var object = this._object;\n        var keys = this._keys;\n        var size = keys.length;\n        var i = 0;\n        while(i !== size){\n            var key = keys[reverse ? size - ++i : i++];\n            if (fn(object[key], key, this) === false) {\n                break;\n            }\n        }\n        return i;\n    };\n    ObjectSeq.prototype.__iterator = function __iterator(type, reverse) {\n        var object = this._object;\n        var keys = this._keys;\n        var size = keys.length;\n        var i = 0;\n        return new Iterator(function() {\n            if (i === size) {\n                return iteratorDone();\n            }\n            var key = keys[reverse ? size - ++i : i++];\n            return iteratorValue(type, key, object[key]);\n        });\n    };\n    return ObjectSeq;\n}(KeyedSeq);\nObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;\nvar CollectionSeq = /*@__PURE__*/ function(IndexedSeq) {\n    function CollectionSeq(collection) {\n        this._collection = collection;\n        this.size = collection.length || collection.size;\n    }\n    if (IndexedSeq) CollectionSeq.__proto__ = IndexedSeq;\n    CollectionSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n    CollectionSeq.prototype.constructor = CollectionSeq;\n    CollectionSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {\n        if (reverse) {\n            return this.cacheResult().__iterate(fn, reverse);\n        }\n        var collection = this._collection;\n        var iterator = getIterator(collection);\n        var iterations = 0;\n        if (isIterator(iterator)) {\n            var step;\n            while(!(step = iterator.next()).done){\n                if (fn(step.value, iterations++, this) === false) {\n                    break;\n                }\n            }\n        }\n        return iterations;\n    };\n    CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {\n        if (reverse) {\n            return this.cacheResult().__iterator(type, reverse);\n        }\n        var collection = this._collection;\n        var iterator = getIterator(collection);\n        if (!isIterator(iterator)) {\n            return new Iterator(iteratorDone);\n        }\n        var iterations = 0;\n        return new Iterator(function() {\n            var step = iterator.next();\n            return step.done ? step : iteratorValue(type, iterations++, step.value);\n        });\n    };\n    return CollectionSeq;\n}(IndexedSeq);\n// # pragma Helper functions\nvar EMPTY_SEQ;\nfunction emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n}\nfunction keyedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (seq) {\n        return seq.fromEntrySeq();\n    }\n    if (typeof value === \"object\") {\n        return new ObjectSeq(value);\n    }\n    throw new TypeError(\"Expected Array or collection object of [k, v] entries, or keyed object: \" + value);\n}\nfunction indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (seq) {\n        return seq;\n    }\n    throw new TypeError(\"Expected Array or collection object of values: \" + value);\n}\nfunction seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (seq) {\n        return isEntriesIterable(value) ? seq.fromEntrySeq() : isKeysIterable(value) ? seq.toSetSeq() : seq;\n    }\n    if (typeof value === \"object\") {\n        return new ObjectSeq(value);\n    }\n    throw new TypeError(\"Expected Array or collection object of values, or keyed object: \" + value);\n}\nfunction maybeIndexedSeqFromValue(value) {\n    return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;\n}\nvar IS_MAP_SYMBOL = \"@@__IMMUTABLE_MAP__@@\";\nfunction isMap(maybeMap) {\n    return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);\n}\nfunction isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n}\nfunction isValueObject(maybeValue) {\n    return Boolean(maybeValue && typeof maybeValue.equals === \"function\" && typeof maybeValue.hashCode === \"function\");\n}\n/**\n * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n *\n * NaN is considered the same as NaN, however -0 and 0 are considered the same\n * value, which is different from the algorithm described by\n * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n *\n * This is extended further to allow Objects to describe the values they\n * represent, by way of `valueOf` or `equals` (and `hashCode`).\n *\n * Note: because of this extension, the key equality of Immutable.Map and the\n * value equality of Immutable.Set will differ from ES6 Map and Set.\n *\n * ### Defining custom values\n *\n * The easiest way to describe the value an object represents is by implementing\n * `valueOf`. For example, `Date` represents a value by returning a unix\n * timestamp for `valueOf`:\n *\n *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n *     var date2 = new Date(1234567890000);\n *     date1.valueOf(); // 1234567890000\n *     assert( date1 !== date2 );\n *     assert( Immutable.is( date1, date2 ) );\n *\n * Note: overriding `valueOf` may have other implications if you use this object\n * where JavaScript expects a primitive, such as implicit string coercion.\n *\n * For more complex types, especially collections, implementing `valueOf` may\n * not be performant. An alternative is to implement `equals` and `hashCode`.\n *\n * `equals` takes another object, presumably of similar type, and returns true\n * if it is equal. Equality is symmetrical, so the same result should be\n * returned if this and the argument are flipped.\n *\n *     assert( a.equals(b) === b.equals(a) );\n *\n * `hashCode` returns a 32bit integer number representing the object which will\n * be used to determine how to store the value object in a Map or Set. You must\n * provide both or neither methods, one must not exist without the other.\n *\n * Also, an important relationship between these methods must be upheld: if two\n * values are equal, they *must* return the same hashCode. If the values are not\n * equal, they might have the same hashCode; this is called a hash collision,\n * and while undesirable for performance reasons, it is acceptable.\n *\n *     if (a.equals(b)) {\n *       assert( a.hashCode() === b.hashCode() );\n *     }\n *\n * All Immutable collections are Value Objects: they implement `equals()`\n * and `hashCode()`.\n */ function is(valueA, valueB) {\n    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {\n        return true;\n    }\n    if (!valueA || !valueB) {\n        return false;\n    }\n    if (typeof valueA.valueOf === \"function\" && typeof valueB.valueOf === \"function\") {\n        valueA = valueA.valueOf();\n        valueB = valueB.valueOf();\n        if (valueA === valueB || valueA !== valueA && valueB !== valueB) {\n            return true;\n        }\n        if (!valueA || !valueB) {\n            return false;\n        }\n    }\n    return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));\n}\nvar imul = typeof Math.imul === \"function\" && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {\n    a |= 0; // int\n    b |= 0; // int\n    var c = a & 0xffff;\n    var d = b & 0xffff;\n    // Shift by 0 fixes the sign on the high part.\n    return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int\n};\n// v8 has an optimization for storing 31-bit signed numbers.\n// Values which have either 00 or 11 as the high order bits qualify.\n// This function drops the highest order bit in a signed number, maintaining\n// the sign bit.\nfunction smi(i32) {\n    return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;\n}\nvar defaultValueOf = Object.prototype.valueOf;\nfunction hash(o) {\n    if (o == null) {\n        return hashNullish(o);\n    }\n    if (typeof o.hashCode === \"function\") {\n        // Drop any high bits from accidentally long hash codes.\n        return smi(o.hashCode(o));\n    }\n    var v = valueOf(o);\n    if (v == null) {\n        return hashNullish(v);\n    }\n    switch(typeof v){\n        case \"boolean\":\n            // The hash values for built-in constants are a 1 value for each 5-byte\n            // shift region expect for the first, which encodes the value. This\n            // reduces the odds of a hash collision for these common values.\n            return v ? 0x42108421 : 0x42108420;\n        case \"number\":\n            return hashNumber(v);\n        case \"string\":\n            return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);\n        case \"object\":\n        case \"function\":\n            return hashJSObj(v);\n        case \"symbol\":\n            return hashSymbol(v);\n        default:\n            if (typeof v.toString === \"function\") {\n                return hashString(v.toString());\n            }\n            throw new Error(\"Value type \" + typeof v + \" cannot be hashed.\");\n    }\n}\nfunction hashNullish(nullish) {\n    return nullish === null ? 0x42108422 : /* undefined */ 0x42108423;\n}\n// Compress arbitrarily large numbers into smi hashes.\nfunction hashNumber(n) {\n    if (n !== n || n === Infinity) {\n        return 0;\n    }\n    var hash = n | 0;\n    if (hash !== n) {\n        hash ^= n * 0xffffffff;\n    }\n    while(n > 0xffffffff){\n        n /= 0xffffffff;\n        hash ^= n;\n    }\n    return smi(hash);\n}\nfunction cachedHashString(string) {\n    var hashed = stringHashCache[string];\n    if (hashed === undefined) {\n        hashed = hashString(string);\n        if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n            STRING_HASH_CACHE_SIZE = 0;\n            stringHashCache = {};\n        }\n        STRING_HASH_CACHE_SIZE++;\n        stringHashCache[string] = hashed;\n    }\n    return hashed;\n}\n// http://jsperf.com/hashing-strings\nfunction hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hashed = 0;\n    for(var ii = 0; ii < string.length; ii++){\n        hashed = 31 * hashed + string.charCodeAt(ii) | 0;\n    }\n    return smi(hashed);\n}\nfunction hashSymbol(sym) {\n    var hashed = symbolMap[sym];\n    if (hashed !== undefined) {\n        return hashed;\n    }\n    hashed = nextHash();\n    symbolMap[sym] = hashed;\n    return hashed;\n}\nfunction hashJSObj(obj) {\n    var hashed;\n    if (usingWeakMap) {\n        hashed = weakMap.get(obj);\n        if (hashed !== undefined) {\n            return hashed;\n        }\n    }\n    hashed = obj[UID_HASH_KEY];\n    if (hashed !== undefined) {\n        return hashed;\n    }\n    if (!canDefineProperty) {\n        hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n        if (hashed !== undefined) {\n            return hashed;\n        }\n        hashed = getIENodeHash(obj);\n        if (hashed !== undefined) {\n            return hashed;\n        }\n    }\n    hashed = nextHash();\n    if (usingWeakMap) {\n        weakMap.set(obj, hashed);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n        throw new Error(\"Non-extensible objects are not allowed as keys.\");\n    } else if (canDefineProperty) {\n        Object.defineProperty(obj, UID_HASH_KEY, {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: hashed\n        });\n    } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n        // Since we can't define a non-enumerable property on the object\n        // we'll hijack one of the less-used non-enumerable properties to\n        // save our hash on it. Since this is a function it will not show up in\n        // `JSON.stringify` which is what we want.\n        obj.propertyIsEnumerable = function() {\n            return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n        };\n        obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;\n    } else if (obj.nodeType !== undefined) {\n        // At this point we couldn't get the IE `uniqueID` to use as a hash\n        // and we couldn't use a non-enumerable property to exploit the\n        // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n        // itself.\n        obj[UID_HASH_KEY] = hashed;\n    } else {\n        throw new Error(\"Unable to set a non-enumerable property on object.\");\n    }\n    return hashed;\n}\n// Get references to ES5 object methods.\nvar isExtensible = Object.isExtensible;\n// True if Object.defineProperty works as expected. IE8 fails this test.\nvar canDefineProperty = function() {\n    try {\n        Object.defineProperty({}, \"@\", {});\n        return true;\n    } catch (e) {\n        return false;\n    }\n}();\n// IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n// and avoid memory leaks from the IE cloneNode bug.\nfunction getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n        switch(node.nodeType){\n            case 1:\n                return node.uniqueID;\n            case 9:\n                return node.documentElement && node.documentElement.uniqueID;\n        }\n    }\n}\nfunction valueOf(obj) {\n    return obj.valueOf !== defaultValueOf && typeof obj.valueOf === \"function\" ? obj.valueOf(obj) : obj;\n}\nfunction nextHash() {\n    var nextHash = ++_objHashUID;\n    if (_objHashUID & 0x40000000) {\n        _objHashUID = 0;\n    }\n    return nextHash;\n}\n// If possible, use a WeakMap.\nvar usingWeakMap = typeof WeakMap === \"function\";\nvar weakMap;\nif (usingWeakMap) {\n    weakMap = new WeakMap();\n}\nvar symbolMap = Object.create(null);\nvar _objHashUID = 0;\nvar UID_HASH_KEY = \"__immutablehash__\";\nif (typeof Symbol === \"function\") {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n}\nvar STRING_HASH_CACHE_MIN_STRLEN = 16;\nvar STRING_HASH_CACHE_MAX_SIZE = 255;\nvar STRING_HASH_CACHE_SIZE = 0;\nvar stringHashCache = {};\nvar ToKeyedSequence = /*@__PURE__*/ function(KeyedSeq) {\n    function ToKeyedSequence(indexed, useKeys) {\n        this._iter = indexed;\n        this._useKeys = useKeys;\n        this.size = indexed.size;\n    }\n    if (KeyedSeq) ToKeyedSequence.__proto__ = KeyedSeq;\n    ToKeyedSequence.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);\n    ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n    ToKeyedSequence.prototype.get = function get(key, notSetValue) {\n        return this._iter.get(key, notSetValue);\n    };\n    ToKeyedSequence.prototype.has = function has(key) {\n        return this._iter.has(key);\n    };\n    ToKeyedSequence.prototype.valueSeq = function valueSeq() {\n        return this._iter.valueSeq();\n    };\n    ToKeyedSequence.prototype.reverse = function reverse() {\n        var this$1$1 = this;\n        var reversedSequence = reverseFactory(this, true);\n        if (!this._useKeys) {\n            reversedSequence.valueSeq = function() {\n                return this$1$1._iter.toSeq().reverse();\n            };\n        }\n        return reversedSequence;\n    };\n    ToKeyedSequence.prototype.map = function map(mapper, context) {\n        var this$1$1 = this;\n        var mappedSequence = mapFactory(this, mapper, context);\n        if (!this._useKeys) {\n            mappedSequence.valueSeq = function() {\n                return this$1$1._iter.toSeq().map(mapper, context);\n            };\n        }\n        return mappedSequence;\n    };\n    ToKeyedSequence.prototype.__iterate = function __iterate(fn, reverse) {\n        var this$1$1 = this;\n        return this._iter.__iterate(function(v, k) {\n            return fn(v, k, this$1$1);\n        }, reverse);\n    };\n    ToKeyedSequence.prototype.__iterator = function __iterator(type, reverse) {\n        return this._iter.__iterator(type, reverse);\n    };\n    return ToKeyedSequence;\n}(KeyedSeq);\nToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;\nvar ToIndexedSequence = /*@__PURE__*/ function(IndexedSeq) {\n    function ToIndexedSequence(iter) {\n        this._iter = iter;\n        this.size = iter.size;\n    }\n    if (IndexedSeq) ToIndexedSequence.__proto__ = IndexedSeq;\n    ToIndexedSequence.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n    ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n    ToIndexedSequence.prototype.includes = function includes(value) {\n        return this._iter.includes(value);\n    };\n    ToIndexedSequence.prototype.__iterate = function __iterate(fn, reverse) {\n        var this$1$1 = this;\n        var i = 0;\n        reverse && ensureSize(this);\n        return this._iter.__iterate(function(v) {\n            return fn(v, reverse ? this$1$1.size - ++i : i++, this$1$1);\n        }, reverse);\n    };\n    ToIndexedSequence.prototype.__iterator = function __iterator(type, reverse) {\n        var this$1$1 = this;\n        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n        var i = 0;\n        reverse && ensureSize(this);\n        return new Iterator(function() {\n            var step = iterator.next();\n            return step.done ? step : iteratorValue(type, reverse ? this$1$1.size - ++i : i++, step.value, step);\n        });\n    };\n    return ToIndexedSequence;\n}(IndexedSeq);\nvar ToSetSequence = /*@__PURE__*/ function(SetSeq) {\n    function ToSetSequence(iter) {\n        this._iter = iter;\n        this.size = iter.size;\n    }\n    if (SetSeq) ToSetSequence.__proto__ = SetSeq;\n    ToSetSequence.prototype = Object.create(SetSeq && SetSeq.prototype);\n    ToSetSequence.prototype.constructor = ToSetSequence;\n    ToSetSequence.prototype.has = function has(key) {\n        return this._iter.includes(key);\n    };\n    ToSetSequence.prototype.__iterate = function __iterate(fn, reverse) {\n        var this$1$1 = this;\n        return this._iter.__iterate(function(v) {\n            return fn(v, v, this$1$1);\n        }, reverse);\n    };\n    ToSetSequence.prototype.__iterator = function __iterator(type, reverse) {\n        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n        return new Iterator(function() {\n            var step = iterator.next();\n            return step.done ? step : iteratorValue(type, step.value, step.value, step);\n        });\n    };\n    return ToSetSequence;\n}(SetSeq);\nvar FromEntriesSequence = /*@__PURE__*/ function(KeyedSeq) {\n    function FromEntriesSequence(entries) {\n        this._iter = entries;\n        this.size = entries.size;\n    }\n    if (KeyedSeq) FromEntriesSequence.__proto__ = KeyedSeq;\n    FromEntriesSequence.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);\n    FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n    FromEntriesSequence.prototype.entrySeq = function entrySeq() {\n        return this._iter.toSeq();\n    };\n    FromEntriesSequence.prototype.__iterate = function __iterate(fn, reverse) {\n        var this$1$1 = this;\n        return this._iter.__iterate(function(entry) {\n            // Check if entry exists first so array access doesn't throw for holes\n            // in the parent iteration.\n            if (entry) {\n                validateEntry(entry);\n                var indexedCollection = isCollection(entry);\n                return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1$1);\n            }\n        }, reverse);\n    };\n    FromEntriesSequence.prototype.__iterator = function __iterator(type, reverse) {\n        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n        return new Iterator(function() {\n            while(true){\n                var step = iterator.next();\n                if (step.done) {\n                    return step;\n                }\n                var entry = step.value;\n                // Check if entry exists first so array access doesn't throw for holes\n                // in the parent iteration.\n                if (entry) {\n                    validateEntry(entry);\n                    var indexedCollection = isCollection(entry);\n                    return iteratorValue(type, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);\n                }\n            }\n        });\n    };\n    return FromEntriesSequence;\n}(KeyedSeq);\nToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;\nfunction flipFactory(collection) {\n    var flipSequence = makeSequence(collection);\n    flipSequence._iter = collection;\n    flipSequence.size = collection.size;\n    flipSequence.flip = function() {\n        return collection;\n    };\n    flipSequence.reverse = function() {\n        var reversedSequence = collection.reverse.apply(this); // super.reverse()\n        reversedSequence.flip = function() {\n            return collection.reverse();\n        };\n        return reversedSequence;\n    };\n    flipSequence.has = function(key) {\n        return collection.includes(key);\n    };\n    flipSequence.includes = function(key) {\n        return collection.has(key);\n    };\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function(fn, reverse) {\n        var this$1$1 = this;\n        return collection.__iterate(function(v, k) {\n            return fn(k, v, this$1$1) !== false;\n        }, reverse);\n    };\n    flipSequence.__iteratorUncached = function(type, reverse) {\n        if (type === ITERATE_ENTRIES) {\n            var iterator = collection.__iterator(type, reverse);\n            return new Iterator(function() {\n                var step = iterator.next();\n                if (!step.done) {\n                    var k = step.value[0];\n                    step.value[0] = step.value[1];\n                    step.value[1] = k;\n                }\n                return step;\n            });\n        }\n        return collection.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);\n    };\n    return flipSequence;\n}\nfunction mapFactory(collection, mapper, context) {\n    var mappedSequence = makeSequence(collection);\n    mappedSequence.size = collection.size;\n    mappedSequence.has = function(key) {\n        return collection.has(key);\n    };\n    mappedSequence.get = function(key, notSetValue) {\n        var v = collection.get(key, NOT_SET);\n        return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);\n    };\n    mappedSequence.__iterateUncached = function(fn, reverse) {\n        var this$1$1 = this;\n        return collection.__iterate(function(v, k, c) {\n            return fn(mapper.call(context, v, k, c), k, this$1$1) !== false;\n        }, reverse);\n    };\n    mappedSequence.__iteratorUncached = function(type, reverse) {\n        var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n        return new Iterator(function() {\n            var step = iterator.next();\n            if (step.done) {\n                return step;\n            }\n            var entry = step.value;\n            var key = entry[0];\n            return iteratorValue(type, key, mapper.call(context, entry[1], key, collection), step);\n        });\n    };\n    return mappedSequence;\n}\nfunction reverseFactory(collection, useKeys) {\n    var this$1$1 = this;\n    var reversedSequence = makeSequence(collection);\n    reversedSequence._iter = collection;\n    reversedSequence.size = collection.size;\n    reversedSequence.reverse = function() {\n        return collection;\n    };\n    if (collection.flip) {\n        reversedSequence.flip = function() {\n            var flipSequence = flipFactory(collection);\n            flipSequence.reverse = function() {\n                return collection.flip();\n            };\n            return flipSequence;\n        };\n    }\n    reversedSequence.get = function(key, notSetValue) {\n        return collection.get(useKeys ? key : -1 - key, notSetValue);\n    };\n    reversedSequence.has = function(key) {\n        return collection.has(useKeys ? key : -1 - key);\n    };\n    reversedSequence.includes = function(value) {\n        return collection.includes(value);\n    };\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function(fn, reverse) {\n        var this$1$1 = this;\n        var i = 0;\n        reverse && ensureSize(collection);\n        return collection.__iterate(function(v, k) {\n            return fn(v, useKeys ? k : reverse ? this$1$1.size - ++i : i++, this$1$1);\n        }, !reverse);\n    };\n    reversedSequence.__iterator = function(type, reverse) {\n        var i = 0;\n        reverse && ensureSize(collection);\n        var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n        return new Iterator(function() {\n            var step = iterator.next();\n            if (step.done) {\n                return step;\n            }\n            var entry = step.value;\n            return iteratorValue(type, useKeys ? entry[0] : reverse ? this$1$1.size - ++i : i++, entry[1], step);\n        });\n    };\n    return reversedSequence;\n}\nfunction filterFactory(collection, predicate, context, useKeys) {\n    var filterSequence = makeSequence(collection);\n    if (useKeys) {\n        filterSequence.has = function(key) {\n            var v = collection.get(key, NOT_SET);\n            return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n        };\n        filterSequence.get = function(key, notSetValue) {\n            var v = collection.get(key, NOT_SET);\n            return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;\n        };\n    }\n    filterSequence.__iterateUncached = function(fn, reverse) {\n        var this$1$1 = this;\n        var iterations = 0;\n        collection.__iterate(function(v, k, c) {\n            if (predicate.call(context, v, k, c)) {\n                iterations++;\n                return fn(v, useKeys ? k : iterations - 1, this$1$1);\n            }\n        }, reverse);\n        return iterations;\n    };\n    filterSequence.__iteratorUncached = function(type, reverse) {\n        var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n        var iterations = 0;\n        return new Iterator(function() {\n            while(true){\n                var step = iterator.next();\n                if (step.done) {\n                    return step;\n                }\n                var entry = step.value;\n                var key = entry[0];\n                var value = entry[1];\n                if (predicate.call(context, value, key, collection)) {\n                    return iteratorValue(type, useKeys ? key : iterations++, value, step);\n                }\n            }\n        });\n    };\n    return filterSequence;\n}\nfunction countByFactory(collection, grouper, context) {\n    var groups = Map().asMutable();\n    collection.__iterate(function(v, k) {\n        groups.update(grouper.call(context, v, k, collection), 0, function(a) {\n            return a + 1;\n        });\n    });\n    return groups.asImmutable();\n}\nfunction groupByFactory(collection, grouper, context) {\n    var isKeyedIter = isKeyed(collection);\n    var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n    collection.__iterate(function(v, k) {\n        groups.update(grouper.call(context, v, k, collection), function(a) {\n            return a = a || [], a.push(isKeyedIter ? [\n                k,\n                v\n            ] : v), a;\n        });\n    });\n    var coerce = collectionClass(collection);\n    return groups.map(function(arr) {\n        return reify(collection, coerce(arr));\n    }).asImmutable();\n}\nfunction partitionFactory(collection, predicate, context) {\n    var isKeyedIter = isKeyed(collection);\n    var groups = [\n        [],\n        []\n    ];\n    collection.__iterate(function(v, k) {\n        groups[predicate.call(context, v, k, collection) ? 1 : 0].push(isKeyedIter ? [\n            k,\n            v\n        ] : v);\n    });\n    var coerce = collectionClass(collection);\n    return groups.map(function(arr) {\n        return reify(collection, coerce(arr));\n    });\n}\nfunction sliceFactory(collection, begin, end, useKeys) {\n    var originalSize = collection.size;\n    if (wholeSlice(begin, end, originalSize)) {\n        return collection;\n    }\n    // begin or end can not be resolved if they were provided as negative numbers and\n    // this collection's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (typeof originalSize === \"undefined\" && (begin < 0 || end < 0)) {\n        return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n    }\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n        sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n    var sliceSeq = makeSequence(collection);\n    // If collection.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || undefined;\n    if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n        sliceSeq.get = function(index, notSetValue) {\n            index = wrapIndex(this, index);\n            return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;\n        };\n    }\n    sliceSeq.__iterateUncached = function(fn, reverse) {\n        var this$1$1 = this;\n        if (sliceSize === 0) {\n            return 0;\n        }\n        if (reverse) {\n            return this.cacheResult().__iterate(fn, reverse);\n        }\n        var skipped = 0;\n        var isSkipping = true;\n        var iterations = 0;\n        collection.__iterate(function(v, k) {\n            if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n                iterations++;\n                return fn(v, useKeys ? k : iterations - 1, this$1$1) !== false && iterations !== sliceSize;\n            }\n        });\n        return iterations;\n    };\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n        if (sliceSize !== 0 && reverse) {\n            return this.cacheResult().__iterator(type, reverse);\n        }\n        // Don't bother instantiating parent iterator if taking 0.\n        if (sliceSize === 0) {\n            return new Iterator(iteratorDone);\n        }\n        var iterator = collection.__iterator(type, reverse);\n        var skipped = 0;\n        var iterations = 0;\n        return new Iterator(function() {\n            while(skipped++ < resolvedBegin){\n                iterator.next();\n            }\n            if (++iterations > sliceSize) {\n                return iteratorDone();\n            }\n            var step = iterator.next();\n            if (useKeys || type === ITERATE_VALUES || step.done) {\n                return step;\n            }\n            if (type === ITERATE_KEYS) {\n                return iteratorValue(type, iterations - 1, undefined, step);\n            }\n            return iteratorValue(type, iterations - 1, step.value[1], step);\n        });\n    };\n    return sliceSeq;\n}\nfunction takeWhileFactory(collection, predicate, context) {\n    var takeSequence = makeSequence(collection);\n    takeSequence.__iterateUncached = function(fn, reverse) {\n        var this$1$1 = this;\n        if (reverse) {\n            return this.cacheResult().__iterate(fn, reverse);\n        }\n        var iterations = 0;\n        collection.__iterate(function(v, k, c) {\n            return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1$1);\n        });\n        return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {\n        var this$1$1 = this;\n        if (reverse) {\n            return this.cacheResult().__iterator(type, reverse);\n        }\n        var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n        var iterating = true;\n        return new Iterator(function() {\n            if (!iterating) {\n                return iteratorDone();\n            }\n            var step = iterator.next();\n            if (step.done) {\n                return step;\n            }\n            var entry = step.value;\n            var k = entry[0];\n            var v = entry[1];\n            if (!predicate.call(context, v, k, this$1$1)) {\n                iterating = false;\n                return iteratorDone();\n            }\n            return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n        });\n    };\n    return takeSequence;\n}\nfunction skipWhileFactory(collection, predicate, context, useKeys) {\n    var skipSequence = makeSequence(collection);\n    skipSequence.__iterateUncached = function(fn, reverse) {\n        var this$1$1 = this;\n        if (reverse) {\n            return this.cacheResult().__iterate(fn, reverse);\n        }\n        var isSkipping = true;\n        var iterations = 0;\n        collection.__iterate(function(v, k, c) {\n            if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n                iterations++;\n                return fn(v, useKeys ? k : iterations - 1, this$1$1);\n            }\n        });\n        return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {\n        var this$1$1 = this;\n        if (reverse) {\n            return this.cacheResult().__iterator(type, reverse);\n        }\n        var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n        var skipping = true;\n        var iterations = 0;\n        return new Iterator(function() {\n            var step;\n            var k;\n            var v;\n            do {\n                step = iterator.next();\n                if (step.done) {\n                    if (useKeys || type === ITERATE_VALUES) {\n                        return step;\n                    }\n                    if (type === ITERATE_KEYS) {\n                        return iteratorValue(type, iterations++, undefined, step);\n                    }\n                    return iteratorValue(type, iterations++, step.value[1], step);\n                }\n                var entry = step.value;\n                k = entry[0];\n                v = entry[1];\n                skipping && (skipping = predicate.call(context, v, k, this$1$1));\n            }while (skipping);\n            return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n        });\n    };\n    return skipSequence;\n}\nfunction concatFactory(collection, values) {\n    var isKeyedCollection = isKeyed(collection);\n    var iters = [\n        collection\n    ].concat(values).map(function(v) {\n        if (!isCollection(v)) {\n            v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [\n                v\n            ]);\n        } else if (isKeyedCollection) {\n            v = KeyedCollection(v);\n        }\n        return v;\n    }).filter(function(v) {\n        return v.size !== 0;\n    });\n    if (iters.length === 0) {\n        return collection;\n    }\n    if (iters.length === 1) {\n        var singleton = iters[0];\n        if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {\n            return singleton;\n        }\n    }\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedCollection) {\n        concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(collection)) {\n        concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(function(sum, seq) {\n        if (sum !== undefined) {\n            var size = seq.size;\n            if (size !== undefined) {\n                return sum + size;\n            }\n        }\n    }, 0);\n    return concatSeq;\n}\nfunction flattenFactory(collection, depth, useKeys) {\n    var flatSequence = makeSequence(collection);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n        if (reverse) {\n            return this.cacheResult().__iterate(fn, reverse);\n        }\n        var iterations = 0;\n        var stopped = false;\n        function flatDeep(iter, currentDepth) {\n            iter.__iterate(function(v, k) {\n                if ((!depth || currentDepth < depth) && isCollection(v)) {\n                    flatDeep(v, currentDepth + 1);\n                } else {\n                    iterations++;\n                    if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {\n                        stopped = true;\n                    }\n                }\n                return !stopped;\n            }, reverse);\n        }\n        flatDeep(collection, 0);\n        return iterations;\n    };\n    flatSequence.__iteratorUncached = function(type, reverse) {\n        if (reverse) {\n            return this.cacheResult().__iterator(type, reverse);\n        }\n        var iterator = collection.__iterator(type, reverse);\n        var stack = [];\n        var iterations = 0;\n        return new Iterator(function() {\n            while(iterator){\n                var step = iterator.next();\n                if (step.done !== false) {\n                    iterator = stack.pop();\n                    continue;\n                }\n                var v = step.value;\n                if (type === ITERATE_ENTRIES) {\n                    v = v[1];\n                }\n                if ((!depth || stack.length < depth) && isCollection(v)) {\n                    stack.push(iterator);\n                    iterator = v.__iterator(type, reverse);\n                } else {\n                    return useKeys ? step : iteratorValue(type, iterations++, v, step);\n                }\n            }\n            return iteratorDone();\n        });\n    };\n    return flatSequence;\n}\nfunction flatMapFactory(collection, mapper, context) {\n    var coerce = collectionClass(collection);\n    return collection.toSeq().map(function(v, k) {\n        return coerce(mapper.call(context, v, k, collection));\n    }).flatten(true);\n}\nfunction interposeFactory(collection, separator) {\n    var interposedSequence = makeSequence(collection);\n    interposedSequence.size = collection.size && collection.size * 2 - 1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {\n        var this$1$1 = this;\n        var iterations = 0;\n        collection.__iterate(function(v) {\n            return (!iterations || fn(separator, iterations++, this$1$1) !== false) && fn(v, iterations++, this$1$1) !== false;\n        }, reverse);\n        return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n        var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n        var iterations = 0;\n        var step;\n        return new Iterator(function() {\n            if (!step || iterations % 2) {\n                step = iterator.next();\n                if (step.done) {\n                    return step;\n                }\n            }\n            return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);\n        });\n    };\n    return interposedSequence;\n}\nfunction sortFactory(collection, comparator, mapper) {\n    if (!comparator) {\n        comparator = defaultComparator;\n    }\n    var isKeyedCollection = isKeyed(collection);\n    var index = 0;\n    var entries = collection.toSeq().map(function(v, k) {\n        return [\n            k,\n            v,\n            index++,\n            mapper ? mapper(v, k, collection) : v\n        ];\n    }).valueSeq().toArray();\n    entries.sort(function(a, b) {\n        return comparator(a[3], b[3]) || a[2] - b[2];\n    }).forEach(isKeyedCollection ? function(v, i) {\n        entries[i].length = 2;\n    } : function(v, i) {\n        entries[i] = v[1];\n    });\n    return isKeyedCollection ? KeyedSeq(entries) : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);\n}\nfunction maxFactory(collection, comparator, mapper) {\n    if (!comparator) {\n        comparator = defaultComparator;\n    }\n    if (mapper) {\n        var entry = collection.toSeq().map(function(v, k) {\n            return [\n                v,\n                mapper(v, k, collection)\n            ];\n        }).reduce(function(a, b) {\n            return maxCompare(comparator, a[1], b[1]) ? b : a;\n        });\n        return entry && entry[0];\n    }\n    return collection.reduce(function(a, b) {\n        return maxCompare(comparator, a, b) ? b : a;\n    });\n}\nfunction maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;\n}\nfunction zipWithFactory(keyIter, zipper, iters, zipAll) {\n    var zipSequence = makeSequence(keyIter);\n    var sizes = new ArraySeq(iters).map(function(i) {\n        return i.size;\n    });\n    zipSequence.size = zipAll ? sizes.max() : sizes.min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n        /* generic:\n    var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n    var step;\n    var iterations = 0;\n    while (!(step = iterator.next()).done) {\n      iterations++;\n      if (fn(step.value[1], step.value[0], this) === false) {\n        break;\n      }\n    }\n    return iterations;\n    */ // indexed:\n        var iterator = this.__iterator(ITERATE_VALUES, reverse);\n        var step;\n        var iterations = 0;\n        while(!(step = iterator.next()).done){\n            if (fn(step.value, iterations++, this) === false) {\n                break;\n            }\n        }\n        return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n        var iterators = iters.map(function(i) {\n            return i = Collection(i), getIterator(reverse ? i.reverse() : i);\n        });\n        var iterations = 0;\n        var isDone = false;\n        return new Iterator(function() {\n            var steps;\n            if (!isDone) {\n                steps = iterators.map(function(i) {\n                    return i.next();\n                });\n                isDone = zipAll ? steps.every(function(s) {\n                    return s.done;\n                }) : steps.some(function(s) {\n                    return s.done;\n                });\n            }\n            if (isDone) {\n                return iteratorDone();\n            }\n            return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function(s) {\n                return s.value;\n            })));\n        });\n    };\n    return zipSequence;\n}\n// #pragma Helper Functions\nfunction reify(iter, seq) {\n    return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n}\nfunction validateEntry(entry) {\n    if (entry !== Object(entry)) {\n        throw new TypeError(\"Expected [K, V] tuple: \" + entry);\n    }\n}\nfunction collectionClass(collection) {\n    return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;\n}\nfunction makeSequence(collection) {\n    return Object.create((isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype);\n}\nfunction cacheResultThrough() {\n    if (this._iter.cacheResult) {\n        this._iter.cacheResult();\n        this.size = this._iter.size;\n        return this;\n    }\n    return Seq.prototype.cacheResult.call(this);\n}\nfunction defaultComparator(a, b) {\n    if (a === undefined && b === undefined) {\n        return 0;\n    }\n    if (a === undefined) {\n        return 1;\n    }\n    if (b === undefined) {\n        return -1;\n    }\n    return a > b ? 1 : a < b ? -1 : 0;\n}\nfunction arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for(var ii = 0; ii < len; ii++){\n        newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n}\nfunction invariant(condition, error) {\n    if (!condition) {\n        throw new Error(error);\n    }\n}\nfunction assertNotInfinite(size) {\n    invariant(size !== Infinity, \"Cannot perform this action with an infinite size.\");\n}\nfunction coerceKeyPath(keyPath) {\n    if (isArrayLike(keyPath) && typeof keyPath !== \"string\") {\n        return keyPath;\n    }\n    if (isOrdered(keyPath)) {\n        return keyPath.toArray();\n    }\n    throw new TypeError(\"Invalid keyPath: expected Ordered Collection or Array: \" + keyPath);\n}\nvar toString = Object.prototype.toString;\nfunction isPlainObject(value) {\n    // The base prototype's toString deals with Argument objects and native namespaces like Math\n    if (!value || typeof value !== \"object\" || toString.call(value) !== \"[object Object]\") {\n        return false;\n    }\n    var proto = Object.getPrototypeOf(value);\n    if (proto === null) {\n        return true;\n    }\n    // Iteratively going up the prototype chain is needed for cross-realm environments (differing contexts, iframes, etc)\n    var parentProto = proto;\n    var nextProto = Object.getPrototypeOf(proto);\n    while(nextProto !== null){\n        parentProto = nextProto;\n        nextProto = Object.getPrototypeOf(parentProto);\n    }\n    return parentProto === proto;\n}\n/**\n * Returns true if the value is a potentially-persistent data structure, either\n * provided by Immutable.js or a plain Array or Object.\n */ function isDataStructure(value) {\n    return typeof value === \"object\" && (isImmutable(value) || Array.isArray(value) || isPlainObject(value));\n}\nfunction quoteString(value) {\n    try {\n        return typeof value === \"string\" ? JSON.stringify(value) : String(value);\n    } catch (_ignoreError) {\n        return JSON.stringify(value);\n    }\n}\nfunction has(collection, key) {\n    return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty.call(collection, key);\n}\nfunction get(collection, key, notSetValue) {\n    return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === \"function\" ? collection.get(key) : collection[key];\n}\nfunction shallowCopy(from) {\n    if (Array.isArray(from)) {\n        return arrCopy(from);\n    }\n    var to = {};\n    for(var key in from){\n        if (hasOwnProperty.call(from, key)) {\n            to[key] = from[key];\n        }\n    }\n    return to;\n}\nfunction remove(collection, key) {\n    if (!isDataStructure(collection)) {\n        throw new TypeError(\"Cannot update non-data-structure value: \" + collection);\n    }\n    if (isImmutable(collection)) {\n        if (!collection.remove) {\n            throw new TypeError(\"Cannot update immutable value without .remove() method: \" + collection);\n        }\n        return collection.remove(key);\n    }\n    if (!hasOwnProperty.call(collection, key)) {\n        return collection;\n    }\n    var collectionCopy = shallowCopy(collection);\n    if (Array.isArray(collectionCopy)) {\n        collectionCopy.splice(key, 1);\n    } else {\n        delete collectionCopy[key];\n    }\n    return collectionCopy;\n}\nfunction set(collection, key, value) {\n    if (!isDataStructure(collection)) {\n        throw new TypeError(\"Cannot update non-data-structure value: \" + collection);\n    }\n    if (isImmutable(collection)) {\n        if (!collection.set) {\n            throw new TypeError(\"Cannot update immutable value without .set() method: \" + collection);\n        }\n        return collection.set(key, value);\n    }\n    if (hasOwnProperty.call(collection, key) && value === collection[key]) {\n        return collection;\n    }\n    var collectionCopy = shallowCopy(collection);\n    collectionCopy[key] = value;\n    return collectionCopy;\n}\nfunction updateIn$1(collection, keyPath, notSetValue, updater) {\n    if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n    }\n    var updatedValue = updateInDeeply(isImmutable(collection), collection, coerceKeyPath(keyPath), 0, notSetValue, updater);\n    return updatedValue === NOT_SET ? notSetValue : updatedValue;\n}\nfunction updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {\n    var wasNotSet = existing === NOT_SET;\n    if (i === keyPath.length) {\n        var existingValue = wasNotSet ? notSetValue : existing;\n        var newValue = updater(existingValue);\n        return newValue === existingValue ? existing : newValue;\n    }\n    if (!wasNotSet && !isDataStructure(existing)) {\n        throw new TypeError(\"Cannot update within non-data-structure value in path [\" + keyPath.slice(0, i).map(quoteString) + \"]: \" + existing);\n    }\n    var key = keyPath[i];\n    var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);\n    var nextUpdated = updateInDeeply(nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting), nextExisting, keyPath, i + 1, notSetValue, updater);\n    return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(wasNotSet ? inImmutable ? emptyMap() : {} : existing, key, nextUpdated);\n}\nfunction setIn$1(collection, keyPath, value) {\n    return updateIn$1(collection, keyPath, NOT_SET, function() {\n        return value;\n    });\n}\nfunction setIn(keyPath, v) {\n    return setIn$1(this, keyPath, v);\n}\nfunction removeIn(collection, keyPath) {\n    return updateIn$1(collection, keyPath, function() {\n        return NOT_SET;\n    });\n}\nfunction deleteIn(keyPath) {\n    return removeIn(this, keyPath);\n}\nfunction update$1(collection, key, notSetValue, updater) {\n    return updateIn$1(collection, [\n        key\n    ], notSetValue, updater);\n}\nfunction update(key, notSetValue, updater) {\n    return arguments.length === 1 ? key(this) : update$1(this, key, notSetValue, updater);\n}\nfunction updateIn(keyPath, notSetValue, updater) {\n    return updateIn$1(this, keyPath, notSetValue, updater);\n}\nfunction merge$1() {\n    var iters = [], len = arguments.length;\n    while(len--)iters[len] = arguments[len];\n    return mergeIntoKeyedWith(this, iters);\n}\nfunction mergeWith$1(merger) {\n    var iters = [], len = arguments.length - 1;\n    while(len-- > 0)iters[len] = arguments[len + 1];\n    if (typeof merger !== \"function\") {\n        throw new TypeError(\"Invalid merger function: \" + merger);\n    }\n    return mergeIntoKeyedWith(this, iters, merger);\n}\nfunction mergeIntoKeyedWith(collection, collections, merger) {\n    var iters = [];\n    for(var ii = 0; ii < collections.length; ii++){\n        var collection$1 = KeyedCollection(collections[ii]);\n        if (collection$1.size !== 0) {\n            iters.push(collection$1);\n        }\n    }\n    if (iters.length === 0) {\n        return collection;\n    }\n    if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {\n        return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function(collection) {\n        var mergeIntoCollection = merger ? function(value, key) {\n            update$1(collection, key, NOT_SET, function(oldVal) {\n                return oldVal === NOT_SET ? value : merger(oldVal, value, key);\n            });\n        } : function(value, key) {\n            collection.set(key, value);\n        };\n        for(var ii = 0; ii < iters.length; ii++){\n            iters[ii].forEach(mergeIntoCollection);\n        }\n    });\n}\nfunction merge(collection) {\n    var sources = [], len = arguments.length - 1;\n    while(len-- > 0)sources[len] = arguments[len + 1];\n    return mergeWithSources(collection, sources);\n}\nfunction mergeWith(merger, collection) {\n    var sources = [], len = arguments.length - 2;\n    while(len-- > 0)sources[len] = arguments[len + 2];\n    return mergeWithSources(collection, sources, merger);\n}\nfunction mergeDeep$1(collection) {\n    var sources = [], len = arguments.length - 1;\n    while(len-- > 0)sources[len] = arguments[len + 1];\n    return mergeDeepWithSources(collection, sources);\n}\nfunction mergeDeepWith$1(merger, collection) {\n    var sources = [], len = arguments.length - 2;\n    while(len-- > 0)sources[len] = arguments[len + 2];\n    return mergeDeepWithSources(collection, sources, merger);\n}\nfunction mergeDeepWithSources(collection, sources, merger) {\n    return mergeWithSources(collection, sources, deepMergerWith(merger));\n}\nfunction mergeWithSources(collection, sources, merger) {\n    if (!isDataStructure(collection)) {\n        throw new TypeError(\"Cannot merge into non-data-structure value: \" + collection);\n    }\n    if (isImmutable(collection)) {\n        return typeof merger === \"function\" && collection.mergeWith ? collection.mergeWith.apply(collection, [\n            merger\n        ].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);\n    }\n    var isArray = Array.isArray(collection);\n    var merged = collection;\n    var Collection = isArray ? IndexedCollection : KeyedCollection;\n    var mergeItem = isArray ? function(value) {\n        // Copy on write\n        if (merged === collection) {\n            merged = shallowCopy(merged);\n        }\n        merged.push(value);\n    } : function(value, key) {\n        var hasVal = hasOwnProperty.call(merged, key);\n        var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;\n        if (!hasVal || nextVal !== merged[key]) {\n            // Copy on write\n            if (merged === collection) {\n                merged = shallowCopy(merged);\n            }\n            merged[key] = nextVal;\n        }\n    };\n    for(var i = 0; i < sources.length; i++){\n        Collection(sources[i]).forEach(mergeItem);\n    }\n    return merged;\n}\nfunction deepMergerWith(merger) {\n    function deepMerger(oldValue, newValue, key) {\n        return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [\n            newValue\n        ], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;\n    }\n    return deepMerger;\n}\n/**\n * It's unclear what the desired behavior is for merging two collections that\n * fall into separate categories between keyed, indexed, or set-like, so we only\n * consider them mergeable if they fall into the same category.\n */ function areMergeable(oldDataStructure, newDataStructure) {\n    var oldSeq = Seq(oldDataStructure);\n    var newSeq = Seq(newDataStructure);\n    // This logic assumes that a sequence can only fall into one of the three\n    // categories mentioned above (since there's no `isSetLike()` method).\n    return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);\n}\nfunction mergeDeep() {\n    var iters = [], len = arguments.length;\n    while(len--)iters[len] = arguments[len];\n    return mergeDeepWithSources(this, iters);\n}\nfunction mergeDeepWith(merger) {\n    var iters = [], len = arguments.length - 1;\n    while(len-- > 0)iters[len] = arguments[len + 1];\n    return mergeDeepWithSources(this, iters, merger);\n}\nfunction mergeIn(keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while(len-- > 0)iters[len] = arguments[len + 1];\n    return updateIn$1(this, keyPath, emptyMap(), function(m) {\n        return mergeWithSources(m, iters);\n    });\n}\nfunction mergeDeepIn(keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while(len-- > 0)iters[len] = arguments[len + 1];\n    return updateIn$1(this, keyPath, emptyMap(), function(m) {\n        return mergeDeepWithSources(m, iters);\n    });\n}\nfunction withMutations(fn) {\n    var mutable = this.asMutable();\n    fn(mutable);\n    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n}\nfunction asMutable() {\n    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n}\nfunction asImmutable() {\n    return this.__ensureOwner();\n}\nfunction wasAltered() {\n    return this.__altered;\n}\nvar Map = /*@__PURE__*/ function(KeyedCollection) {\n    function Map(value) {\n        // eslint-disable-next-line no-constructor-return\n        return value === undefined || value === null ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map) {\n            var iter = KeyedCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function(v, k) {\n                return map.set(k, v);\n            });\n        });\n    }\n    if (KeyedCollection) Map.__proto__ = KeyedCollection;\n    Map.prototype = Object.create(KeyedCollection && KeyedCollection.prototype);\n    Map.prototype.constructor = Map;\n    Map.of = function of() {\n        var keyValues = [], len = arguments.length;\n        while(len--)keyValues[len] = arguments[len];\n        return emptyMap().withMutations(function(map) {\n            for(var i = 0; i < keyValues.length; i += 2){\n                if (i + 1 >= keyValues.length) {\n                    throw new Error(\"Missing value for key: \" + keyValues[i]);\n                }\n                map.set(keyValues[i], keyValues[i + 1]);\n            }\n        });\n    };\n    Map.prototype.toString = function toString() {\n        return this.__toString(\"Map {\", \"}\");\n    };\n    // @pragma Access\n    Map.prototype.get = function get(k, notSetValue) {\n        return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;\n    };\n    // @pragma Modification\n    Map.prototype.set = function set(k, v) {\n        return updateMap(this, k, v);\n    };\n    Map.prototype.remove = function remove(k) {\n        return updateMap(this, k, NOT_SET);\n    };\n    Map.prototype.deleteAll = function deleteAll(keys) {\n        var collection = Collection(keys);\n        if (collection.size === 0) {\n            return this;\n        }\n        return this.withMutations(function(map) {\n            collection.forEach(function(key) {\n                return map.remove(key);\n            });\n        });\n    };\n    Map.prototype.clear = function clear() {\n        if (this.size === 0) {\n            return this;\n        }\n        if (this.__ownerID) {\n            this.size = 0;\n            this._root = null;\n            this.__hash = undefined;\n            this.__altered = true;\n            return this;\n        }\n        return emptyMap();\n    };\n    // @pragma Composition\n    Map.prototype.sort = function sort(comparator) {\n        // Late binding\n        return OrderedMap(sortFactory(this, comparator));\n    };\n    Map.prototype.sortBy = function sortBy(mapper, comparator) {\n        // Late binding\n        return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n    Map.prototype.map = function map(mapper, context) {\n        var this$1$1 = this;\n        return this.withMutations(function(map) {\n            map.forEach(function(value, key) {\n                map.set(key, mapper.call(context, value, key, this$1$1));\n            });\n        });\n    };\n    // @pragma Mutability\n    Map.prototype.__iterator = function __iterator(type, reverse) {\n        return new MapIterator(this, type, reverse);\n    };\n    Map.prototype.__iterate = function __iterate(fn, reverse) {\n        var this$1$1 = this;\n        var iterations = 0;\n        this._root && this._root.iterate(function(entry) {\n            iterations++;\n            return fn(entry[1], entry[0], this$1$1);\n        }, reverse);\n        return iterations;\n    };\n    Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n        if (ownerID === this.__ownerID) {\n            return this;\n        }\n        if (!ownerID) {\n            if (this.size === 0) {\n                return emptyMap();\n            }\n            this.__ownerID = ownerID;\n            this.__altered = false;\n            return this;\n        }\n        return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n    return Map;\n}(KeyedCollection);\nMap.isMap = isMap;\nvar MapPrototype = Map.prototype;\nMapPrototype[IS_MAP_SYMBOL] = true;\nMapPrototype[DELETE] = MapPrototype.remove;\nMapPrototype.removeAll = MapPrototype.deleteAll;\nMapPrototype.setIn = setIn;\nMapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;\nMapPrototype.update = update;\nMapPrototype.updateIn = updateIn;\nMapPrototype.merge = MapPrototype.concat = merge$1;\nMapPrototype.mergeWith = mergeWith$1;\nMapPrototype.mergeDeep = mergeDeep;\nMapPrototype.mergeDeepWith = mergeDeepWith;\nMapPrototype.mergeIn = mergeIn;\nMapPrototype.mergeDeepIn = mergeDeepIn;\nMapPrototype.withMutations = withMutations;\nMapPrototype.wasAltered = wasAltered;\nMapPrototype.asImmutable = asImmutable;\nMapPrototype[\"@@transducer/init\"] = MapPrototype.asMutable = asMutable;\nMapPrototype[\"@@transducer/step\"] = function(result, arr) {\n    return result.set(arr[0], arr[1]);\n};\nMapPrototype[\"@@transducer/result\"] = function(obj) {\n    return obj.asImmutable();\n};\n// #pragma Trie Nodes\nvar ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n    this.ownerID = ownerID;\n    this.entries = entries;\n};\nArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for(var ii = 0, len = entries.length; ii < len; ii++){\n        if (is(key, entries[ii][0])) {\n            return entries[ii][1];\n        }\n    }\n    return notSetValue;\n};\nArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n    for(; idx < len; idx++){\n        if (is(key, entries[idx][0])) {\n            break;\n        }\n    }\n    var exists = idx < len;\n    if (exists ? entries[idx][1] === value : removed) {\n        return this;\n    }\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n    if (removed && entries.length === 1) {\n        return; // undefined\n    }\n    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n    }\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n    if (exists) {\n        if (removed) {\n            idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n        } else {\n            newEntries[idx] = [\n                key,\n                value\n            ];\n        }\n    } else {\n        newEntries.push([\n            key,\n            value\n        ]);\n    }\n    if (isEditable) {\n        this.entries = newEntries;\n        return this;\n    }\n    return new ArrayMapNode(ownerID, newEntries);\n};\nvar BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n    this.ownerID = ownerID;\n    this.bitmap = bitmap;\n    this.nodes = nodes;\n};\nBitmapIndexedNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n        keyHash = hash(key);\n    }\n    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n    var bitmap = this.bitmap;\n    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);\n};\nBitmapIndexedNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n        keyHash = hash(key);\n    }\n    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var bit = 1 << keyHashFrag;\n    var bitmap = this.bitmap;\n    var exists = (bitmap & bit) !== 0;\n    if (!exists && value === NOT_SET) {\n        return this;\n    }\n    var idx = popCount(bitmap & bit - 1);\n    var nodes = this.nodes;\n    var node = exists ? nodes[idx] : undefined;\n    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n    if (newNode === node) {\n        return this;\n    }\n    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n    }\n    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n    }\n    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n    }\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n    var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);\n    if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n    }\n    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n};\nvar HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n    this.ownerID = ownerID;\n    this.count = count;\n    this.nodes = nodes;\n};\nHashArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n        keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var node = this.nodes[idx];\n    return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n};\nHashArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n        keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var removed = value === NOT_SET;\n    var nodes = this.nodes;\n    var node = nodes[idx];\n    if (removed && !node) {\n        return this;\n    }\n    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n    if (newNode === node) {\n        return this;\n    }\n    var newCount = this.count;\n    if (!node) {\n        newCount++;\n    } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n            return packNodes(ownerID, nodes, newCount, idx);\n        }\n    }\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newNodes = setAt(nodes, idx, newNode, isEditable);\n    if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n    }\n    return new HashArrayMapNode(ownerID, newCount, newNodes);\n};\nvar HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entries = entries;\n};\nHashCollisionNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for(var ii = 0, len = entries.length; ii < len; ii++){\n        if (is(key, entries[ii][0])) {\n            return entries[ii][1];\n        }\n    }\n    return notSetValue;\n};\nHashCollisionNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n        keyHash = hash(key);\n    }\n    var removed = value === NOT_SET;\n    if (keyHash !== this.keyHash) {\n        if (removed) {\n            return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [\n            key,\n            value\n        ]);\n    }\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n    for(; idx < len; idx++){\n        if (is(key, entries[idx][0])) {\n            break;\n        }\n    }\n    var exists = idx < len;\n    if (exists ? entries[idx][1] === value : removed) {\n        return this;\n    }\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n    if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n    }\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n    if (exists) {\n        if (removed) {\n            idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n        } else {\n            newEntries[idx] = [\n                key,\n                value\n            ];\n        }\n    } else {\n        newEntries.push([\n            key,\n            value\n        ]);\n    }\n    if (isEditable) {\n        this.entries = newEntries;\n        return this;\n    }\n    return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n};\nvar ValueNode = function ValueNode(ownerID, keyHash, entry) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entry = entry;\n};\nValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n};\nValueNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n    var keyMatch = is(key, this.entry[0]);\n    if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n    }\n    SetRef(didAlter);\n    if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n    }\n    if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n            this.entry[1] = value;\n            return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [\n            key,\n            value\n        ]);\n    }\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, hash(key), [\n        key,\n        value\n    ]);\n};\n// #pragma Iterators\nArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse) {\n    var entries = this.entries;\n    for(var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++){\n        if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n            return false;\n        }\n    }\n};\nBitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse) {\n    var nodes = this.nodes;\n    for(var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++){\n        var node = nodes[reverse ? maxIndex - ii : ii];\n        if (node && node.iterate(fn, reverse) === false) {\n            return false;\n        }\n    }\n};\n// eslint-disable-next-line no-unused-vars\nValueNode.prototype.iterate = function(fn, reverse) {\n    return fn(this.entry);\n};\nvar MapIterator = /*@__PURE__*/ function(Iterator) {\n    function MapIterator(map, type, reverse) {\n        this._type = type;\n        this._reverse = reverse;\n        this._stack = map._root && mapIteratorFrame(map._root);\n    }\n    if (Iterator) MapIterator.__proto__ = Iterator;\n    MapIterator.prototype = Object.create(Iterator && Iterator.prototype);\n    MapIterator.prototype.constructor = MapIterator;\n    MapIterator.prototype.next = function next() {\n        var type = this._type;\n        var stack = this._stack;\n        while(stack){\n            var node = stack.node;\n            var index = stack.index++;\n            var maxIndex = void 0;\n            if (node.entry) {\n                if (index === 0) {\n                    return mapIteratorValue(type, node.entry);\n                }\n            } else if (node.entries) {\n                maxIndex = node.entries.length - 1;\n                if (index <= maxIndex) {\n                    return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n                }\n            } else {\n                maxIndex = node.nodes.length - 1;\n                if (index <= maxIndex) {\n                    var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n                    if (subNode) {\n                        if (subNode.entry) {\n                            return mapIteratorValue(type, subNode.entry);\n                        }\n                        stack = this._stack = mapIteratorFrame(subNode, stack);\n                    }\n                    continue;\n                }\n            }\n            stack = this._stack = this._stack.__prev;\n        }\n        return iteratorDone();\n    };\n    return MapIterator;\n}(Iterator);\nfunction mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n}\nfunction mapIteratorFrame(node, prev) {\n    return {\n        node: node,\n        index: 0,\n        __prev: prev\n    };\n}\nfunction makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n}\nvar EMPTY_MAP;\nfunction emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n}\nfunction updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n        if (v === NOT_SET) {\n            return map;\n        }\n        newSize = 1;\n        newRoot = new ArrayMapNode(map.__ownerID, [\n            [\n                k,\n                v\n            ]\n        ]);\n    } else {\n        var didChangeSize = MakeRef();\n        var didAlter = MakeRef();\n        newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n        if (!didAlter.value) {\n            return map;\n        }\n        newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n        map.size = newSize;\n        map._root = newRoot;\n        map.__hash = undefined;\n        map.__altered = true;\n        return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n}\nfunction updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n        if (value === NOT_SET) {\n            return node;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return new ValueNode(ownerID, keyHash, [\n            key,\n            value\n        ]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n}\nfunction isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n}\nfunction mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n        return new HashCollisionNode(ownerID, keyHash, [\n            node.entry,\n            entry\n        ]);\n    }\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var newNode;\n    var nodes = idx1 === idx2 ? [\n        mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)\n    ] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [\n        node,\n        newNode\n    ] : [\n        newNode,\n        node\n    ]);\n    return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);\n}\nfunction createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n        ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [\n        key,\n        value\n    ]);\n    for(var ii = 0; ii < entries.length; ii++){\n        var entry = entries[ii];\n        node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n}\nfunction packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for(var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1){\n        var node = nodes[ii];\n        if (node !== undefined && ii !== excluding) {\n            bitmap |= bit;\n            packedNodes[packedII++] = node;\n        }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n}\nfunction expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for(var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1){\n        expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n}\nfunction popCount(x) {\n    x -= x >> 1 & 0x55555555;\n    x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n    x = x + (x >> 4) & 0x0f0f0f0f;\n    x += x >> 8;\n    x += x >> 16;\n    return x & 0x7f;\n}\nfunction setAt(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n}\nfunction spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n        array[idx] = val;\n        return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for(var ii = 0; ii < newLen; ii++){\n        if (ii === idx) {\n            newArray[ii] = val;\n            after = -1;\n        } else {\n            newArray[ii] = array[ii + after];\n        }\n    }\n    return newArray;\n}\nfunction spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n        array.pop();\n        return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for(var ii = 0; ii < newLen; ii++){\n        if (ii === idx) {\n            after = 1;\n        }\n        newArray[ii] = array[ii + after];\n    }\n    return newArray;\n}\nvar MAX_ARRAY_MAP_SIZE = SIZE / 4;\nvar MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\nvar MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\nvar IS_LIST_SYMBOL = \"@@__IMMUTABLE_LIST__@@\";\nfunction isList(maybeList) {\n    return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);\n}\nvar List = /*@__PURE__*/ function(IndexedCollection) {\n    function List(value) {\n        var empty = emptyList();\n        if (value === undefined || value === null) {\n            // eslint-disable-next-line no-constructor-return\n            return empty;\n        }\n        if (isList(value)) {\n            // eslint-disable-next-line no-constructor-return\n            return value;\n        }\n        var iter = IndexedCollection(value);\n        var size = iter.size;\n        if (size === 0) {\n            // eslint-disable-next-line no-constructor-return\n            return empty;\n        }\n        assertNotInfinite(size);\n        if (size > 0 && size < SIZE) {\n            // eslint-disable-next-line no-constructor-return\n            return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n        }\n        // eslint-disable-next-line no-constructor-return\n        return empty.withMutations(function(list) {\n            list.setSize(size);\n            iter.forEach(function(v, i) {\n                return list.set(i, v);\n            });\n        });\n    }\n    if (IndexedCollection) List.__proto__ = IndexedCollection;\n    List.prototype = Object.create(IndexedCollection && IndexedCollection.prototype);\n    List.prototype.constructor = List;\n    List.of = function of() {\n        return this(arguments);\n    };\n    List.prototype.toString = function toString() {\n        return this.__toString(\"List [\", \"]\");\n    };\n    // @pragma Access\n    List.prototype.get = function get(index, notSetValue) {\n        index = wrapIndex(this, index);\n        if (index >= 0 && index < this.size) {\n            index += this._origin;\n            var node = listNodeFor(this, index);\n            return node && node.array[index & MASK];\n        }\n        return notSetValue;\n    };\n    // @pragma Modification\n    List.prototype.set = function set(index, value) {\n        return updateList(this, index, value);\n    };\n    List.prototype.remove = function remove(index) {\n        return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);\n    };\n    List.prototype.insert = function insert(index, value) {\n        return this.splice(index, 0, value);\n    };\n    List.prototype.clear = function clear() {\n        if (this.size === 0) {\n            return this;\n        }\n        if (this.__ownerID) {\n            this.size = this._origin = this._capacity = 0;\n            this._level = SHIFT;\n            this._root = this._tail = this.__hash = undefined;\n            this.__altered = true;\n            return this;\n        }\n        return emptyList();\n    };\n    List.prototype.push = function push() {\n        var values = arguments;\n        var oldSize = this.size;\n        return this.withMutations(function(list) {\n            setListBounds(list, 0, oldSize + values.length);\n            for(var ii = 0; ii < values.length; ii++){\n                list.set(oldSize + ii, values[ii]);\n            }\n        });\n    };\n    List.prototype.pop = function pop() {\n        return setListBounds(this, 0, -1);\n    };\n    List.prototype.unshift = function unshift() {\n        var values = arguments;\n        return this.withMutations(function(list) {\n            setListBounds(list, -values.length);\n            for(var ii = 0; ii < values.length; ii++){\n                list.set(ii, values[ii]);\n            }\n        });\n    };\n    List.prototype.shift = function shift() {\n        return setListBounds(this, 1);\n    };\n    // @pragma Composition\n    List.prototype.concat = function concat() {\n        var arguments$1 = arguments;\n        var seqs = [];\n        for(var i = 0; i < arguments.length; i++){\n            var argument = arguments$1[i];\n            var seq = IndexedCollection(typeof argument !== \"string\" && hasIterator(argument) ? argument : [\n                argument\n            ]);\n            if (seq.size !== 0) {\n                seqs.push(seq);\n            }\n        }\n        if (seqs.length === 0) {\n            return this;\n        }\n        if (this.size === 0 && !this.__ownerID && seqs.length === 1) {\n            return this.constructor(seqs[0]);\n        }\n        return this.withMutations(function(list) {\n            seqs.forEach(function(seq) {\n                return seq.forEach(function(value) {\n                    return list.push(value);\n                });\n            });\n        });\n    };\n    List.prototype.setSize = function setSize(size) {\n        return setListBounds(this, 0, size);\n    };\n    List.prototype.map = function map(mapper, context) {\n        var this$1$1 = this;\n        return this.withMutations(function(list) {\n            for(var i = 0; i < this$1$1.size; i++){\n                list.set(i, mapper.call(context, list.get(i), i, this$1$1));\n            }\n        });\n    };\n    // @pragma Iteration\n    List.prototype.slice = function slice(begin, end) {\n        var size = this.size;\n        if (wholeSlice(begin, end, size)) {\n            return this;\n        }\n        return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));\n    };\n    List.prototype.__iterator = function __iterator(type, reverse) {\n        var index = reverse ? this.size : 0;\n        var values = iterateList(this, reverse);\n        return new Iterator(function() {\n            var value = values();\n            return value === DONE ? iteratorDone() : iteratorValue(type, reverse ? --index : index++, value);\n        });\n    };\n    List.prototype.__iterate = function __iterate(fn, reverse) {\n        var index = reverse ? this.size : 0;\n        var values = iterateList(this, reverse);\n        var value;\n        while((value = values()) !== DONE){\n            if (fn(value, reverse ? --index : index++, this) === false) {\n                break;\n            }\n        }\n        return index;\n    };\n    List.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n        if (ownerID === this.__ownerID) {\n            return this;\n        }\n        if (!ownerID) {\n            if (this.size === 0) {\n                return emptyList();\n            }\n            this.__ownerID = ownerID;\n            this.__altered = false;\n            return this;\n        }\n        return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n    return List;\n}(IndexedCollection);\nList.isList = isList;\nvar ListPrototype = List.prototype;\nListPrototype[IS_LIST_SYMBOL] = true;\nListPrototype[DELETE] = ListPrototype.remove;\nListPrototype.merge = ListPrototype.concat;\nListPrototype.setIn = setIn;\nListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;\nListPrototype.update = update;\nListPrototype.updateIn = updateIn;\nListPrototype.mergeIn = mergeIn;\nListPrototype.mergeDeepIn = mergeDeepIn;\nListPrototype.withMutations = withMutations;\nListPrototype.wasAltered = wasAltered;\nListPrototype.asImmutable = asImmutable;\nListPrototype[\"@@transducer/init\"] = ListPrototype.asMutable = asMutable;\nListPrototype[\"@@transducer/step\"] = function(result, arr) {\n    return result.push(arr);\n};\nListPrototype[\"@@transducer/result\"] = function(obj) {\n    return obj.asImmutable();\n};\nvar VNode = function VNode(array, ownerID) {\n    this.array = array;\n    this.ownerID = ownerID;\n};\n// TODO: seems like these methods are very similar\nVNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {\n    if (index === level ? 1 << level : this.array.length === 0) {\n        return this;\n    }\n    var originIndex = index >>> level & MASK;\n    if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n    }\n    var removingFirst = originIndex === 0;\n    var newChild;\n    if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n            return this;\n        }\n    }\n    if (removingFirst && !newChild) {\n        return this;\n    }\n    var editable = editableVNode(this, ownerID);\n    if (!removingFirst) {\n        for(var ii = 0; ii < originIndex; ii++){\n            editable.array[ii] = undefined;\n        }\n    }\n    if (newChild) {\n        editable.array[originIndex] = newChild;\n    }\n    return editable;\n};\nVNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {\n    if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n        return this;\n    }\n    var sizeIndex = index - 1 >>> level & MASK;\n    if (sizeIndex >= this.array.length) {\n        return this;\n    }\n    var newChild;\n    if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n            return this;\n        }\n    }\n    var editable = editableVNode(this, ownerID);\n    editable.array.splice(sizeIndex + 1);\n    if (newChild) {\n        editable.array[sizeIndex] = newChild;\n    }\n    return editable;\n};\nvar DONE = {};\nfunction iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n    function iterateNodeOrLeaf(node, level, offset) {\n        return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);\n    }\n    function iterateLeaf(node, offset) {\n        var array = offset === tailPos ? tail && tail.array : node && node.array;\n        var from = offset > left ? 0 : left - offset;\n        var to = right - offset;\n        if (to > SIZE) {\n            to = SIZE;\n        }\n        return function() {\n            if (from === to) {\n                return DONE;\n            }\n            var idx = reverse ? --to : from++;\n            return array && array[idx];\n        };\n    }\n    function iterateNode(node, level, offset) {\n        var values;\n        var array = node && node.array;\n        var from = offset > left ? 0 : left - offset >> level;\n        var to = (right - offset >> level) + 1;\n        if (to > SIZE) {\n            to = SIZE;\n        }\n        return function() {\n            while(true){\n                if (values) {\n                    var value = values();\n                    if (value !== DONE) {\n                        return value;\n                    }\n                    values = null;\n                }\n                if (from === to) {\n                    return DONE;\n                }\n                var idx = reverse ? --to : from++;\n                values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));\n            }\n        };\n    }\n}\nfunction makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n}\nvar EMPTY_LIST;\nfunction emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n}\nfunction updateList(list, index, value) {\n    index = wrapIndex(list, index);\n    if (index !== index) {\n        return list;\n    }\n    if (index >= list.size || index < 0) {\n        return list.withMutations(function(list) {\n            index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);\n        });\n    }\n    index += list._origin;\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef();\n    if (index >= getTailOffset(list._capacity)) {\n        newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n        newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n    if (!didAlter.value) {\n        return list;\n    }\n    if (list.__ownerID) {\n        list._root = newRoot;\n        list._tail = newTail;\n        list.__hash = undefined;\n        list.__altered = true;\n        return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n}\nfunction updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = index >>> level & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n        return node;\n    }\n    var newNode;\n    if (level > 0) {\n        var lowerNode = node && node.array[idx];\n        var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n        if (newLowerNode === lowerNode) {\n            return node;\n        }\n        newNode = editableVNode(node, ownerID);\n        newNode.array[idx] = newLowerNode;\n        return newNode;\n    }\n    if (nodeHas && node.array[idx] === value) {\n        return node;\n    }\n    if (didAlter) {\n        SetRef(didAlter);\n    }\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n        newNode.array.pop();\n    } else {\n        newNode.array[idx] = value;\n    }\n    return newNode;\n}\nfunction editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n        return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n}\nfunction listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n        return list._tail;\n    }\n    if (rawIndex < 1 << list._level + SHIFT) {\n        var node = list._root;\n        var level = list._level;\n        while(node && level > 0){\n            node = node.array[rawIndex >>> level & MASK];\n            level -= SHIFT;\n        }\n        return node;\n    }\n}\nfunction setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n        begin |= 0;\n    }\n    if (end !== undefined) {\n        end |= 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n        return list;\n    }\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n        return list.clear();\n    }\n    var newLevel = list._level;\n    var newRoot = list._root;\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while(newOrigin + offsetShift < 0){\n        newRoot = new VNode(newRoot && newRoot.array.length ? [\n            undefined,\n            newRoot\n        ] : [], owner);\n        newLevel += SHIFT;\n        offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n        newOrigin += offsetShift;\n        oldOrigin += offsetShift;\n        newCapacity += offsetShift;\n        oldCapacity += offsetShift;\n    }\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n    // New size might need creating a higher root.\n    while(newTailOffset >= 1 << newLevel + SHIFT){\n        newRoot = new VNode(newRoot && newRoot.array.length ? [\n            newRoot\n        ] : [], owner);\n        newLevel += SHIFT;\n    }\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n        newRoot = editableVNode(newRoot, owner);\n        var node = newRoot;\n        for(var level = newLevel; level > SHIFT; level -= SHIFT){\n            var idx = oldTailOffset >>> level & MASK;\n            node = node.array[idx] = editableVNode(node.array[idx], owner);\n        }\n        node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;\n    }\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n        newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n        newOrigin -= newTailOffset;\n        newCapacity -= newTailOffset;\n        newLevel = SHIFT;\n        newRoot = null;\n        newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n    // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n        offsetShift = 0;\n        // Identify the new top root node of the subtree of the old root.\n        while(newRoot){\n            var beginIndex = newOrigin >>> newLevel & MASK;\n            if (beginIndex !== newTailOffset >>> newLevel & MASK) {\n                break;\n            }\n            if (beginIndex) {\n                offsetShift += (1 << newLevel) * beginIndex;\n            }\n            newLevel -= SHIFT;\n            newRoot = newRoot.array[beginIndex];\n        }\n        // Trim the new sides of the new root.\n        if (newRoot && newOrigin > oldOrigin) {\n            newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n        }\n        if (newRoot && newTailOffset < oldTailOffset) {\n            newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n        }\n        if (offsetShift) {\n            newOrigin -= offsetShift;\n            newCapacity -= offsetShift;\n        }\n    }\n    if (list.__ownerID) {\n        list.size = newCapacity - newOrigin;\n        list._origin = newOrigin;\n        list._capacity = newCapacity;\n        list._level = newLevel;\n        list._root = newRoot;\n        list._tail = newTail;\n        list.__hash = undefined;\n        list.__altered = true;\n        return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n}\nfunction getTailOffset(size) {\n    return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;\n}\nvar OrderedMap = /*@__PURE__*/ function(Map) {\n    function OrderedMap(value) {\n        // eslint-disable-next-line no-constructor-return\n        return value === undefined || value === null ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map) {\n            var iter = KeyedCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function(v, k) {\n                return map.set(k, v);\n            });\n        });\n    }\n    if (Map) OrderedMap.__proto__ = Map;\n    OrderedMap.prototype = Object.create(Map && Map.prototype);\n    OrderedMap.prototype.constructor = OrderedMap;\n    OrderedMap.of = function of() {\n        return this(arguments);\n    };\n    OrderedMap.prototype.toString = function toString() {\n        return this.__toString(\"OrderedMap {\", \"}\");\n    };\n    // @pragma Access\n    OrderedMap.prototype.get = function get(k, notSetValue) {\n        var index = this._map.get(k);\n        return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n    // @pragma Modification\n    OrderedMap.prototype.clear = function clear() {\n        if (this.size === 0) {\n            return this;\n        }\n        if (this.__ownerID) {\n            this.size = 0;\n            this._map.clear();\n            this._list.clear();\n            this.__altered = true;\n            return this;\n        }\n        return emptyOrderedMap();\n    };\n    OrderedMap.prototype.set = function set(k, v) {\n        return updateOrderedMap(this, k, v);\n    };\n    OrderedMap.prototype.remove = function remove(k) {\n        return updateOrderedMap(this, k, NOT_SET);\n    };\n    OrderedMap.prototype.__iterate = function __iterate(fn, reverse) {\n        var this$1$1 = this;\n        return this._list.__iterate(function(entry) {\n            return entry && fn(entry[1], entry[0], this$1$1);\n        }, reverse);\n    };\n    OrderedMap.prototype.__iterator = function __iterator(type, reverse) {\n        return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n    OrderedMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n        if (ownerID === this.__ownerID) {\n            return this;\n        }\n        var newMap = this._map.__ensureOwner(ownerID);\n        var newList = this._list.__ensureOwner(ownerID);\n        if (!ownerID) {\n            if (this.size === 0) {\n                return emptyOrderedMap();\n            }\n            this.__ownerID = ownerID;\n            this.__altered = false;\n            this._map = newMap;\n            this._list = newList;\n            return this;\n        }\n        return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n    return OrderedMap;\n}(Map);\nOrderedMap.isOrderedMap = isOrderedMap;\nOrderedMap.prototype[IS_ORDERED_SYMBOL] = true;\nOrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\nfunction makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    omap.__altered = false;\n    return omap;\n}\nvar EMPTY_ORDERED_MAP;\nfunction emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n}\nfunction updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) {\n        // removed\n        if (!has) {\n            return omap;\n        }\n        if (list.size >= SIZE && list.size >= map.size * 2) {\n            newList = list.filter(function(entry, idx) {\n                return entry !== undefined && i !== idx;\n            });\n            newMap = newList.toKeyedSeq().map(function(entry) {\n                return entry[0];\n            }).flip().toMap();\n            if (omap.__ownerID) {\n                newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n            }\n        } else {\n            newMap = map.remove(k);\n            newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n        }\n    } else if (has) {\n        if (v === list.get(i)[1]) {\n            return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [\n            k,\n            v\n        ]);\n    } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [\n            k,\n            v\n        ]);\n    }\n    if (omap.__ownerID) {\n        omap.size = newMap.size;\n        omap._map = newMap;\n        omap._list = newList;\n        omap.__hash = undefined;\n        omap.__altered = true;\n        return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n}\nvar IS_STACK_SYMBOL = \"@@__IMMUTABLE_STACK__@@\";\nfunction isStack(maybeStack) {\n    return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);\n}\nvar Stack = /*@__PURE__*/ function(IndexedCollection) {\n    function Stack(value) {\n        // eslint-disable-next-line no-constructor-return\n        return value === undefined || value === null ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);\n    }\n    if (IndexedCollection) Stack.__proto__ = IndexedCollection;\n    Stack.prototype = Object.create(IndexedCollection && IndexedCollection.prototype);\n    Stack.prototype.constructor = Stack;\n    Stack.of = function of() {\n        return this(arguments);\n    };\n    Stack.prototype.toString = function toString() {\n        return this.__toString(\"Stack [\", \"]\");\n    };\n    // @pragma Access\n    Stack.prototype.get = function get(index, notSetValue) {\n        var head = this._head;\n        index = wrapIndex(this, index);\n        while(head && index--){\n            head = head.next;\n        }\n        return head ? head.value : notSetValue;\n    };\n    Stack.prototype.peek = function peek() {\n        return this._head && this._head.value;\n    };\n    // @pragma Modification\n    Stack.prototype.push = function push() {\n        var arguments$1 = arguments;\n        if (arguments.length === 0) {\n            return this;\n        }\n        var newSize = this.size + arguments.length;\n        var head = this._head;\n        for(var ii = arguments.length - 1; ii >= 0; ii--){\n            head = {\n                value: arguments$1[ii],\n                next: head\n            };\n        }\n        if (this.__ownerID) {\n            this.size = newSize;\n            this._head = head;\n            this.__hash = undefined;\n            this.__altered = true;\n            return this;\n        }\n        return makeStack(newSize, head);\n    };\n    Stack.prototype.pushAll = function pushAll(iter) {\n        iter = IndexedCollection(iter);\n        if (iter.size === 0) {\n            return this;\n        }\n        if (this.size === 0 && isStack(iter)) {\n            return iter;\n        }\n        assertNotInfinite(iter.size);\n        var newSize = this.size;\n        var head = this._head;\n        iter.__iterate(function(value) {\n            newSize++;\n            head = {\n                value: value,\n                next: head\n            };\n        }, /* reverse */ true);\n        if (this.__ownerID) {\n            this.size = newSize;\n            this._head = head;\n            this.__hash = undefined;\n            this.__altered = true;\n            return this;\n        }\n        return makeStack(newSize, head);\n    };\n    Stack.prototype.pop = function pop() {\n        return this.slice(1);\n    };\n    Stack.prototype.clear = function clear() {\n        if (this.size === 0) {\n            return this;\n        }\n        if (this.__ownerID) {\n            this.size = 0;\n            this._head = undefined;\n            this.__hash = undefined;\n            this.__altered = true;\n            return this;\n        }\n        return emptyStack();\n    };\n    Stack.prototype.slice = function slice(begin, end) {\n        if (wholeSlice(begin, end, this.size)) {\n            return this;\n        }\n        var resolvedBegin = resolveBegin(begin, this.size);\n        var resolvedEnd = resolveEnd(end, this.size);\n        if (resolvedEnd !== this.size) {\n            // super.slice(begin, end);\n            return IndexedCollection.prototype.slice.call(this, begin, end);\n        }\n        var newSize = this.size - resolvedBegin;\n        var head = this._head;\n        while(resolvedBegin--){\n            head = head.next;\n        }\n        if (this.__ownerID) {\n            this.size = newSize;\n            this._head = head;\n            this.__hash = undefined;\n            this.__altered = true;\n            return this;\n        }\n        return makeStack(newSize, head);\n    };\n    // @pragma Mutability\n    Stack.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n        if (ownerID === this.__ownerID) {\n            return this;\n        }\n        if (!ownerID) {\n            if (this.size === 0) {\n                return emptyStack();\n            }\n            this.__ownerID = ownerID;\n            this.__altered = false;\n            return this;\n        }\n        return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n    // @pragma Iteration\n    Stack.prototype.__iterate = function __iterate(fn, reverse) {\n        var this$1$1 = this;\n        if (reverse) {\n            return new ArraySeq(this.toArray()).__iterate(function(v, k) {\n                return fn(v, k, this$1$1);\n            }, reverse);\n        }\n        var iterations = 0;\n        var node = this._head;\n        while(node){\n            if (fn(node.value, iterations++, this) === false) {\n                break;\n            }\n            node = node.next;\n        }\n        return iterations;\n    };\n    Stack.prototype.__iterator = function __iterator(type, reverse) {\n        if (reverse) {\n            return new ArraySeq(this.toArray()).__iterator(type, reverse);\n        }\n        var iterations = 0;\n        var node = this._head;\n        return new Iterator(function() {\n            if (node) {\n                var value = node.value;\n                node = node.next;\n                return iteratorValue(type, iterations++, value);\n            }\n            return iteratorDone();\n        });\n    };\n    return Stack;\n}(IndexedCollection);\nStack.isStack = isStack;\nvar StackPrototype = Stack.prototype;\nStackPrototype[IS_STACK_SYMBOL] = true;\nStackPrototype.shift = StackPrototype.pop;\nStackPrototype.unshift = StackPrototype.push;\nStackPrototype.unshiftAll = StackPrototype.pushAll;\nStackPrototype.withMutations = withMutations;\nStackPrototype.wasAltered = wasAltered;\nStackPrototype.asImmutable = asImmutable;\nStackPrototype[\"@@transducer/init\"] = StackPrototype.asMutable = asMutable;\nStackPrototype[\"@@transducer/step\"] = function(result, arr) {\n    return result.unshift(arr);\n};\nStackPrototype[\"@@transducer/result\"] = function(obj) {\n    return obj.asImmutable();\n};\nfunction makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n}\nvar EMPTY_STACK;\nfunction emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n}\nvar IS_SET_SYMBOL = \"@@__IMMUTABLE_SET__@@\";\nfunction isSet(maybeSet) {\n    return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);\n}\nfunction isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n}\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (!isCollection(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {\n        return false;\n    }\n    if (a.size === 0 && b.size === 0) {\n        return true;\n    }\n    var notAssociative = !isAssociative(a);\n    if (isOrdered(a)) {\n        var entries = a.entries();\n        return b.every(function(v, k) {\n            var entry = entries.next().value;\n            return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n        }) && entries.next().done;\n    }\n    var flipped = false;\n    if (a.size === undefined) {\n        if (b.size === undefined) {\n            if (typeof a.cacheResult === \"function\") {\n                a.cacheResult();\n            }\n        } else {\n            flipped = true;\n            var _ = a;\n            a = b;\n            b = _;\n        }\n    }\n    var allEqual = true;\n    var bSize = b.__iterate(function(v, k) {\n        if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n            allEqual = false;\n            return false;\n        }\n    });\n    return allEqual && a.size === bSize;\n}\nfunction mixin(ctor, methods) {\n    var keyCopier = function(key) {\n        ctor.prototype[key] = methods[key];\n    };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n}\nfunction toJS(value) {\n    if (!value || typeof value !== \"object\") {\n        return value;\n    }\n    if (!isCollection(value)) {\n        if (!isDataStructure(value)) {\n            return value;\n        }\n        value = Seq(value);\n    }\n    if (isKeyed(value)) {\n        var result$1 = {};\n        value.__iterate(function(v, k) {\n            result$1[k] = toJS(v);\n        });\n        return result$1;\n    }\n    var result = [];\n    value.__iterate(function(v) {\n        result.push(toJS(v));\n    });\n    return result;\n}\nvar Set = /*@__PURE__*/ function(SetCollection) {\n    function Set(value) {\n        // eslint-disable-next-line no-constructor-return\n        return value === undefined || value === null ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set) {\n            var iter = SetCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function(v) {\n                return set.add(v);\n            });\n        });\n    }\n    if (SetCollection) Set.__proto__ = SetCollection;\n    Set.prototype = Object.create(SetCollection && SetCollection.prototype);\n    Set.prototype.constructor = Set;\n    Set.of = function of() {\n        return this(arguments);\n    };\n    Set.fromKeys = function fromKeys(value) {\n        return this(KeyedCollection(value).keySeq());\n    };\n    Set.intersect = function intersect(sets) {\n        sets = Collection(sets).toArray();\n        return sets.length ? SetPrototype.intersect.apply(Set(sets.pop()), sets) : emptySet();\n    };\n    Set.union = function union(sets) {\n        sets = Collection(sets).toArray();\n        return sets.length ? SetPrototype.union.apply(Set(sets.pop()), sets) : emptySet();\n    };\n    Set.prototype.toString = function toString() {\n        return this.__toString(\"Set {\", \"}\");\n    };\n    // @pragma Access\n    Set.prototype.has = function has(value) {\n        return this._map.has(value);\n    };\n    // @pragma Modification\n    Set.prototype.add = function add(value) {\n        return updateSet(this, this._map.set(value, value));\n    };\n    Set.prototype.remove = function remove(value) {\n        return updateSet(this, this._map.remove(value));\n    };\n    Set.prototype.clear = function clear() {\n        return updateSet(this, this._map.clear());\n    };\n    // @pragma Composition\n    Set.prototype.map = function map(mapper, context) {\n        var this$1$1 = this;\n        // keep track if the set is altered by the map function\n        var didChanges = false;\n        var newMap = updateSet(this, this._map.mapEntries(function(ref) {\n            var v = ref[1];\n            var mapped = mapper.call(context, v, v, this$1$1);\n            if (mapped !== v) {\n                didChanges = true;\n            }\n            return [\n                mapped,\n                mapped\n            ];\n        }, context));\n        return didChanges ? newMap : this;\n    };\n    Set.prototype.union = function union() {\n        var iters = [], len = arguments.length;\n        while(len--)iters[len] = arguments[len];\n        iters = iters.filter(function(x) {\n            return x.size !== 0;\n        });\n        if (iters.length === 0) {\n            return this;\n        }\n        if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n            return this.constructor(iters[0]);\n        }\n        return this.withMutations(function(set) {\n            for(var ii = 0; ii < iters.length; ii++){\n                if (typeof iters[ii] === \"string\") {\n                    set.add(iters[ii]);\n                } else {\n                    SetCollection(iters[ii]).forEach(function(value) {\n                        return set.add(value);\n                    });\n                }\n            }\n        });\n    };\n    Set.prototype.intersect = function intersect() {\n        var iters = [], len = arguments.length;\n        while(len--)iters[len] = arguments[len];\n        if (iters.length === 0) {\n            return this;\n        }\n        iters = iters.map(function(iter) {\n            return SetCollection(iter);\n        });\n        var toRemove = [];\n        this.forEach(function(value) {\n            if (!iters.every(function(iter) {\n                return iter.includes(value);\n            })) {\n                toRemove.push(value);\n            }\n        });\n        return this.withMutations(function(set) {\n            toRemove.forEach(function(value) {\n                set.remove(value);\n            });\n        });\n    };\n    Set.prototype.subtract = function subtract() {\n        var iters = [], len = arguments.length;\n        while(len--)iters[len] = arguments[len];\n        if (iters.length === 0) {\n            return this;\n        }\n        iters = iters.map(function(iter) {\n            return SetCollection(iter);\n        });\n        var toRemove = [];\n        this.forEach(function(value) {\n            if (iters.some(function(iter) {\n                return iter.includes(value);\n            })) {\n                toRemove.push(value);\n            }\n        });\n        return this.withMutations(function(set) {\n            toRemove.forEach(function(value) {\n                set.remove(value);\n            });\n        });\n    };\n    Set.prototype.sort = function sort(comparator) {\n        // Late binding\n        return OrderedSet(sortFactory(this, comparator));\n    };\n    Set.prototype.sortBy = function sortBy(mapper, comparator) {\n        // Late binding\n        return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n    Set.prototype.wasAltered = function wasAltered() {\n        return this._map.wasAltered();\n    };\n    Set.prototype.__iterate = function __iterate(fn, reverse) {\n        var this$1$1 = this;\n        return this._map.__iterate(function(k) {\n            return fn(k, k, this$1$1);\n        }, reverse);\n    };\n    Set.prototype.__iterator = function __iterator(type, reverse) {\n        return this._map.__iterator(type, reverse);\n    };\n    Set.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n        if (ownerID === this.__ownerID) {\n            return this;\n        }\n        var newMap = this._map.__ensureOwner(ownerID);\n        if (!ownerID) {\n            if (this.size === 0) {\n                return this.__empty();\n            }\n            this.__ownerID = ownerID;\n            this._map = newMap;\n            return this;\n        }\n        return this.__make(newMap, ownerID);\n    };\n    return Set;\n}(SetCollection);\nSet.isSet = isSet;\nvar SetPrototype = Set.prototype;\nSetPrototype[IS_SET_SYMBOL] = true;\nSetPrototype[DELETE] = SetPrototype.remove;\nSetPrototype.merge = SetPrototype.concat = SetPrototype.union;\nSetPrototype.withMutations = withMutations;\nSetPrototype.asImmutable = asImmutable;\nSetPrototype[\"@@transducer/init\"] = SetPrototype.asMutable = asMutable;\nSetPrototype[\"@@transducer/step\"] = function(result, arr) {\n    return result.add(arr);\n};\nSetPrototype[\"@@transducer/result\"] = function(obj) {\n    return obj.asImmutable();\n};\nSetPrototype.__empty = emptySet;\nSetPrototype.__make = makeSet;\nfunction updateSet(set, newMap) {\n    if (set.__ownerID) {\n        set.size = newMap.size;\n        set._map = newMap;\n        return set;\n    }\n    return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);\n}\nfunction makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n}\nvar EMPTY_SET;\nfunction emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n}\n/**\n * Returns a lazy seq of nums from start (inclusive) to end\n * (exclusive), by step, where start defaults to 0, step to 1, and end to\n * infinity. When start is equal to end, returns empty list.\n */ var Range = /*@__PURE__*/ function(IndexedSeq) {\n    function Range(start, end, step) {\n        if (!(this instanceof Range)) {\n            // eslint-disable-next-line no-constructor-return\n            return new Range(start, end, step);\n        }\n        invariant(step !== 0, \"Cannot step a Range by 0\");\n        start = start || 0;\n        if (end === undefined) {\n            end = Infinity;\n        }\n        step = step === undefined ? 1 : Math.abs(step);\n        if (end < start) {\n            step = -step;\n        }\n        this._start = start;\n        this._end = end;\n        this._step = step;\n        this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n        if (this.size === 0) {\n            if (EMPTY_RANGE) {\n                // eslint-disable-next-line no-constructor-return\n                return EMPTY_RANGE;\n            }\n            EMPTY_RANGE = this;\n        }\n    }\n    if (IndexedSeq) Range.__proto__ = IndexedSeq;\n    Range.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n    Range.prototype.constructor = Range;\n    Range.prototype.toString = function toString() {\n        if (this.size === 0) {\n            return \"Range []\";\n        }\n        return \"Range [ \" + this._start + \"...\" + this._end + (this._step !== 1 ? \" by \" + this._step : \"\") + \" ]\";\n    };\n    Range.prototype.get = function get(index, notSetValue) {\n        return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;\n    };\n    Range.prototype.includes = function includes(searchValue) {\n        var possibleIndex = (searchValue - this._start) / this._step;\n        return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);\n    };\n    Range.prototype.slice = function slice(begin, end) {\n        if (wholeSlice(begin, end, this.size)) {\n            return this;\n        }\n        begin = resolveBegin(begin, this.size);\n        end = resolveEnd(end, this.size);\n        if (end <= begin) {\n            return new Range(0, 0);\n        }\n        return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n    Range.prototype.indexOf = function indexOf(searchValue) {\n        var offsetValue = searchValue - this._start;\n        if (offsetValue % this._step === 0) {\n            var index = offsetValue / this._step;\n            if (index >= 0 && index < this.size) {\n                return index;\n            }\n        }\n        return -1;\n    };\n    Range.prototype.lastIndexOf = function lastIndexOf(searchValue) {\n        return this.indexOf(searchValue);\n    };\n    Range.prototype.__iterate = function __iterate(fn, reverse) {\n        var size = this.size;\n        var step = this._step;\n        var value = reverse ? this._start + (size - 1) * step : this._start;\n        var i = 0;\n        while(i !== size){\n            if (fn(value, reverse ? size - ++i : i++, this) === false) {\n                break;\n            }\n            value += reverse ? -step : step;\n        }\n        return i;\n    };\n    Range.prototype.__iterator = function __iterator(type, reverse) {\n        var size = this.size;\n        var step = this._step;\n        var value = reverse ? this._start + (size - 1) * step : this._start;\n        var i = 0;\n        return new Iterator(function() {\n            if (i === size) {\n                return iteratorDone();\n            }\n            var v = value;\n            value += reverse ? -step : step;\n            return iteratorValue(type, reverse ? size - ++i : i++, v);\n        });\n    };\n    Range.prototype.equals = function equals(other) {\n        return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);\n    };\n    return Range;\n}(IndexedSeq);\nvar EMPTY_RANGE;\nfunction getIn$1(collection, searchKeyPath, notSetValue) {\n    var keyPath = coerceKeyPath(searchKeyPath);\n    var i = 0;\n    while(i !== keyPath.length){\n        collection = get(collection, keyPath[i++], NOT_SET);\n        if (collection === NOT_SET) {\n            return notSetValue;\n        }\n    }\n    return collection;\n}\nfunction getIn(searchKeyPath, notSetValue) {\n    return getIn$1(this, searchKeyPath, notSetValue);\n}\nfunction hasIn$1(collection, keyPath) {\n    return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;\n}\nfunction hasIn(searchKeyPath) {\n    return hasIn$1(this, searchKeyPath);\n}\nfunction toObject() {\n    assertNotInfinite(this.size);\n    var object = {};\n    this.__iterate(function(v, k) {\n        object[k] = v;\n    });\n    return object;\n}\n// Note: all of these methods are deprecated.\nCollection.isIterable = isCollection;\nCollection.isKeyed = isKeyed;\nCollection.isIndexed = isIndexed;\nCollection.isAssociative = isAssociative;\nCollection.isOrdered = isOrdered;\nCollection.Iterator = Iterator;\nmixin(Collection, {\n    // ### Conversion to other types\n    toArray: function toArray() {\n        assertNotInfinite(this.size);\n        var array = new Array(this.size || 0);\n        var useTuples = isKeyed(this);\n        var i = 0;\n        this.__iterate(function(v, k) {\n            // Keyed collections produce an array of tuples.\n            array[i++] = useTuples ? [\n                k,\n                v\n            ] : v;\n        });\n        return array;\n    },\n    toIndexedSeq: function toIndexedSeq() {\n        return new ToIndexedSequence(this);\n    },\n    toJS: function toJS$1() {\n        return toJS(this);\n    },\n    toKeyedSeq: function toKeyedSeq() {\n        return new ToKeyedSequence(this, true);\n    },\n    toMap: function toMap() {\n        // Use Late Binding here to solve the circular dependency.\n        return Map(this.toKeyedSeq());\n    },\n    toObject: toObject,\n    toOrderedMap: function toOrderedMap() {\n        // Use Late Binding here to solve the circular dependency.\n        return OrderedMap(this.toKeyedSeq());\n    },\n    toOrderedSet: function toOrderedSet() {\n        // Use Late Binding here to solve the circular dependency.\n        return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n    toSet: function toSet() {\n        // Use Late Binding here to solve the circular dependency.\n        return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n    toSetSeq: function toSetSeq() {\n        return new ToSetSequence(this);\n    },\n    toSeq: function toSeq() {\n        return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();\n    },\n    toStack: function toStack() {\n        // Use Late Binding here to solve the circular dependency.\n        return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n    toList: function toList() {\n        // Use Late Binding here to solve the circular dependency.\n        return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n    // ### Common JavaScript methods and properties\n    toString: function toString() {\n        return \"[Collection]\";\n    },\n    __toString: function __toString(head, tail) {\n        if (this.size === 0) {\n            return head + tail;\n        }\n        return head + \" \" + this.toSeq().map(this.__toStringMapper).join(\", \") + \" \" + tail;\n    },\n    // ### ES6 Collection methods (ES6 Array and Map)\n    concat: function concat() {\n        var values = [], len = arguments.length;\n        while(len--)values[len] = arguments[len];\n        return reify(this, concatFactory(this, values));\n    },\n    includes: function includes(searchValue) {\n        return this.some(function(value) {\n            return is(value, searchValue);\n        });\n    },\n    entries: function entries() {\n        return this.__iterator(ITERATE_ENTRIES);\n    },\n    every: function every(predicate, context) {\n        assertNotInfinite(this.size);\n        var returnValue = true;\n        this.__iterate(function(v, k, c) {\n            if (!predicate.call(context, v, k, c)) {\n                returnValue = false;\n                return false;\n            }\n        });\n        return returnValue;\n    },\n    filter: function filter(predicate, context) {\n        return reify(this, filterFactory(this, predicate, context, true));\n    },\n    partition: function partition(predicate, context) {\n        return partitionFactory(this, predicate, context);\n    },\n    find: function find(predicate, context, notSetValue) {\n        var entry = this.findEntry(predicate, context);\n        return entry ? entry[1] : notSetValue;\n    },\n    forEach: function forEach(sideEffect, context) {\n        assertNotInfinite(this.size);\n        return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n    join: function join(separator) {\n        assertNotInfinite(this.size);\n        separator = separator !== undefined ? \"\" + separator : \",\";\n        var joined = \"\";\n        var isFirst = true;\n        this.__iterate(function(v) {\n            isFirst ? isFirst = false : joined += separator;\n            joined += v !== null && v !== undefined ? v.toString() : \"\";\n        });\n        return joined;\n    },\n    keys: function keys() {\n        return this.__iterator(ITERATE_KEYS);\n    },\n    map: function map(mapper, context) {\n        return reify(this, mapFactory(this, mapper, context));\n    },\n    reduce: function reduce$1(reducer, initialReduction, context) {\n        return reduce(this, reducer, initialReduction, context, arguments.length < 2, false);\n    },\n    reduceRight: function reduceRight(reducer, initialReduction, context) {\n        return reduce(this, reducer, initialReduction, context, arguments.length < 2, true);\n    },\n    reverse: function reverse() {\n        return reify(this, reverseFactory(this, true));\n    },\n    slice: function slice(begin, end) {\n        return reify(this, sliceFactory(this, begin, end, true));\n    },\n    some: function some(predicate, context) {\n        assertNotInfinite(this.size);\n        var returnValue = false;\n        this.__iterate(function(v, k, c) {\n            if (predicate.call(context, v, k, c)) {\n                returnValue = true;\n                return false;\n            }\n        });\n        return returnValue;\n    },\n    sort: function sort(comparator) {\n        return reify(this, sortFactory(this, comparator));\n    },\n    values: function values() {\n        return this.__iterator(ITERATE_VALUES);\n    },\n    // ### More sequential methods\n    butLast: function butLast() {\n        return this.slice(0, -1);\n    },\n    isEmpty: function isEmpty() {\n        return this.size !== undefined ? this.size === 0 : !this.some(function() {\n            return true;\n        });\n    },\n    count: function count(predicate, context) {\n        return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);\n    },\n    countBy: function countBy(grouper, context) {\n        return countByFactory(this, grouper, context);\n    },\n    equals: function equals(other) {\n        return deepEqual(this, other);\n    },\n    entrySeq: function entrySeq() {\n        var collection = this;\n        if (collection._cache) {\n            // We cache as an entries array, so we can just return the cache!\n            return new ArraySeq(collection._cache);\n        }\n        var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();\n        entriesSequence.fromEntrySeq = function() {\n            return collection.toSeq();\n        };\n        return entriesSequence;\n    },\n    filterNot: function filterNot(predicate, context) {\n        return this.filter(not(predicate), context);\n    },\n    findEntry: function findEntry(predicate, context, notSetValue) {\n        var found = notSetValue;\n        this.__iterate(function(v, k, c) {\n            if (predicate.call(context, v, k, c)) {\n                found = [\n                    k,\n                    v\n                ];\n                return false;\n            }\n        });\n        return found;\n    },\n    findKey: function findKey(predicate, context) {\n        var entry = this.findEntry(predicate, context);\n        return entry && entry[0];\n    },\n    findLast: function findLast(predicate, context, notSetValue) {\n        return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n    findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n        return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n    findLastKey: function findLastKey(predicate, context) {\n        return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n    first: function first(notSetValue) {\n        return this.find(returnTrue, null, notSetValue);\n    },\n    flatMap: function flatMap(mapper, context) {\n        return reify(this, flatMapFactory(this, mapper, context));\n    },\n    flatten: function flatten(depth) {\n        return reify(this, flattenFactory(this, depth, true));\n    },\n    fromEntrySeq: function fromEntrySeq() {\n        return new FromEntriesSequence(this);\n    },\n    get: function get(searchKey, notSetValue) {\n        return this.find(function(_, key) {\n            return is(key, searchKey);\n        }, undefined, notSetValue);\n    },\n    getIn: getIn,\n    groupBy: function groupBy(grouper, context) {\n        return groupByFactory(this, grouper, context);\n    },\n    has: function has(searchKey) {\n        return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n    hasIn: hasIn,\n    isSubset: function isSubset(iter) {\n        iter = typeof iter.includes === \"function\" ? iter : Collection(iter);\n        return this.every(function(value) {\n            return iter.includes(value);\n        });\n    },\n    isSuperset: function isSuperset(iter) {\n        iter = typeof iter.isSubset === \"function\" ? iter : Collection(iter);\n        return iter.isSubset(this);\n    },\n    keyOf: function keyOf(searchValue) {\n        return this.findKey(function(value) {\n            return is(value, searchValue);\n        });\n    },\n    keySeq: function keySeq() {\n        return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n    last: function last(notSetValue) {\n        return this.toSeq().reverse().first(notSetValue);\n    },\n    lastKeyOf: function lastKeyOf(searchValue) {\n        return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n    max: function max(comparator) {\n        return maxFactory(this, comparator);\n    },\n    maxBy: function maxBy(mapper, comparator) {\n        return maxFactory(this, comparator, mapper);\n    },\n    min: function min(comparator) {\n        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n    minBy: function minBy(mapper, comparator) {\n        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n    rest: function rest() {\n        return this.slice(1);\n    },\n    skip: function skip(amount) {\n        return amount === 0 ? this : this.slice(Math.max(0, amount));\n    },\n    skipLast: function skipLast(amount) {\n        return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n    },\n    skipWhile: function skipWhile(predicate, context) {\n        return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n    skipUntil: function skipUntil(predicate, context) {\n        return this.skipWhile(not(predicate), context);\n    },\n    sortBy: function sortBy(mapper, comparator) {\n        return reify(this, sortFactory(this, comparator, mapper));\n    },\n    take: function take(amount) {\n        return this.slice(0, Math.max(0, amount));\n    },\n    takeLast: function takeLast(amount) {\n        return this.slice(-Math.max(0, amount));\n    },\n    takeWhile: function takeWhile(predicate, context) {\n        return reify(this, takeWhileFactory(this, predicate, context));\n    },\n    takeUntil: function takeUntil(predicate, context) {\n        return this.takeWhile(not(predicate), context);\n    },\n    update: function update(fn) {\n        return fn(this);\n    },\n    valueSeq: function valueSeq() {\n        return this.toIndexedSeq();\n    },\n    // ### Hashable Object\n    hashCode: function hashCode() {\n        return this.__hash || (this.__hash = hashCollection(this));\n    }\n});\nvar CollectionPrototype = Collection.prototype;\nCollectionPrototype[IS_COLLECTION_SYMBOL] = true;\nCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\nCollectionPrototype.toJSON = CollectionPrototype.toArray;\nCollectionPrototype.__toStringMapper = quoteString;\nCollectionPrototype.inspect = CollectionPrototype.toSource = function() {\n    return this.toString();\n};\nCollectionPrototype.chain = CollectionPrototype.flatMap;\nCollectionPrototype.contains = CollectionPrototype.includes;\nmixin(KeyedCollection, {\n    // ### More sequential methods\n    flip: function flip() {\n        return reify(this, flipFactory(this));\n    },\n    mapEntries: function mapEntries(mapper, context) {\n        var this$1$1 = this;\n        var iterations = 0;\n        return reify(this, this.toSeq().map(function(v, k) {\n            return mapper.call(context, [\n                k,\n                v\n            ], iterations++, this$1$1);\n        }).fromEntrySeq());\n    },\n    mapKeys: function mapKeys(mapper, context) {\n        var this$1$1 = this;\n        return reify(this, this.toSeq().flip().map(function(k, v) {\n            return mapper.call(context, k, v, this$1$1);\n        }).flip());\n    }\n});\nvar KeyedCollectionPrototype = KeyedCollection.prototype;\nKeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;\nKeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\nKeyedCollectionPrototype.toJSON = toObject;\nKeyedCollectionPrototype.__toStringMapper = function(v, k) {\n    return quoteString(k) + \": \" + quoteString(v);\n};\nmixin(IndexedCollection, {\n    // ### Conversion to other types\n    toKeyedSeq: function toKeyedSeq() {\n        return new ToKeyedSequence(this, false);\n    },\n    // ### ES6 Collection methods (ES6 Array and Map)\n    filter: function filter(predicate, context) {\n        return reify(this, filterFactory(this, predicate, context, false));\n    },\n    findIndex: function findIndex(predicate, context) {\n        var entry = this.findEntry(predicate, context);\n        return entry ? entry[0] : -1;\n    },\n    indexOf: function indexOf(searchValue) {\n        var key = this.keyOf(searchValue);\n        return key === undefined ? -1 : key;\n    },\n    lastIndexOf: function lastIndexOf(searchValue) {\n        var key = this.lastKeyOf(searchValue);\n        return key === undefined ? -1 : key;\n    },\n    reverse: function reverse() {\n        return reify(this, reverseFactory(this, false));\n    },\n    slice: function slice(begin, end) {\n        return reify(this, sliceFactory(this, begin, end, false));\n    },\n    splice: function splice(index, removeNum /*, ...values*/ ) {\n        var numArgs = arguments.length;\n        removeNum = Math.max(removeNum || 0, 0);\n        if (numArgs === 0 || numArgs === 2 && !removeNum) {\n            return this;\n        }\n        // If index is negative, it should resolve relative to the size of the\n        // collection. However size may be expensive to compute if not cached, so\n        // only call count() if the number is in fact negative.\n        index = resolveBegin(index, index < 0 ? this.count() : this.size);\n        var spliced = this.slice(0, index);\n        return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));\n    },\n    // ### More collection methods\n    findLastIndex: function findLastIndex(predicate, context) {\n        var entry = this.findLastEntry(predicate, context);\n        return entry ? entry[0] : -1;\n    },\n    first: function first(notSetValue) {\n        return this.get(0, notSetValue);\n    },\n    flatten: function flatten(depth) {\n        return reify(this, flattenFactory(this, depth, false));\n    },\n    get: function get(index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function(_, key) {\n            return key === index;\n        }, undefined, notSetValue);\n    },\n    has: function has(index) {\n        index = wrapIndex(this, index);\n        return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);\n    },\n    interpose: function interpose(separator) {\n        return reify(this, interposeFactory(this, separator));\n    },\n    interleave: function interleave() {\n        var collections = [\n            this\n        ].concat(arrCopy(arguments));\n        var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n        var interleaved = zipped.flatten(true);\n        if (zipped.size) {\n            interleaved.size = zipped.size * collections.length;\n        }\n        return reify(this, interleaved);\n    },\n    keySeq: function keySeq() {\n        return Range(0, this.size);\n    },\n    last: function last(notSetValue) {\n        return this.get(-1, notSetValue);\n    },\n    skipWhile: function skipWhile(predicate, context) {\n        return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n    zip: function zip() {\n        var collections = [\n            this\n        ].concat(arrCopy(arguments));\n        return reify(this, zipWithFactory(this, defaultZipper, collections));\n    },\n    zipAll: function zipAll() {\n        var collections = [\n            this\n        ].concat(arrCopy(arguments));\n        return reify(this, zipWithFactory(this, defaultZipper, collections, true));\n    },\n    zipWith: function zipWith(zipper /*, ...collections */ ) {\n        var collections = arrCopy(arguments);\n        collections[0] = this;\n        return reify(this, zipWithFactory(this, zipper, collections));\n    }\n});\nvar IndexedCollectionPrototype = IndexedCollection.prototype;\nIndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;\nIndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;\nmixin(SetCollection, {\n    // ### ES6 Collection methods (ES6 Array and Map)\n    get: function get(value, notSetValue) {\n        return this.has(value) ? value : notSetValue;\n    },\n    includes: function includes(value) {\n        return this.has(value);\n    },\n    // ### More sequential methods\n    keySeq: function keySeq() {\n        return this.valueSeq();\n    }\n});\nvar SetCollectionPrototype = SetCollection.prototype;\nSetCollectionPrototype.has = CollectionPrototype.includes;\nSetCollectionPrototype.contains = SetCollectionPrototype.includes;\nSetCollectionPrototype.keys = SetCollectionPrototype.values;\n// Mixin subclasses\nmixin(KeyedSeq, KeyedCollectionPrototype);\nmixin(IndexedSeq, IndexedCollectionPrototype);\nmixin(SetSeq, SetCollectionPrototype);\n// #pragma Helper functions\nfunction reduce(collection, reducer, reduction, context, useFirst, reverse) {\n    assertNotInfinite(collection.size);\n    collection.__iterate(function(v, k, c) {\n        if (useFirst) {\n            useFirst = false;\n            reduction = v;\n        } else {\n            reduction = reducer.call(context, reduction, v, k, c);\n        }\n    }, reverse);\n    return reduction;\n}\nfunction keyMapper(v, k) {\n    return k;\n}\nfunction entryMapper(v, k) {\n    return [\n        k,\n        v\n    ];\n}\nfunction not(predicate) {\n    return function() {\n        return !predicate.apply(this, arguments);\n    };\n}\nfunction neg(predicate) {\n    return function() {\n        return -predicate.apply(this, arguments);\n    };\n}\nfunction defaultZipper() {\n    return arrCopy(arguments);\n}\nfunction defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n}\nfunction hashCollection(collection) {\n    if (collection.size === Infinity) {\n        return 0;\n    }\n    var ordered = isOrdered(collection);\n    var keyed = isKeyed(collection);\n    var h = ordered ? 1 : 0;\n    var size = collection.__iterate(keyed ? ordered ? function(v, k) {\n        h = 31 * h + hashMerge(hash(v), hash(k)) | 0;\n    } : function(v, k) {\n        h = h + hashMerge(hash(v), hash(k)) | 0;\n    } : ordered ? function(v) {\n        h = 31 * h + hash(v) | 0;\n    } : function(v) {\n        h = h + hash(v) | 0;\n    });\n    return murmurHashOfSize(size, h);\n}\nfunction murmurHashOfSize(size, h) {\n    h = imul(h, 0xcc9e2d51);\n    h = imul(h << 15 | h >>> -15, 0x1b873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xe6546b64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85ebca6b);\n    h = imul(h ^ h >>> 13, 0xc2b2ae35);\n    h = smi(h ^ h >>> 16);\n    return h;\n}\nfunction hashMerge(a, b) {\n    return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int\n}\nvar OrderedSet = /*@__PURE__*/ function(Set) {\n    function OrderedSet(value) {\n        // eslint-disable-next-line no-constructor-return\n        return value === undefined || value === null ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set) {\n            var iter = SetCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function(v) {\n                return set.add(v);\n            });\n        });\n    }\n    if (Set) OrderedSet.__proto__ = Set;\n    OrderedSet.prototype = Object.create(Set && Set.prototype);\n    OrderedSet.prototype.constructor = OrderedSet;\n    OrderedSet.of = function of() {\n        return this(arguments);\n    };\n    OrderedSet.fromKeys = function fromKeys(value) {\n        return this(KeyedCollection(value).keySeq());\n    };\n    OrderedSet.prototype.toString = function toString() {\n        return this.__toString(\"OrderedSet {\", \"}\");\n    };\n    return OrderedSet;\n}(Set);\nOrderedSet.isOrderedSet = isOrderedSet;\nvar OrderedSetPrototype = OrderedSet.prototype;\nOrderedSetPrototype[IS_ORDERED_SYMBOL] = true;\nOrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\nOrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\nOrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;\nOrderedSetPrototype.__empty = emptyOrderedSet;\nOrderedSetPrototype.__make = makeOrderedSet;\nfunction makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n}\nvar EMPTY_ORDERED_SET;\nfunction emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n}\nvar PairSorting = {\n    LeftThenRight: -1,\n    RightThenLeft: +1\n};\nfunction throwOnInvalidDefaultValues(defaultValues) {\n    if (isRecord(defaultValues)) {\n        throw new Error(\"Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead.\");\n    }\n    if (isImmutable(defaultValues)) {\n        throw new Error(\"Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead.\");\n    }\n    if (defaultValues === null || typeof defaultValues !== \"object\") {\n        throw new Error(\"Can not call `Record` with a non-object as default values. Use a plain javascript object instead.\");\n    }\n}\nvar Record = function Record(defaultValues, name) {\n    var hasInitialized;\n    throwOnInvalidDefaultValues(defaultValues);\n    var RecordType = function Record(values) {\n        var this$1$1 = this;\n        if (values instanceof RecordType) {\n            return values;\n        }\n        if (!(this instanceof RecordType)) {\n            return new RecordType(values);\n        }\n        if (!hasInitialized) {\n            hasInitialized = true;\n            var keys = Object.keys(defaultValues);\n            var indices = RecordTypePrototype._indices = {};\n            // Deprecated: left to attempt not to break any external code which\n            // relies on a ._name property existing on record instances.\n            // Use Record.getDescriptiveName() instead\n            RecordTypePrototype._name = name;\n            RecordTypePrototype._keys = keys;\n            RecordTypePrototype._defaultValues = defaultValues;\n            for(var i = 0; i < keys.length; i++){\n                var propName = keys[i];\n                indices[propName] = i;\n                if (RecordTypePrototype[propName]) {\n                    /* eslint-disable no-console */ typeof console === \"object\" && console.warn && console.warn(\"Cannot define \" + recordName(this) + ' with property \"' + propName + '\" since that property name is part of the Record API.');\n                /* eslint-enable no-console */ } else {\n                    setProp(RecordTypePrototype, propName);\n                }\n            }\n        }\n        this.__ownerID = undefined;\n        this._values = List().withMutations(function(l) {\n            l.setSize(this$1$1._keys.length);\n            KeyedCollection(values).forEach(function(v, k) {\n                l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? undefined : v);\n            });\n        });\n        return this;\n    };\n    var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n    RecordTypePrototype.constructor = RecordType;\n    if (name) {\n        RecordType.displayName = name;\n    }\n    // eslint-disable-next-line no-constructor-return\n    return RecordType;\n};\nRecord.prototype.toString = function toString() {\n    var str = recordName(this) + \" { \";\n    var keys = this._keys;\n    var k;\n    for(var i = 0, l = keys.length; i !== l; i++){\n        k = keys[i];\n        str += (i ? \", \" : \"\") + k + \": \" + quoteString(this.get(k));\n    }\n    return str + \" }\";\n};\nRecord.prototype.equals = function equals(other) {\n    return this === other || isRecord(other) && recordSeq(this).equals(recordSeq(other));\n};\nRecord.prototype.hashCode = function hashCode() {\n    return recordSeq(this).hashCode();\n};\n// @pragma Access\nRecord.prototype.has = function has(k) {\n    return this._indices.hasOwnProperty(k);\n};\nRecord.prototype.get = function get(k, notSetValue) {\n    if (!this.has(k)) {\n        return notSetValue;\n    }\n    var index = this._indices[k];\n    var value = this._values.get(index);\n    return value === undefined ? this._defaultValues[k] : value;\n};\n// @pragma Modification\nRecord.prototype.set = function set(k, v) {\n    if (this.has(k)) {\n        var newValues = this._values.set(this._indices[k], v === this._defaultValues[k] ? undefined : v);\n        if (newValues !== this._values && !this.__ownerID) {\n            return makeRecord(this, newValues);\n        }\n    }\n    return this;\n};\nRecord.prototype.remove = function remove(k) {\n    return this.set(k);\n};\nRecord.prototype.clear = function clear() {\n    var newValues = this._values.clear().setSize(this._keys.length);\n    return this.__ownerID ? this : makeRecord(this, newValues);\n};\nRecord.prototype.wasAltered = function wasAltered() {\n    return this._values.wasAltered();\n};\nRecord.prototype.toSeq = function toSeq() {\n    return recordSeq(this);\n};\nRecord.prototype.toJS = function toJS$1() {\n    return toJS(this);\n};\nRecord.prototype.entries = function entries() {\n    return this.__iterator(ITERATE_ENTRIES);\n};\nRecord.prototype.__iterator = function __iterator(type, reverse) {\n    return recordSeq(this).__iterator(type, reverse);\n};\nRecord.prototype.__iterate = function __iterate(fn, reverse) {\n    return recordSeq(this).__iterate(fn, reverse);\n};\nRecord.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n    if (ownerID === this.__ownerID) {\n        return this;\n    }\n    var newValues = this._values.__ensureOwner(ownerID);\n    if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._values = newValues;\n        return this;\n    }\n    return makeRecord(this, newValues, ownerID);\n};\nRecord.isRecord = isRecord;\nRecord.getDescriptiveName = recordName;\nvar RecordPrototype = Record.prototype;\nRecordPrototype[IS_RECORD_SYMBOL] = true;\nRecordPrototype[DELETE] = RecordPrototype.remove;\nRecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;\nRecordPrototype.getIn = getIn;\nRecordPrototype.hasIn = CollectionPrototype.hasIn;\nRecordPrototype.merge = merge$1;\nRecordPrototype.mergeWith = mergeWith$1;\nRecordPrototype.mergeIn = mergeIn;\nRecordPrototype.mergeDeep = mergeDeep;\nRecordPrototype.mergeDeepWith = mergeDeepWith;\nRecordPrototype.mergeDeepIn = mergeDeepIn;\nRecordPrototype.setIn = setIn;\nRecordPrototype.update = update;\nRecordPrototype.updateIn = updateIn;\nRecordPrototype.withMutations = withMutations;\nRecordPrototype.asMutable = asMutable;\nRecordPrototype.asImmutable = asImmutable;\nRecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;\nRecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;\nRecordPrototype.inspect = RecordPrototype.toSource = function() {\n    return this.toString();\n};\nfunction makeRecord(likeRecord, values, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._values = values;\n    record.__ownerID = ownerID;\n    return record;\n}\nfunction recordName(record) {\n    return record.constructor.displayName || record.constructor.name || \"Record\";\n}\nfunction recordSeq(record) {\n    return keyedSeqFromValue(record._keys.map(function(k) {\n        return [\n            k,\n            record.get(k)\n        ];\n    }));\n}\nfunction setProp(prototype, name) {\n    try {\n        Object.defineProperty(prototype, name, {\n            get: function() {\n                return this.get(name);\n            },\n            set: function(value) {\n                invariant(this.__ownerID, \"Cannot set on an immutable record.\");\n                this.set(name, value);\n            }\n        });\n    } catch (error) {\n    // Object.defineProperty failed. Probably IE8.\n    }\n}\n/**\n * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n * undefined, returns an infinite sequence of `value`.\n */ var Repeat = /*@__PURE__*/ function(IndexedSeq) {\n    function Repeat(value, times) {\n        if (!(this instanceof Repeat)) {\n            // eslint-disable-next-line no-constructor-return\n            return new Repeat(value, times);\n        }\n        this._value = value;\n        this.size = times === undefined ? Infinity : Math.max(0, times);\n        if (this.size === 0) {\n            if (EMPTY_REPEAT) {\n                // eslint-disable-next-line no-constructor-return\n                return EMPTY_REPEAT;\n            }\n            EMPTY_REPEAT = this;\n        }\n    }\n    if (IndexedSeq) Repeat.__proto__ = IndexedSeq;\n    Repeat.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n    Repeat.prototype.constructor = Repeat;\n    Repeat.prototype.toString = function toString() {\n        if (this.size === 0) {\n            return \"Repeat []\";\n        }\n        return \"Repeat [ \" + this._value + \" \" + this.size + \" times ]\";\n    };\n    Repeat.prototype.get = function get(index, notSetValue) {\n        return this.has(index) ? this._value : notSetValue;\n    };\n    Repeat.prototype.includes = function includes(searchValue) {\n        return is(this._value, searchValue);\n    };\n    Repeat.prototype.slice = function slice(begin, end) {\n        var size = this.size;\n        return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n    Repeat.prototype.reverse = function reverse() {\n        return this;\n    };\n    Repeat.prototype.indexOf = function indexOf(searchValue) {\n        if (is(this._value, searchValue)) {\n            return 0;\n        }\n        return -1;\n    };\n    Repeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {\n        if (is(this._value, searchValue)) {\n            return this.size;\n        }\n        return -1;\n    };\n    Repeat.prototype.__iterate = function __iterate(fn, reverse) {\n        var size = this.size;\n        var i = 0;\n        while(i !== size){\n            if (fn(this._value, reverse ? size - ++i : i++, this) === false) {\n                break;\n            }\n        }\n        return i;\n    };\n    Repeat.prototype.__iterator = function __iterator(type, reverse) {\n        var this$1$1 = this;\n        var size = this.size;\n        var i = 0;\n        return new Iterator(function() {\n            return i === size ? iteratorDone() : iteratorValue(type, reverse ? size - ++i : i++, this$1$1._value);\n        });\n    };\n    Repeat.prototype.equals = function equals(other) {\n        return other instanceof Repeat ? is(this._value, other._value) : deepEqual(this, other);\n    };\n    return Repeat;\n}(IndexedSeq);\nvar EMPTY_REPEAT;\nfunction fromJS(value, converter) {\n    return fromJSWith([], converter || defaultConverter, value, \"\", converter && converter.length > 2 ? [] : undefined, {\n        \"\": value\n    });\n}\nfunction fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n    if (typeof value !== \"string\" && !isImmutable(value) && (isArrayLike(value) || hasIterator(value) || isPlainObject(value))) {\n        if (~stack.indexOf(value)) {\n            throw new TypeError(\"Cannot convert circular structure to Immutable\");\n        }\n        stack.push(value);\n        keyPath && key !== \"\" && keyPath.push(key);\n        var converted = converter.call(parentValue, key, Seq(value).map(function(v, k) {\n            return fromJSWith(stack, converter, v, k, keyPath, value);\n        }), keyPath && keyPath.slice());\n        stack.pop();\n        keyPath && keyPath.pop();\n        return converted;\n    }\n    return value;\n}\nfunction defaultConverter(k, v) {\n    // Effectively the opposite of \"Collection.toSeq()\"\n    return isIndexed(v) ? v.toList() : isKeyed(v) ? v.toMap() : v.toSet();\n}\nvar version = \"4.3.7\";\nvar Immutable = {\n    version: version,\n    Collection: Collection,\n    // Note: Iterable is deprecated\n    Iterable: Collection,\n    Seq: Seq,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n    PairSorting: PairSorting,\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n    is: is,\n    fromJS: fromJS,\n    hash: hash,\n    isImmutable: isImmutable,\n    isCollection: isCollection,\n    isKeyed: isKeyed,\n    isIndexed: isIndexed,\n    isAssociative: isAssociative,\n    isOrdered: isOrdered,\n    isValueObject: isValueObject,\n    isPlainObject: isPlainObject,\n    isSeq: isSeq,\n    isList: isList,\n    isMap: isMap,\n    isOrderedMap: isOrderedMap,\n    isStack: isStack,\n    isSet: isSet,\n    isOrderedSet: isOrderedSet,\n    isRecord: isRecord,\n    get: get,\n    getIn: getIn$1,\n    has: has,\n    hasIn: hasIn$1,\n    merge: merge,\n    mergeDeep: mergeDeep$1,\n    mergeWith: mergeWith,\n    mergeDeepWith: mergeDeepWith$1,\n    remove: remove,\n    removeIn: removeIn,\n    set: set,\n    setIn: setIn$1,\n    update: update$1,\n    updateIn: updateIn$1\n};\n// Note: Iterable is deprecated\nvar Iterable = Collection;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Immutable);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1tdXRhYmxlL2Rpc3QvaW1tdXRhYmxlLmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0QsSUFBSUEsU0FBUztBQUViLCtDQUErQztBQUMvQyxJQUFJQyxRQUFRLEdBQUcsNkNBQTZDO0FBQzVELElBQUlDLE9BQU8sS0FBS0Q7QUFDaEIsSUFBSUUsT0FBT0QsT0FBTztBQUVsQiw4RUFBOEU7QUFDOUUsOERBQThEO0FBQzlELElBQUlFLFVBQVUsQ0FBQztBQUVmLG9EQUFvRDtBQUNwRCxTQUFTQztJQUNQLE9BQU87UUFBRUMsT0FBTztJQUFNO0FBQ3hCO0FBRUEsU0FBU0MsT0FBT0MsR0FBRztJQUNqQixJQUFJQSxLQUFLO1FBQ1BBLElBQUlGLEtBQUssR0FBRztJQUNkO0FBQ0Y7QUFFQSxnRkFBZ0Y7QUFDaEYsNkVBQTZFO0FBQzdFLHNEQUFzRDtBQUN0RCxTQUFTRyxXQUFXO0FBRXBCLFNBQVNDLFdBQVdDLElBQUk7SUFDdEIsSUFBSUEsS0FBS0MsSUFBSSxLQUFLQyxXQUFXO1FBQzNCRixLQUFLQyxJQUFJLEdBQUdELEtBQUtHLFNBQVMsQ0FBQ0M7SUFDN0I7SUFDQSxPQUFPSixLQUFLQyxJQUFJO0FBQ2xCO0FBRUEsU0FBU0ksVUFBVUwsSUFBSSxFQUFFTSxLQUFLO0lBQzVCLHlFQUF5RTtJQUN6RSxFQUFFO0lBQ0YsZ0VBQWdFO0lBQ2hFLHVFQUF1RTtJQUN2RSxpQkFBaUI7SUFDakIsRUFBRTtJQUNGLDJFQUEyRTtJQUMzRSxJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUM3QixJQUFJQyxjQUFjRCxVQUFVLEdBQUcsb0NBQW9DO1FBQ25FLElBQUksS0FBS0MsZ0JBQWdCRCxTQUFTQyxnQkFBZ0IsWUFBWTtZQUM1RCxPQUFPQztRQUNUO1FBQ0FGLFFBQVFDO0lBQ1Y7SUFDQSxPQUFP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QUNkRCxTQUFTQTtJQUVUNXNCLFlBQVlBO0lBQ1osK0JBQStCO0lBQy9COHNCLFVBQVU5c0I7SUFFVkMsS0FBS0E7SUFDTGtOLEtBQUtBO0lBQ0xNLFlBQVlBO0lBQ1pvTyxNQUFNQTtJQUNOMEUsT0FBT0E7SUFDUHhmLEtBQUtBO0lBQ0xpaUIsWUFBWUE7SUFDWm9ILGFBQWFBO0lBRWJLLFFBQVFBO0lBQ1JwSCxPQUFPQTtJQUNQNkksUUFBUUE7SUFFUnBrQixJQUFJQTtJQUNKd2tCLFFBQVFBO0lBQ1I1akIsTUFBTUE7SUFFTnBILGFBQWFBO0lBQ2JqQyxjQUFjQTtJQUNkSSxTQUFTQTtJQUNURyxXQUFXQTtJQUNYRSxlQUFlQTtJQUNmMkIsV0FBV0E7SUFDWGlHLGVBQWVBO0lBQ2Z5SyxlQUFlQTtJQUNmbFIsT0FBT0E7SUFDUDBhLFFBQVFBO0lBQ1JyVSxPQUFPQTtJQUNQRSxjQUFjQTtJQUNkNlksU0FBU0E7SUFDVGEsT0FBT0E7SUFDUEUsY0FBY0E7SUFDZGhnQixVQUFVQTtJQUVWNkUsS0FBS0E7SUFDTHFlLE9BQU9GO0lBQ1BqZSxLQUFLQTtJQUNMcWUsT0FBT0Q7SUFDUHRQLE9BQU9BO0lBQ1BtQixXQUFXZjtJQUNYRCxXQUFXQTtJQUNYaUIsZUFBZWQ7SUFDZnRDLFFBQVFBO0lBQ1JrQixVQUFVQTtJQUNWN0osS0FBS0E7SUFDTDRKLE9BQU9EO0lBQ1A1RyxRQUFRZ0g7SUFDUkMsVUFBVWxCO0FBQ1o7QUFFQSwrQkFBK0I7QUFDL0IsSUFBSTBaLFdBQVc5c0I7QUFFZixpRUFBZTZzQixTQUFTQSxFQUFDO0FBQzhmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVlbC1oYXJ2ZXN0ZXIvLi9ub2RlX21vZHVsZXMvaW1tdXRhYmxlL2Rpc3QvaW1tdXRhYmxlLmVzLmpzPzRhMmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNSVQgTGljZW5zZVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgTGVlIEJ5cm9uIGFuZCBvdGhlciBjb250cmlidXRvcnMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xudmFyIERFTEVURSA9ICdkZWxldGUnO1xuXG4vLyBDb25zdGFudHMgZGVzY3JpYmluZyB0aGUgc2l6ZSBvZiB0cmllIG5vZGVzLlxudmFyIFNISUZUID0gNTsgLy8gUmVzdWx0ZWQgaW4gYmVzdCBwZXJmb3JtYW5jZSBhZnRlciBfX19fX18/XG52YXIgU0laRSA9IDEgPDwgU0hJRlQ7XG52YXIgTUFTSyA9IFNJWkUgLSAxO1xuXG4vLyBBIGNvbnNpc3RlbnQgc2hhcmVkIHZhbHVlIHJlcHJlc2VudGluZyBcIm5vdCBzZXRcIiB3aGljaCBlcXVhbHMgbm90aGluZyBvdGhlclxuLy8gdGhhbiBpdHNlbGYsIGFuZCBub3RoaW5nIHRoYXQgY291bGQgYmUgcHJvdmlkZWQgZXh0ZXJuYWxseS5cbnZhciBOT1RfU0VUID0ge307XG5cbi8vIEJvb2xlYW4gcmVmZXJlbmNlcywgUm91Z2ggZXF1aXZhbGVudCBvZiBgYm9vbCAmYC5cbmZ1bmN0aW9uIE1ha2VSZWYoKSB7XG4gIHJldHVybiB7IHZhbHVlOiBmYWxzZSB9O1xufVxuXG5mdW5jdGlvbiBTZXRSZWYocmVmKSB7XG4gIGlmIChyZWYpIHtcbiAgICByZWYudmFsdWUgPSB0cnVlO1xuICB9XG59XG5cbi8vIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIHZhbHVlIHJlcHJlc2VudGluZyBhbiBcIm93bmVyXCIgZm9yIHRyYW5zaWVudCB3cml0ZXNcbi8vIHRvIHRyaWVzLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgb25seSBldmVyIGVxdWFsIGl0c2VsZiwgYW5kIHdpbGwgbm90IGVxdWFsXG4vLyB0aGUgcmV0dXJuIG9mIGFueSBzdWJzZXF1ZW50IGNhbGwgb2YgdGhpcyBmdW5jdGlvbi5cbmZ1bmN0aW9uIE93bmVySUQoKSB7fVxuXG5mdW5jdGlvbiBlbnN1cmVTaXplKGl0ZXIpIHtcbiAgaWYgKGl0ZXIuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaXRlci5zaXplID0gaXRlci5fX2l0ZXJhdGUocmV0dXJuVHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIGl0ZXIuc2l6ZTtcbn1cblxuZnVuY3Rpb24gd3JhcEluZGV4KGl0ZXIsIGluZGV4KSB7XG4gIC8vIFRoaXMgaW1wbGVtZW50cyBcImlzIGFycmF5IGluZGV4XCIgd2hpY2ggdGhlIEVDTUFTdHJpbmcgc3BlYyBkZWZpbmVzIGFzOlxuICAvL1xuICAvLyAgICAgQSBTdHJpbmcgcHJvcGVydHkgbmFtZSBQIGlzIGFuIGFycmF5IGluZGV4IGlmIGFuZCBvbmx5IGlmXG4gIC8vICAgICBUb1N0cmluZyhUb1VpbnQzMihQKSkgaXMgZXF1YWwgdG8gUCBhbmQgVG9VaW50MzIoUCkgaXMgbm90IGVxdWFsXG4gIC8vICAgICB0byAyXjMy4oiSMS5cbiAgLy9cbiAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWFycmF5LWV4b3RpYy1vYmplY3RzXG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgdmFyIHVpbnQzMkluZGV4ID0gaW5kZXggPj4+IDA7IC8vIE4gPj4+IDAgaXMgc2hvcnRoYW5kIGZvciBUb1VpbnQzMlxuICAgIGlmICgnJyArIHVpbnQzMkluZGV4ICE9PSBpbmRleCB8fCB1aW50MzJJbmRleCA9PT0gNDI5NDk2NzI5NSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgaW5kZXggPSB1aW50MzJJbmRleDtcbiAgfVxuICByZXR1cm4gaW5kZXggPCAwID8gZW5zdXJlU2l6ZShpdGVyKSArIGluZGV4IDogaW5kZXg7XG59XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHNpemUpIHtcbiAgcmV0dXJuIChcbiAgICAoKGJlZ2luID09PSAwICYmICFpc05lZyhiZWdpbikpIHx8XG4gICAgICAoc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGJlZ2luIDw9IC1zaXplKSkgJiZcbiAgICAoZW5kID09PSB1bmRlZmluZWQgfHwgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBlbmQgPj0gc2l6ZSkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVCZWdpbihiZWdpbiwgc2l6ZSkge1xuICByZXR1cm4gcmVzb2x2ZUluZGV4KGJlZ2luLCBzaXplLCAwKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUVuZChlbmQsIHNpemUpIHtcbiAgcmV0dXJuIHJlc29sdmVJbmRleChlbmQsIHNpemUsIHNpemUpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5kZXgoaW5kZXgsIHNpemUsIGRlZmF1bHRJbmRleCkge1xuICAvLyBTYW5pdGl6ZSBpbmRpY2VzIHVzaW5nIHRoaXMgc2hvcnRoYW5kIGZvciBUb0ludDMyKGFyZ3VtZW50KVxuICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9pbnQzMlxuICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZFxuICAgID8gZGVmYXVsdEluZGV4XG4gICAgOiBpc05lZyhpbmRleClcbiAgICA/IHNpemUgPT09IEluZmluaXR5XG4gICAgICA/IHNpemVcbiAgICAgIDogTWF0aC5tYXgoMCwgc2l6ZSArIGluZGV4KSB8IDBcbiAgICA6IHNpemUgPT09IHVuZGVmaW5lZCB8fCBzaXplID09PSBpbmRleFxuICAgID8gaW5kZXhcbiAgICA6IE1hdGgubWluKHNpemUsIGluZGV4KSB8IDA7XG59XG5cbmZ1bmN0aW9uIGlzTmVnKHZhbHVlKSB7XG4gIC8vIEFjY291bnQgZm9yIC0wIHdoaWNoIGlzIG5lZ2F0aXZlLCBidXQgbm90IGxlc3MgdGhhbiAwLlxuICByZXR1cm4gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPT09IC1JbmZpbml0eSk7XG59XG5cbnZhciBJU19DT0xMRUNUSU9OX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX0lURVJBQkxFX19AQCc7XG5cbmZ1bmN0aW9uIGlzQ29sbGVjdGlvbihtYXliZUNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVDb2xsZWN0aW9uICYmIG1heWJlQ29sbGVjdGlvbltJU19DT0xMRUNUSU9OX1NZTUJPTF0pO1xufVxuXG52YXIgSVNfS0VZRURfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfS0VZRURfX0BAJztcblxuZnVuY3Rpb24gaXNLZXllZChtYXliZUtleWVkKSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlS2V5ZWQgJiYgbWF5YmVLZXllZFtJU19LRVlFRF9TWU1CT0xdKTtcbn1cblxudmFyIElTX0lOREVYRURfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfSU5ERVhFRF9fQEAnO1xuXG5mdW5jdGlvbiBpc0luZGV4ZWQobWF5YmVJbmRleGVkKSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlSW5kZXhlZCAmJiBtYXliZUluZGV4ZWRbSVNfSU5ERVhFRF9TWU1CT0xdKTtcbn1cblxuZnVuY3Rpb24gaXNBc3NvY2lhdGl2ZShtYXliZUFzc29jaWF0aXZlKSB7XG4gIHJldHVybiBpc0tleWVkKG1heWJlQXNzb2NpYXRpdmUpIHx8IGlzSW5kZXhlZChtYXliZUFzc29jaWF0aXZlKTtcbn1cblxudmFyIENvbGxlY3Rpb24gPSBmdW5jdGlvbiBDb2xsZWN0aW9uKHZhbHVlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cbiAgcmV0dXJuIGlzQ29sbGVjdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IFNlcSh2YWx1ZSk7XG59O1xuXG52YXIgS2V5ZWRDb2xsZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29sbGVjdGlvbikge1xuICBmdW5jdGlvbiBLZXllZENvbGxlY3Rpb24odmFsdWUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gICAgcmV0dXJuIGlzS2V5ZWQodmFsdWUpID8gdmFsdWUgOiBLZXllZFNlcSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIENvbGxlY3Rpb24gKSBLZXllZENvbGxlY3Rpb24uX19wcm90b19fID0gQ29sbGVjdGlvbjtcbiAgS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleWVkQ29sbGVjdGlvbjtcblxuICByZXR1cm4gS2V5ZWRDb2xsZWN0aW9uO1xufShDb2xsZWN0aW9uKSk7XG5cbnZhciBJbmRleGVkQ29sbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENvbGxlY3Rpb24pIHtcbiAgZnVuY3Rpb24gSW5kZXhlZENvbGxlY3Rpb24odmFsdWUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gICAgcmV0dXJuIGlzSW5kZXhlZCh2YWx1ZSkgPyB2YWx1ZSA6IEluZGV4ZWRTZXEodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBDb2xsZWN0aW9uICkgSW5kZXhlZENvbGxlY3Rpb24uX19wcm90b19fID0gQ29sbGVjdGlvbjtcbiAgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbmRleGVkQ29sbGVjdGlvbjtcblxuICByZXR1cm4gSW5kZXhlZENvbGxlY3Rpb247XG59KENvbGxlY3Rpb24pKTtcblxudmFyIFNldENvbGxlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDb2xsZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFNldENvbGxlY3Rpb24odmFsdWUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gICAgcmV0dXJuIGlzQ29sbGVjdGlvbih2YWx1ZSkgJiYgIWlzQXNzb2NpYXRpdmUodmFsdWUpID8gdmFsdWUgOiBTZXRTZXEodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBDb2xsZWN0aW9uICkgU2V0Q29sbGVjdGlvbi5fX3Byb3RvX18gPSBDb2xsZWN0aW9uO1xuICBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXRDb2xsZWN0aW9uO1xuXG4gIHJldHVybiBTZXRDb2xsZWN0aW9uO1xufShDb2xsZWN0aW9uKSk7XG5cbkNvbGxlY3Rpb24uS2V5ZWQgPSBLZXllZENvbGxlY3Rpb247XG5Db2xsZWN0aW9uLkluZGV4ZWQgPSBJbmRleGVkQ29sbGVjdGlvbjtcbkNvbGxlY3Rpb24uU2V0ID0gU2V0Q29sbGVjdGlvbjtcblxudmFyIElTX1NFUV9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9TRVFfX0BAJztcblxuZnVuY3Rpb24gaXNTZXEobWF5YmVTZXEpIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVTZXEgJiYgbWF5YmVTZXFbSVNfU0VRX1NZTUJPTF0pO1xufVxuXG52YXIgSVNfUkVDT1JEX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1JFQ09SRF9fQEAnO1xuXG5mdW5jdGlvbiBpc1JlY29yZChtYXliZVJlY29yZCkge1xuICByZXR1cm4gQm9vbGVhbihtYXliZVJlY29yZCAmJiBtYXliZVJlY29yZFtJU19SRUNPUkRfU1lNQk9MXSk7XG59XG5cbmZ1bmN0aW9uIGlzSW1tdXRhYmxlKG1heWJlSW1tdXRhYmxlKSB7XG4gIHJldHVybiBpc0NvbGxlY3Rpb24obWF5YmVJbW11dGFibGUpIHx8IGlzUmVjb3JkKG1heWJlSW1tdXRhYmxlKTtcbn1cblxudmFyIElTX09SREVSRURfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfT1JERVJFRF9fQEAnO1xuXG5mdW5jdGlvbiBpc09yZGVyZWQobWF5YmVPcmRlcmVkKSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlT3JkZXJlZCAmJiBtYXliZU9yZGVyZWRbSVNfT1JERVJFRF9TWU1CT0xdKTtcbn1cblxudmFyIElURVJBVEVfS0VZUyA9IDA7XG52YXIgSVRFUkFURV9WQUxVRVMgPSAxO1xudmFyIElURVJBVEVfRU5UUklFUyA9IDI7XG5cbnZhciBSRUFMX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gUkVBTF9JVEVSQVRPUl9TWU1CT0wgfHwgRkFVWF9JVEVSQVRPUl9TWU1CT0w7XG5cbnZhciBJdGVyYXRvciA9IGZ1bmN0aW9uIEl0ZXJhdG9yKG5leHQpIHtcbiAgdGhpcy5uZXh0ID0gbmV4dDtcbn07XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuICdbSXRlcmF0b3JdJztcbn07XG5cbkl0ZXJhdG9yLktFWVMgPSBJVEVSQVRFX0tFWVM7XG5JdGVyYXRvci5WQUxVRVMgPSBJVEVSQVRFX1ZBTFVFUztcbkl0ZXJhdG9yLkVOVFJJRVMgPSBJVEVSQVRFX0VOVFJJRVM7XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5pbnNwZWN0ID0gSXRlcmF0b3IucHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xufTtcbkl0ZXJhdG9yLnByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgaXRlcmF0b3JSZXN1bHQpIHtcbiAgdmFyIHZhbHVlID0gdHlwZSA9PT0gMCA/IGsgOiB0eXBlID09PSAxID8gdiA6IFtrLCB2XTtcbiAgaXRlcmF0b3JSZXN1bHRcbiAgICA/IChpdGVyYXRvclJlc3VsdC52YWx1ZSA9IHZhbHVlKVxuICAgIDogKGl0ZXJhdG9yUmVzdWx0ID0ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgfSk7XG4gIHJldHVybiBpdGVyYXRvclJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXRlcmF0b3JEb25lKCkge1xuICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG59XG5cbmZ1bmN0aW9uIGhhc0l0ZXJhdG9yKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWF5YmVJdGVyYWJsZSkpIHtcbiAgICAvLyBJRTExIHRyaWNrIGFzIGl0IGRvZXMgbm90IHN1cHBvcnQgYFN5bWJvbC5pdGVyYXRvcmBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAhIWdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSk7XG59XG5cbmZ1bmN0aW9uIGlzSXRlcmF0b3IobWF5YmVJdGVyYXRvcikge1xuICByZXR1cm4gbWF5YmVJdGVyYXRvciAmJiB0eXBlb2YgbWF5YmVJdGVyYXRvci5uZXh0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvcihpdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oaXRlcmFibGUpO1xuICByZXR1cm4gaXRlcmF0b3JGbiAmJiBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGUpO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKGl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID1cbiAgICBpdGVyYWJsZSAmJlxuICAgICgoUkVBTF9JVEVSQVRPUl9TWU1CT0wgJiYgaXRlcmFibGVbUkVBTF9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgaXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFbnRyaWVzSXRlcmFibGUobWF5YmVJdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSk7XG4gIHJldHVybiBpdGVyYXRvckZuICYmIGl0ZXJhdG9yRm4gPT09IG1heWJlSXRlcmFibGUuZW50cmllcztcbn1cblxuZnVuY3Rpb24gaXNLZXlzSXRlcmFibGUobWF5YmVJdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSk7XG4gIHJldHVybiBpdGVyYXRvckZuICYmIGl0ZXJhdG9yRm4gPT09IG1heWJlSXRlcmFibGUua2V5cztcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgdmFsdWUgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZS5sZW5ndGgpICYmXG4gICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAodmFsdWUubGVuZ3RoID09PSAwXG4gICAgICA/IC8vIE9ubHkge2xlbmd0aDogMH0gaXMgY29uc2lkZXJlZCBBcnJheS1saWtlLlxuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAxXG4gICAgICA6IC8vIEFuIG9iamVjdCBpcyBvbmx5IEFycmF5LWxpa2UgaWYgaXQgaGFzIGEgcHJvcGVydHkgd2hlcmUgdGhlIGxhc3QgdmFsdWVcbiAgICAgICAgLy8gaW4gdGhlIGFycmF5LWxpa2UgbWF5IGJlIGZvdW5kICh3aGljaCBjb3VsZCBiZSB1bmRlZmluZWQpLlxuICAgICAgICB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZS5sZW5ndGggLSAxKSlcbiAgKTtcbn1cblxudmFyIFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENvbGxlY3Rpb24pIHtcbiAgZnVuY3Rpb24gU2VxKHZhbHVlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsXG4gICAgICA/IGVtcHR5U2VxdWVuY2UoKVxuICAgICAgOiBpc0ltbXV0YWJsZSh2YWx1ZSlcbiAgICAgID8gdmFsdWUudG9TZXEoKVxuICAgICAgOiBzZXFGcm9tVmFsdWUodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBDb2xsZWN0aW9uICkgU2VxLl9fcHJvdG9fXyA9IENvbGxlY3Rpb247XG4gIFNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gIFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXE7XG5cbiAgU2VxLnByb3RvdHlwZS50b1NlcSA9IGZ1bmN0aW9uIHRvU2VxICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBTZXEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NlcSB7JywgJ30nKTtcbiAgfTtcblxuICBTZXEucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gZnVuY3Rpb24gY2FjaGVSZXN1bHQgKCkge1xuICAgIGlmICghdGhpcy5fY2FjaGUgJiYgdGhpcy5fX2l0ZXJhdGVVbmNhY2hlZCkge1xuICAgICAgdGhpcy5fY2FjaGUgPSB0aGlzLmVudHJ5U2VxKCkudG9BcnJheSgpO1xuICAgICAgdGhpcy5zaXplID0gdGhpcy5fY2FjaGUubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBhYnN0cmFjdCBfX2l0ZXJhdGVVbmNhY2hlZChmbiwgcmV2ZXJzZSlcblxuICBTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHZhciBzaXplID0gY2FjaGUubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGVbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgICBpZiAoZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9faXRlcmF0ZVVuY2FjaGVkKGZuLCByZXZlcnNlKTtcbiAgfTtcblxuICAvLyBhYnN0cmFjdCBfX2l0ZXJhdG9yVW5jYWNoZWQodHlwZSwgcmV2ZXJzZSlcblxuICBTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICB2YXIgc2l6ZSA9IGNhY2hlLmxlbmd0aDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtyZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrK107XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvclVuY2FjaGVkKHR5cGUsIHJldmVyc2UpO1xuICB9O1xuXG4gIHJldHVybiBTZXE7XG59KENvbGxlY3Rpb24pKTtcblxudmFyIEtleWVkU2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2VxKSB7XG4gIGZ1bmN0aW9uIEtleWVkU2VxKHZhbHVlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsXG4gICAgICA/IGVtcHR5U2VxdWVuY2UoKS50b0tleWVkU2VxKClcbiAgICAgIDogaXNDb2xsZWN0aW9uKHZhbHVlKVxuICAgICAgPyBpc0tleWVkKHZhbHVlKVxuICAgICAgICA/IHZhbHVlLnRvU2VxKClcbiAgICAgICAgOiB2YWx1ZS5mcm9tRW50cnlTZXEoKVxuICAgICAgOiBpc1JlY29yZCh2YWx1ZSlcbiAgICAgID8gdmFsdWUudG9TZXEoKVxuICAgICAgOiBrZXllZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIFNlcSApIEtleWVkU2VxLl9fcHJvdG9fXyA9IFNlcTtcbiAgS2V5ZWRTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VxICYmIFNlcS5wcm90b3R5cGUgKTtcbiAgS2V5ZWRTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5ZWRTZXE7XG5cbiAgS2V5ZWRTZXEucHJvdG90eXBlLnRvS2V5ZWRTZXEgPSBmdW5jdGlvbiB0b0tleWVkU2VxICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gS2V5ZWRTZXE7XG59KFNlcSkpO1xuXG52YXIgSW5kZXhlZFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNlcSkge1xuICBmdW5jdGlvbiBJbmRleGVkU2VxKHZhbHVlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsXG4gICAgICA/IGVtcHR5U2VxdWVuY2UoKVxuICAgICAgOiBpc0NvbGxlY3Rpb24odmFsdWUpXG4gICAgICA/IGlzS2V5ZWQodmFsdWUpXG4gICAgICAgID8gdmFsdWUuZW50cnlTZXEoKVxuICAgICAgICA6IHZhbHVlLnRvSW5kZXhlZFNlcSgpXG4gICAgICA6IGlzUmVjb3JkKHZhbHVlKVxuICAgICAgPyB2YWx1ZS50b1NlcSgpLmVudHJ5U2VxKClcbiAgICAgIDogaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIFNlcSApIEluZGV4ZWRTZXEuX19wcm90b19fID0gU2VxO1xuICBJbmRleGVkU2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNlcSAmJiBTZXEucHJvdG90eXBlICk7XG4gIEluZGV4ZWRTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5kZXhlZFNlcTtcblxuICBJbmRleGVkU2VxLm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gSW5kZXhlZFNlcShhcmd1bWVudHMpO1xuICB9O1xuXG4gIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvSW5kZXhlZFNlcSA9IGZ1bmN0aW9uIHRvSW5kZXhlZFNlcSAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgSW5kZXhlZFNlcS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2VxIFsnLCAnXScpO1xuICB9O1xuXG4gIHJldHVybiBJbmRleGVkU2VxO1xufShTZXEpKTtcblxudmFyIFNldFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNlcSkge1xuICBmdW5jdGlvbiBTZXRTZXEodmFsdWUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gICAgcmV0dXJuIChcbiAgICAgIGlzQ29sbGVjdGlvbih2YWx1ZSkgJiYgIWlzQXNzb2NpYXRpdmUodmFsdWUpID8gdmFsdWUgOiBJbmRleGVkU2VxKHZhbHVlKVxuICAgICkudG9TZXRTZXEoKTtcbiAgfVxuXG4gIGlmICggU2VxICkgU2V0U2VxLl9fcHJvdG9fXyA9IFNlcTtcbiAgU2V0U2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNlcSAmJiBTZXEucHJvdG90eXBlICk7XG4gIFNldFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXRTZXE7XG5cbiAgU2V0U2VxLm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gU2V0U2VxKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgU2V0U2VxLnByb3RvdHlwZS50b1NldFNlcSA9IGZ1bmN0aW9uIHRvU2V0U2VxICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gU2V0U2VxO1xufShTZXEpKTtcblxuU2VxLmlzU2VxID0gaXNTZXE7XG5TZXEuS2V5ZWQgPSBLZXllZFNlcTtcblNlcS5TZXQgPSBTZXRTZXE7XG5TZXEuSW5kZXhlZCA9IEluZGV4ZWRTZXE7XG5cblNlcS5wcm90b3R5cGVbSVNfU0VRX1NZTUJPTF0gPSB0cnVlO1xuXG4vLyAjcHJhZ21hIFJvb3QgU2VxdWVuY2VzXG5cbnZhciBBcnJheVNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRTZXEpIHtcbiAgZnVuY3Rpb24gQXJyYXlTZXEoYXJyYXkpIHtcbiAgICB0aGlzLl9hcnJheSA9IGFycmF5O1xuICAgIHRoaXMuc2l6ZSA9IGFycmF5Lmxlbmd0aDtcbiAgfVxuXG4gIGlmICggSW5kZXhlZFNlcSApIEFycmF5U2VxLl9fcHJvdG9fXyA9IEluZGV4ZWRTZXE7XG4gIEFycmF5U2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRTZXEgJiYgSW5kZXhlZFNlcS5wcm90b3R5cGUgKTtcbiAgQXJyYXlTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXJyYXlTZXE7XG5cbiAgQXJyYXlTZXEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGluZGV4KSA/IHRoaXMuX2FycmF5W3dyYXBJbmRleCh0aGlzLCBpbmRleCldIDogbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgQXJyYXlTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcbiAgICB2YXIgc2l6ZSA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgIHZhciBpaSA9IHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrO1xuICAgICAgaWYgKGZuKGFycmF5W2lpXSwgaWksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH07XG5cbiAgQXJyYXlTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5fYXJyYXk7XG4gICAgdmFyIHNpemUgPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGkgPT09IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGlpID0gcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKys7XG4gICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpaSwgYXJyYXlbaWldKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQXJyYXlTZXE7XG59KEluZGV4ZWRTZXEpKTtcblxudmFyIE9iamVjdFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEtleWVkU2VxKSB7XG4gIGZ1bmN0aW9uIE9iamVjdFNlcShvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCkuY29uY2F0KFxuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KSA6IFtdXG4gICAgKTtcbiAgICB0aGlzLl9vYmplY3QgPSBvYmplY3Q7XG4gICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgdGhpcy5zaXplID0ga2V5cy5sZW5ndGg7XG4gIH1cblxuICBpZiAoIEtleWVkU2VxICkgT2JqZWN0U2VxLl9fcHJvdG9fXyA9IEtleWVkU2VxO1xuICBPYmplY3RTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggS2V5ZWRTZXEgJiYgS2V5ZWRTZXEucHJvdG90eXBlICk7XG4gIE9iamVjdFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPYmplY3RTZXE7XG5cbiAgT2JqZWN0U2VxLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICBpZiAobm90U2V0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0W2tleV07XG4gIH07XG5cbiAgT2JqZWN0U2VxLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX29iamVjdCwga2V5KTtcbiAgfTtcblxuICBPYmplY3RTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgb2JqZWN0ID0gdGhpcy5fb2JqZWN0O1xuICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcbiAgICB2YXIgc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgaWYgKGZuKG9iamVjdFtrZXldLCBrZXksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH07XG5cbiAgT2JqZWN0U2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBvYmplY3QgPSB0aGlzLl9vYmplY3Q7XG4gICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICAgIHZhciBzaXplID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGkgPT09IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IGtleXNbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwga2V5LCBvYmplY3Rba2V5XSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE9iamVjdFNlcTtcbn0oS2V5ZWRTZXEpKTtcbk9iamVjdFNlcS5wcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcblxudmFyIENvbGxlY3Rpb25TZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gIGZ1bmN0aW9uIENvbGxlY3Rpb25TZXEoY29sbGVjdGlvbikge1xuICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgIHRoaXMuc2l6ZSA9IGNvbGxlY3Rpb24ubGVuZ3RoIHx8IGNvbGxlY3Rpb24uc2l6ZTtcbiAgfVxuXG4gIGlmICggSW5kZXhlZFNlcSApIENvbGxlY3Rpb25TZXEuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgQ29sbGVjdGlvblNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gIENvbGxlY3Rpb25TZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29sbGVjdGlvblNlcTtcblxuICBDb2xsZWN0aW9uU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIF9faXRlcmF0ZVVuY2FjaGVkIChmbiwgcmV2ZXJzZSkge1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5fY29sbGVjdGlvbjtcbiAgICB2YXIgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihjb2xsZWN0aW9uKTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgaWYgKGlzSXRlcmF0b3IoaXRlcmF0b3IpKSB7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgaWYgKGZuKHN0ZXAudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgQ29sbGVjdGlvblNlcS5wcm90b3R5cGUuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gX19pdGVyYXRvclVuY2FjaGVkICh0eXBlLCByZXZlcnNlKSB7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGNvbGxlY3Rpb24pO1xuICAgIGlmICghaXNJdGVyYXRvcihpdGVyYXRvcikpIHtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoaXRlcmF0b3JEb25lKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3RlcC5kb25lID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ29sbGVjdGlvblNlcTtcbn0oSW5kZXhlZFNlcSkpO1xuXG4vLyAjIHByYWdtYSBIZWxwZXIgZnVuY3Rpb25zXG5cbnZhciBFTVBUWV9TRVE7XG5cbmZ1bmN0aW9uIGVtcHR5U2VxdWVuY2UoKSB7XG4gIHJldHVybiBFTVBUWV9TRVEgfHwgKEVNUFRZX1NFUSA9IG5ldyBBcnJheVNlcShbXSkpO1xufVxuXG5mdW5jdGlvbiBrZXllZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICB2YXIgc2VxID0gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgaWYgKHNlcSkge1xuICAgIHJldHVybiBzZXEuZnJvbUVudHJ5U2VxKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdFNlcSh2YWx1ZSk7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgY29sbGVjdGlvbiBvYmplY3Qgb2YgW2ssIHZdIGVudHJpZXMsIG9yIGtleWVkIG9iamVjdDogJyArXG4gICAgICB2YWx1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBpbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gIHZhciBzZXEgPSBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpO1xuICBpZiAoc2VxKSB7XG4gICAgcmV0dXJuIHNlcTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdFeHBlY3RlZCBBcnJheSBvciBjb2xsZWN0aW9uIG9iamVjdCBvZiB2YWx1ZXM6ICcgKyB2YWx1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBzZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgdmFyIHNlcSA9IG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gIGlmIChzZXEpIHtcbiAgICByZXR1cm4gaXNFbnRyaWVzSXRlcmFibGUodmFsdWUpXG4gICAgICA/IHNlcS5mcm9tRW50cnlTZXEoKVxuICAgICAgOiBpc0tleXNJdGVyYWJsZSh2YWx1ZSlcbiAgICAgID8gc2VxLnRvU2V0U2VxKClcbiAgICAgIDogc2VxO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RTZXEodmFsdWUpO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ0V4cGVjdGVkIEFycmF5IG9yIGNvbGxlY3Rpb24gb2JqZWN0IG9mIHZhbHVlcywgb3Iga2V5ZWQgb2JqZWN0OiAnICsgdmFsdWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5TGlrZSh2YWx1ZSlcbiAgICA/IG5ldyBBcnJheVNlcSh2YWx1ZSlcbiAgICA6IGhhc0l0ZXJhdG9yKHZhbHVlKVxuICAgID8gbmV3IENvbGxlY3Rpb25TZXEodmFsdWUpXG4gICAgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBJU19NQVBfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfTUFQX19AQCc7XG5cbmZ1bmN0aW9uIGlzTWFwKG1heWJlTWFwKSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlTWFwICYmIG1heWJlTWFwW0lTX01BUF9TWU1CT0xdKTtcbn1cblxuZnVuY3Rpb24gaXNPcmRlcmVkTWFwKG1heWJlT3JkZXJlZE1hcCkge1xuICByZXR1cm4gaXNNYXAobWF5YmVPcmRlcmVkTWFwKSAmJiBpc09yZGVyZWQobWF5YmVPcmRlcmVkTWFwKTtcbn1cblxuZnVuY3Rpb24gaXNWYWx1ZU9iamVjdChtYXliZVZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIG1heWJlVmFsdWUgJiZcbiAgICAgIHR5cGVvZiBtYXliZVZhbHVlLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIG1heWJlVmFsdWUuaGFzaENvZGUgPT09ICdmdW5jdGlvbidcbiAgKTtcbn1cblxuLyoqXG4gKiBBbiBleHRlbnNpb24gb2YgdGhlIFwic2FtZS12YWx1ZVwiIGFsZ29yaXRobSBhcyBbZGVzY3JpYmVkIGZvciB1c2UgYnkgRVM2IE1hcFxuICogYW5kIFNldF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwI0tleV9lcXVhbGl0eSlcbiAqXG4gKiBOYU4gaXMgY29uc2lkZXJlZCB0aGUgc2FtZSBhcyBOYU4sIGhvd2V2ZXIgLTAgYW5kIDAgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWVcbiAqIHZhbHVlLCB3aGljaCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBieVxuICogW2BPYmplY3QuaXNgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXMpLlxuICpcbiAqIFRoaXMgaXMgZXh0ZW5kZWQgZnVydGhlciB0byBhbGxvdyBPYmplY3RzIHRvIGRlc2NyaWJlIHRoZSB2YWx1ZXMgdGhleVxuICogcmVwcmVzZW50LCBieSB3YXkgb2YgYHZhbHVlT2ZgIG9yIGBlcXVhbHNgIChhbmQgYGhhc2hDb2RlYCkuXG4gKlxuICogTm90ZTogYmVjYXVzZSBvZiB0aGlzIGV4dGVuc2lvbiwgdGhlIGtleSBlcXVhbGl0eSBvZiBJbW11dGFibGUuTWFwIGFuZCB0aGVcbiAqIHZhbHVlIGVxdWFsaXR5IG9mIEltbXV0YWJsZS5TZXQgd2lsbCBkaWZmZXIgZnJvbSBFUzYgTWFwIGFuZCBTZXQuXG4gKlxuICogIyMjIERlZmluaW5nIGN1c3RvbSB2YWx1ZXNcbiAqXG4gKiBUaGUgZWFzaWVzdCB3YXkgdG8gZGVzY3JpYmUgdGhlIHZhbHVlIGFuIG9iamVjdCByZXByZXNlbnRzIGlzIGJ5IGltcGxlbWVudGluZ1xuICogYHZhbHVlT2ZgLiBGb3IgZXhhbXBsZSwgYERhdGVgIHJlcHJlc2VudHMgYSB2YWx1ZSBieSByZXR1cm5pbmcgYSB1bml4XG4gKiB0aW1lc3RhbXAgZm9yIGB2YWx1ZU9mYDpcbiAqXG4gKiAgICAgdmFyIGRhdGUxID0gbmV3IERhdGUoMTIzNDU2Nzg5MDAwMCk7IC8vIEZyaSBGZWIgMTMgMjAwOSAuLi5cbiAqICAgICB2YXIgZGF0ZTIgPSBuZXcgRGF0ZSgxMjM0NTY3ODkwMDAwKTtcbiAqICAgICBkYXRlMS52YWx1ZU9mKCk7IC8vIDEyMzQ1Njc4OTAwMDBcbiAqICAgICBhc3NlcnQoIGRhdGUxICE9PSBkYXRlMiApO1xuICogICAgIGFzc2VydCggSW1tdXRhYmxlLmlzKCBkYXRlMSwgZGF0ZTIgKSApO1xuICpcbiAqIE5vdGU6IG92ZXJyaWRpbmcgYHZhbHVlT2ZgIG1heSBoYXZlIG90aGVyIGltcGxpY2F0aW9ucyBpZiB5b3UgdXNlIHRoaXMgb2JqZWN0XG4gKiB3aGVyZSBKYXZhU2NyaXB0IGV4cGVjdHMgYSBwcmltaXRpdmUsIHN1Y2ggYXMgaW1wbGljaXQgc3RyaW5nIGNvZXJjaW9uLlxuICpcbiAqIEZvciBtb3JlIGNvbXBsZXggdHlwZXMsIGVzcGVjaWFsbHkgY29sbGVjdGlvbnMsIGltcGxlbWVudGluZyBgdmFsdWVPZmAgbWF5XG4gKiBub3QgYmUgcGVyZm9ybWFudC4gQW4gYWx0ZXJuYXRpdmUgaXMgdG8gaW1wbGVtZW50IGBlcXVhbHNgIGFuZCBgaGFzaENvZGVgLlxuICpcbiAqIGBlcXVhbHNgIHRha2VzIGFub3RoZXIgb2JqZWN0LCBwcmVzdW1hYmx5IG9mIHNpbWlsYXIgdHlwZSwgYW5kIHJldHVybnMgdHJ1ZVxuICogaWYgaXQgaXMgZXF1YWwuIEVxdWFsaXR5IGlzIHN5bW1ldHJpY2FsLCBzbyB0aGUgc2FtZSByZXN1bHQgc2hvdWxkIGJlXG4gKiByZXR1cm5lZCBpZiB0aGlzIGFuZCB0aGUgYXJndW1lbnQgYXJlIGZsaXBwZWQuXG4gKlxuICogICAgIGFzc2VydCggYS5lcXVhbHMoYikgPT09IGIuZXF1YWxzKGEpICk7XG4gKlxuICogYGhhc2hDb2RlYCByZXR1cm5zIGEgMzJiaXQgaW50ZWdlciBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBvYmplY3Qgd2hpY2ggd2lsbFxuICogYmUgdXNlZCB0byBkZXRlcm1pbmUgaG93IHRvIHN0b3JlIHRoZSB2YWx1ZSBvYmplY3QgaW4gYSBNYXAgb3IgU2V0LiBZb3UgbXVzdFxuICogcHJvdmlkZSBib3RoIG9yIG5laXRoZXIgbWV0aG9kcywgb25lIG11c3Qgbm90IGV4aXN0IHdpdGhvdXQgdGhlIG90aGVyLlxuICpcbiAqIEFsc28sIGFuIGltcG9ydGFudCByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGVzZSBtZXRob2RzIG11c3QgYmUgdXBoZWxkOiBpZiB0d29cbiAqIHZhbHVlcyBhcmUgZXF1YWwsIHRoZXkgKm11c3QqIHJldHVybiB0aGUgc2FtZSBoYXNoQ29kZS4gSWYgdGhlIHZhbHVlcyBhcmUgbm90XG4gKiBlcXVhbCwgdGhleSBtaWdodCBoYXZlIHRoZSBzYW1lIGhhc2hDb2RlOyB0aGlzIGlzIGNhbGxlZCBhIGhhc2ggY29sbGlzaW9uLFxuICogYW5kIHdoaWxlIHVuZGVzaXJhYmxlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBpdCBpcyBhY2NlcHRhYmxlLlxuICpcbiAqICAgICBpZiAoYS5lcXVhbHMoYikpIHtcbiAqICAgICAgIGFzc2VydCggYS5oYXNoQ29kZSgpID09PSBiLmhhc2hDb2RlKCkgKTtcbiAqICAgICB9XG4gKlxuICogQWxsIEltbXV0YWJsZSBjb2xsZWN0aW9ucyBhcmUgVmFsdWUgT2JqZWN0czogdGhleSBpbXBsZW1lbnQgYGVxdWFscygpYFxuICogYW5kIGBoYXNoQ29kZSgpYC5cbiAqL1xuZnVuY3Rpb24gaXModmFsdWVBLCB2YWx1ZUIpIHtcbiAgaWYgKHZhbHVlQSA9PT0gdmFsdWVCIHx8ICh2YWx1ZUEgIT09IHZhbHVlQSAmJiB2YWx1ZUIgIT09IHZhbHVlQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIXZhbHVlQSB8fCAhdmFsdWVCKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChcbiAgICB0eXBlb2YgdmFsdWVBLnZhbHVlT2YgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsdWVCLnZhbHVlT2YgPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgdmFsdWVBID0gdmFsdWVBLnZhbHVlT2YoKTtcbiAgICB2YWx1ZUIgPSB2YWx1ZUIudmFsdWVPZigpO1xuICAgIGlmICh2YWx1ZUEgPT09IHZhbHVlQiB8fCAodmFsdWVBICE9PSB2YWx1ZUEgJiYgdmFsdWVCICE9PSB2YWx1ZUIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZUEgfHwgIXZhbHVlQikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gISEoXG4gICAgaXNWYWx1ZU9iamVjdCh2YWx1ZUEpICYmXG4gICAgaXNWYWx1ZU9iamVjdCh2YWx1ZUIpICYmXG4gICAgdmFsdWVBLmVxdWFscyh2YWx1ZUIpXG4gICk7XG59XG5cbnZhciBpbXVsID1cbiAgdHlwZW9mIE1hdGguaW11bCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXRoLmltdWwoMHhmZmZmZmZmZiwgMikgPT09IC0yXG4gICAgPyBNYXRoLmltdWxcbiAgICA6IGZ1bmN0aW9uIGltdWwoYSwgYikge1xuICAgICAgICBhIHw9IDA7IC8vIGludFxuICAgICAgICBiIHw9IDA7IC8vIGludFxuICAgICAgICB2YXIgYyA9IGEgJiAweGZmZmY7XG4gICAgICAgIHZhciBkID0gYiAmIDB4ZmZmZjtcbiAgICAgICAgLy8gU2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0LlxuICAgICAgICByZXR1cm4gKGMgKiBkICsgKCgoKGEgPj4+IDE2KSAqIGQgKyBjICogKGIgPj4+IDE2KSkgPDwgMTYpID4+PiAwKSkgfCAwOyAvLyBpbnRcbiAgICAgIH07XG5cbi8vIHY4IGhhcyBhbiBvcHRpbWl6YXRpb24gZm9yIHN0b3JpbmcgMzEtYml0IHNpZ25lZCBudW1iZXJzLlxuLy8gVmFsdWVzIHdoaWNoIGhhdmUgZWl0aGVyIDAwIG9yIDExIGFzIHRoZSBoaWdoIG9yZGVyIGJpdHMgcXVhbGlmeS5cbi8vIFRoaXMgZnVuY3Rpb24gZHJvcHMgdGhlIGhpZ2hlc3Qgb3JkZXIgYml0IGluIGEgc2lnbmVkIG51bWJlciwgbWFpbnRhaW5pbmdcbi8vIHRoZSBzaWduIGJpdC5cbmZ1bmN0aW9uIHNtaShpMzIpIHtcbiAgcmV0dXJuICgoaTMyID4+PiAxKSAmIDB4NDAwMDAwMDApIHwgKGkzMiAmIDB4YmZmZmZmZmYpO1xufVxuXG52YXIgZGVmYXVsdFZhbHVlT2YgPSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2Y7XG5cbmZ1bmN0aW9uIGhhc2gobykge1xuICBpZiAobyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGhhc2hOdWxsaXNoKG8pO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvLmhhc2hDb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRHJvcCBhbnkgaGlnaCBiaXRzIGZyb20gYWNjaWRlbnRhbGx5IGxvbmcgaGFzaCBjb2Rlcy5cbiAgICByZXR1cm4gc21pKG8uaGFzaENvZGUobykpO1xuICB9XG5cbiAgdmFyIHYgPSB2YWx1ZU9mKG8pO1xuXG4gIGlmICh2ID09IG51bGwpIHtcbiAgICByZXR1cm4gaGFzaE51bGxpc2godik7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAvLyBUaGUgaGFzaCB2YWx1ZXMgZm9yIGJ1aWx0LWluIGNvbnN0YW50cyBhcmUgYSAxIHZhbHVlIGZvciBlYWNoIDUtYnl0ZVxuICAgICAgLy8gc2hpZnQgcmVnaW9uIGV4cGVjdCBmb3IgdGhlIGZpcnN0LCB3aGljaCBlbmNvZGVzIHRoZSB2YWx1ZS4gVGhpc1xuICAgICAgLy8gcmVkdWNlcyB0aGUgb2RkcyBvZiBhIGhhc2ggY29sbGlzaW9uIGZvciB0aGVzZSBjb21tb24gdmFsdWVzLlxuICAgICAgcmV0dXJuIHYgPyAweDQyMTA4NDIxIDogMHg0MjEwODQyMDtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGhhc2hOdW1iZXIodik7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2Lmxlbmd0aCA+IFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU5cbiAgICAgICAgPyBjYWNoZWRIYXNoU3RyaW5nKHYpXG4gICAgICAgIDogaGFzaFN0cmluZyh2KTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiBoYXNoSlNPYmoodik7XG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybiBoYXNoU3ltYm9sKHYpO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHYudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hTdHJpbmcodi50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgdHlwZSAnICsgdHlwZW9mIHYgKyAnIGNhbm5vdCBiZSBoYXNoZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzaE51bGxpc2gobnVsbGlzaCkge1xuICByZXR1cm4gbnVsbGlzaCA9PT0gbnVsbCA/IDB4NDIxMDg0MjIgOiAvKiB1bmRlZmluZWQgKi8gMHg0MjEwODQyMztcbn1cblxuLy8gQ29tcHJlc3MgYXJiaXRyYXJpbHkgbGFyZ2UgbnVtYmVycyBpbnRvIHNtaSBoYXNoZXMuXG5mdW5jdGlvbiBoYXNoTnVtYmVyKG4pIHtcbiAgaWYgKG4gIT09IG4gfHwgbiA9PT0gSW5maW5pdHkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgaGFzaCA9IG4gfCAwO1xuICBpZiAoaGFzaCAhPT0gbikge1xuICAgIGhhc2ggXj0gbiAqIDB4ZmZmZmZmZmY7XG4gIH1cbiAgd2hpbGUgKG4gPiAweGZmZmZmZmZmKSB7XG4gICAgbiAvPSAweGZmZmZmZmZmO1xuICAgIGhhc2ggXj0gbjtcbiAgfVxuICByZXR1cm4gc21pKGhhc2gpO1xufVxuXG5mdW5jdGlvbiBjYWNoZWRIYXNoU3RyaW5nKHN0cmluZykge1xuICB2YXIgaGFzaGVkID0gc3RyaW5nSGFzaENhY2hlW3N0cmluZ107XG4gIGlmIChoYXNoZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIGhhc2hlZCA9IGhhc2hTdHJpbmcoc3RyaW5nKTtcbiAgICBpZiAoU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9PT0gU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUpIHtcbiAgICAgIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPSAwO1xuICAgICAgc3RyaW5nSGFzaENhY2hlID0ge307XG4gICAgfVxuICAgIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUrKztcbiAgICBzdHJpbmdIYXNoQ2FjaGVbc3RyaW5nXSA9IGhhc2hlZDtcbiAgfVxuICByZXR1cm4gaGFzaGVkO1xufVxuXG4vLyBodHRwOi8vanNwZXJmLmNvbS9oYXNoaW5nLXN0cmluZ3NcbmZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyaW5nKSB7XG4gIC8vIFRoaXMgaXMgdGhlIGhhc2ggZnJvbSBKVk1cbiAgLy8gVGhlIGhhc2ggY29kZSBmb3IgYSBzdHJpbmcgaXMgY29tcHV0ZWQgYXNcbiAgLy8gc1swXSAqIDMxIF4gKG4gLSAxKSArIHNbMV0gKiAzMSBeIChuIC0gMikgKyAuLi4gKyBzW24gLSAxXSxcbiAgLy8gd2hlcmUgc1tpXSBpcyB0aGUgaXRoIGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nIGFuZCBuIGlzIHRoZSBsZW5ndGggb2ZcbiAgLy8gdGhlIHN0cmluZy4gV2UgXCJtb2RcIiB0aGUgcmVzdWx0IHRvIG1ha2UgaXQgYmV0d2VlbiAwIChpbmNsdXNpdmUpIGFuZCAyXjMxXG4gIC8vIChleGNsdXNpdmUpIGJ5IGRyb3BwaW5nIGhpZ2ggYml0cy5cbiAgdmFyIGhhc2hlZCA9IDA7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBzdHJpbmcubGVuZ3RoOyBpaSsrKSB7XG4gICAgaGFzaGVkID0gKDMxICogaGFzaGVkICsgc3RyaW5nLmNoYXJDb2RlQXQoaWkpKSB8IDA7XG4gIH1cbiAgcmV0dXJuIHNtaShoYXNoZWQpO1xufVxuXG5mdW5jdGlvbiBoYXNoU3ltYm9sKHN5bSkge1xuICB2YXIgaGFzaGVkID0gc3ltYm9sTWFwW3N5bV07XG4gIGlmIChoYXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoYXNoZWQ7XG4gIH1cblxuICBoYXNoZWQgPSBuZXh0SGFzaCgpO1xuXG4gIHN5bWJvbE1hcFtzeW1dID0gaGFzaGVkO1xuXG4gIHJldHVybiBoYXNoZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc2hKU09iaihvYmopIHtcbiAgdmFyIGhhc2hlZDtcbiAgaWYgKHVzaW5nV2Vha01hcCkge1xuICAgIGhhc2hlZCA9IHdlYWtNYXAuZ2V0KG9iaik7XG4gICAgaWYgKGhhc2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaGFzaGVkO1xuICAgIH1cbiAgfVxuXG4gIGhhc2hlZCA9IG9ialtVSURfSEFTSF9LRVldO1xuICBpZiAoaGFzaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaGFzaGVkO1xuICB9XG5cbiAgaWYgKCFjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgIGhhc2hlZCA9IG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSAmJiBvYmoucHJvcGVydHlJc0VudW1lcmFibGVbVUlEX0hBU0hfS0VZXTtcbiAgICBpZiAoaGFzaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBoYXNoZWQ7XG4gICAgfVxuXG4gICAgaGFzaGVkID0gZ2V0SUVOb2RlSGFzaChvYmopO1xuICAgIGlmIChoYXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGhhc2hlZDtcbiAgICB9XG4gIH1cblxuICBoYXNoZWQgPSBuZXh0SGFzaCgpO1xuXG4gIGlmICh1c2luZ1dlYWtNYXApIHtcbiAgICB3ZWFrTWFwLnNldChvYmosIGhhc2hlZCk7XG4gIH0gZWxzZSBpZiAoaXNFeHRlbnNpYmxlICE9PSB1bmRlZmluZWQgJiYgaXNFeHRlbnNpYmxlKG9iaikgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tZXh0ZW5zaWJsZSBvYmplY3RzIGFyZSBub3QgYWxsb3dlZCBhcyBrZXlzLicpO1xuICB9IGVsc2UgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgVUlEX0hBU0hfS0VZLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogaGFzaGVkLFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKFxuICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlID09PSBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICkge1xuICAgIC8vIFNpbmNlIHdlIGNhbid0IGRlZmluZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBvYmplY3RcbiAgICAvLyB3ZSdsbCBoaWphY2sgb25lIG9mIHRoZSBsZXNzLXVzZWQgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyB0b1xuICAgIC8vIHNhdmUgb3VyIGhhc2ggb24gaXQuIFNpbmNlIHRoaXMgaXMgYSBmdW5jdGlvbiBpdCB3aWxsIG5vdCBzaG93IHVwIGluXG4gICAgLy8gYEpTT04uc3RyaW5naWZ5YCB3aGljaCBpcyB3aGF0IHdlIHdhbnQuXG4gICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmFwcGx5KFxuICAgICAgICB0aGlzLFxuICAgICAgICBhcmd1bWVudHNcbiAgICAgICk7XG4gICAgfTtcbiAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGVbVUlEX0hBU0hfS0VZXSA9IGhhc2hlZDtcbiAgfSBlbHNlIGlmIChvYmoubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgY291bGRuJ3QgZ2V0IHRoZSBJRSBgdW5pcXVlSURgIHRvIHVzZSBhcyBhIGhhc2hcbiAgICAvLyBhbmQgd2UgY291bGRuJ3QgdXNlIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgdG8gZXhwbG9pdCB0aGVcbiAgICAvLyBkb250RW51bSBidWcgc28gd2Ugc2ltcGx5IGFkZCB0aGUgYFVJRF9IQVNIX0tFWWAgb24gdGhlIG5vZGVcbiAgICAvLyBpdHNlbGYuXG4gICAgb2JqW1VJRF9IQVNIX0tFWV0gPSBoYXNoZWQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2V0IGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gb2JqZWN0LicpO1xuICB9XG5cbiAgcmV0dXJuIGhhc2hlZDtcbn1cblxuLy8gR2V0IHJlZmVyZW5jZXMgdG8gRVM1IG9iamVjdCBtZXRob2RzLlxudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbi8vIFRydWUgaWYgT2JqZWN0LmRlZmluZVByb3BlcnR5IHdvcmtzIGFzIGV4cGVjdGVkLiBJRTggZmFpbHMgdGhpcyB0ZXN0LlxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdAJywge30pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vLyBJRSBoYXMgYSBgdW5pcXVlSURgIHByb3BlcnR5IG9uIERPTSBub2Rlcy4gV2UgY2FuIGNvbnN0cnVjdCB0aGUgaGFzaCBmcm9tIGl0XG4vLyBhbmQgYXZvaWQgbWVtb3J5IGxlYWtzIGZyb20gdGhlIElFIGNsb25lTm9kZSBidWcuXG5mdW5jdGlvbiBnZXRJRU5vZGVIYXNoKG5vZGUpIHtcbiAgaWYgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA+IDApIHtcbiAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgMTogLy8gRWxlbWVudFxuICAgICAgICByZXR1cm4gbm9kZS51bmlxdWVJRDtcbiAgICAgIGNhc2UgOTogLy8gRG9jdW1lbnRcbiAgICAgICAgcmV0dXJuIG5vZGUuZG9jdW1lbnRFbGVtZW50ICYmIG5vZGUuZG9jdW1lbnRFbGVtZW50LnVuaXF1ZUlEO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWx1ZU9mKG9iaikge1xuICByZXR1cm4gb2JqLnZhbHVlT2YgIT09IGRlZmF1bHRWYWx1ZU9mICYmIHR5cGVvZiBvYmoudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gb2JqLnZhbHVlT2Yob2JqKVxuICAgIDogb2JqO1xufVxuXG5mdW5jdGlvbiBuZXh0SGFzaCgpIHtcbiAgdmFyIG5leHRIYXNoID0gKytfb2JqSGFzaFVJRDtcbiAgaWYgKF9vYmpIYXNoVUlEICYgMHg0MDAwMDAwMCkge1xuICAgIF9vYmpIYXNoVUlEID0gMDtcbiAgfVxuICByZXR1cm4gbmV4dEhhc2g7XG59XG5cbi8vIElmIHBvc3NpYmxlLCB1c2UgYSBXZWFrTWFwLlxudmFyIHVzaW5nV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nO1xudmFyIHdlYWtNYXA7XG5pZiAodXNpbmdXZWFrTWFwKSB7XG4gIHdlYWtNYXAgPSBuZXcgV2Vha01hcCgpO1xufVxuXG52YXIgc3ltYm9sTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxudmFyIF9vYmpIYXNoVUlEID0gMDtcblxudmFyIFVJRF9IQVNIX0tFWSA9ICdfX2ltbXV0YWJsZWhhc2hfXyc7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBVSURfSEFTSF9LRVkgPSBTeW1ib2woVUlEX0hBU0hfS0VZKTtcbn1cblxudmFyIFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU4gPSAxNjtcbnZhciBTVFJJTkdfSEFTSF9DQUNIRV9NQVhfU0laRSA9IDI1NTtcbnZhciBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcbnZhciBzdHJpbmdIYXNoQ2FjaGUgPSB7fTtcblxudmFyIFRvS2V5ZWRTZXF1ZW5jZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEtleWVkU2VxKSB7XG4gIGZ1bmN0aW9uIFRvS2V5ZWRTZXF1ZW5jZShpbmRleGVkLCB1c2VLZXlzKSB7XG4gICAgdGhpcy5faXRlciA9IGluZGV4ZWQ7XG4gICAgdGhpcy5fdXNlS2V5cyA9IHVzZUtleXM7XG4gICAgdGhpcy5zaXplID0gaW5kZXhlZC5zaXplO1xuICB9XG5cbiAgaWYgKCBLZXllZFNlcSApIFRvS2V5ZWRTZXF1ZW5jZS5fX3Byb3RvX18gPSBLZXllZFNlcTtcbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEtleWVkU2VxICYmIEtleWVkU2VxLnByb3RvdHlwZSApO1xuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9LZXllZFNlcXVlbmNlO1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuZ2V0KGtleSwgbm90U2V0VmFsdWUpO1xuICB9O1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlci5oYXMoa2V5KTtcbiAgfTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLnZhbHVlU2VxID0gZnVuY3Rpb24gdmFsdWVTZXEgKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLnZhbHVlU2VxKCk7XG4gIH07XG5cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIHZhciByZXZlcnNlZFNlcXVlbmNlID0gcmV2ZXJzZUZhY3RvcnkodGhpcywgdHJ1ZSk7XG4gICAgaWYgKCF0aGlzLl91c2VLZXlzKSB7XG4gICAgICByZXZlcnNlZFNlcXVlbmNlLnZhbHVlU2VxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxJDEuX2l0ZXIudG9TZXEoKS5yZXZlcnNlKCk7IH07XG4gICAgfVxuICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICB9O1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgdmFyIG1hcHBlZFNlcXVlbmNlID0gbWFwRmFjdG9yeSh0aGlzLCBtYXBwZXIsIGNvbnRleHQpO1xuICAgIGlmICghdGhpcy5fdXNlS2V5cykge1xuICAgICAgbWFwcGVkU2VxdWVuY2UudmFsdWVTZXEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEkMS5faXRlci50b1NlcSgpLm1hcChtYXBwZXIsIGNvbnRleHQpOyB9O1xuICAgIH1cbiAgICByZXR1cm4gbWFwcGVkU2VxdWVuY2U7XG4gIH07XG5cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4odiwgaywgdGhpcyQxJDEpOyB9LCByZXZlcnNlKTtcbiAgfTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgfTtcblxuICByZXR1cm4gVG9LZXllZFNlcXVlbmNlO1xufShLZXllZFNlcSkpO1xuVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuXG52YXIgVG9JbmRleGVkU2VxdWVuY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gIGZ1bmN0aW9uIFRvSW5kZXhlZFNlcXVlbmNlKGl0ZXIpIHtcbiAgICB0aGlzLl9pdGVyID0gaXRlcjtcbiAgICB0aGlzLnNpemUgPSBpdGVyLnNpemU7XG4gIH1cblxuICBpZiAoIEluZGV4ZWRTZXEgKSBUb0luZGV4ZWRTZXF1ZW5jZS5fX3Byb3RvX18gPSBJbmRleGVkU2VxO1xuICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvSW5kZXhlZFNlcXVlbmNlO1xuXG4gIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLmluY2x1ZGVzKHZhbHVlKTtcbiAgfTtcblxuICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgcmV2ZXJzZSAmJiBlbnN1cmVTaXplKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShcbiAgICAgIGZ1bmN0aW9uICh2KSB7IHJldHVybiBmbih2LCByZXZlcnNlID8gdGhpcyQxJDEuc2l6ZSAtICsraSA6IGkrKywgdGhpcyQxJDEpOyB9LFxuICAgICAgcmV2ZXJzZVxuICAgICk7XG4gIH07XG5cbiAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldmVyc2UgJiYgZW5zdXJlU2l6ZSh0aGlzKTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgcmV0dXJuIHN0ZXAuZG9uZVxuICAgICAgICA/IHN0ZXBcbiAgICAgICAgOiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHJldmVyc2UgPyB0aGlzJDEkMS5zaXplIC0gKytpIDogaSsrLFxuICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgIHN0ZXBcbiAgICAgICAgICApO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUb0luZGV4ZWRTZXF1ZW5jZTtcbn0oSW5kZXhlZFNlcSkpO1xuXG52YXIgVG9TZXRTZXF1ZW5jZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNldFNlcSkge1xuICBmdW5jdGlvbiBUb1NldFNlcXVlbmNlKGl0ZXIpIHtcbiAgICB0aGlzLl9pdGVyID0gaXRlcjtcbiAgICB0aGlzLnNpemUgPSBpdGVyLnNpemU7XG4gIH1cblxuICBpZiAoIFNldFNlcSApIFRvU2V0U2VxdWVuY2UuX19wcm90b19fID0gU2V0U2VxO1xuICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNldFNlcSAmJiBTZXRTZXEucHJvdG90eXBlICk7XG4gIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9TZXRTZXF1ZW5jZTtcblxuICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLmluY2x1ZGVzKGtleSk7XG4gIH07XG5cbiAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZuKHYsIHYsIHRoaXMkMSQxKTsgfSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3RlcC5kb25lXG4gICAgICAgID8gc3RlcFxuICAgICAgICA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgc3RlcC52YWx1ZSwgc3RlcC52YWx1ZSwgc3RlcCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFRvU2V0U2VxdWVuY2U7XG59KFNldFNlcSkpO1xuXG52YXIgRnJvbUVudHJpZXNTZXF1ZW5jZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEtleWVkU2VxKSB7XG4gIGZ1bmN0aW9uIEZyb21FbnRyaWVzU2VxdWVuY2UoZW50cmllcykge1xuICAgIHRoaXMuX2l0ZXIgPSBlbnRyaWVzO1xuICAgIHRoaXMuc2l6ZSA9IGVudHJpZXMuc2l6ZTtcbiAgfVxuXG4gIGlmICggS2V5ZWRTZXEgKSBGcm9tRW50cmllc1NlcXVlbmNlLl9fcHJvdG9fXyA9IEtleWVkU2VxO1xuICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEtleWVkU2VxICYmIEtleWVkU2VxLnByb3RvdHlwZSApO1xuICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZyb21FbnRyaWVzU2VxdWVuY2U7XG5cbiAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuZW50cnlTZXEgPSBmdW5jdGlvbiBlbnRyeVNlcSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIudG9TZXEoKTtcbiAgfTtcblxuICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIC8vIENoZWNrIGlmIGVudHJ5IGV4aXN0cyBmaXJzdCBzbyBhcnJheSBhY2Nlc3MgZG9lc24ndCB0aHJvdyBmb3IgaG9sZXNcbiAgICAgIC8vIGluIHRoZSBwYXJlbnQgaXRlcmF0aW9uLlxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIHZhbGlkYXRlRW50cnkoZW50cnkpO1xuICAgICAgICB2YXIgaW5kZXhlZENvbGxlY3Rpb24gPSBpc0NvbGxlY3Rpb24oZW50cnkpO1xuICAgICAgICByZXR1cm4gZm4oXG4gICAgICAgICAgaW5kZXhlZENvbGxlY3Rpb24gPyBlbnRyeS5nZXQoMSkgOiBlbnRyeVsxXSxcbiAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgwKSA6IGVudHJ5WzBdLFxuICAgICAgICAgIHRoaXMkMSQxXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAvLyBDaGVjayBpZiBlbnRyeSBleGlzdHMgZmlyc3Qgc28gYXJyYXkgYWNjZXNzIGRvZXNuJ3QgdGhyb3cgZm9yIGhvbGVzXG4gICAgICAgIC8vIGluIHRoZSBwYXJlbnQgaXRlcmF0aW9uLlxuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB2YXIgaW5kZXhlZENvbGxlY3Rpb24gPSBpc0NvbGxlY3Rpb24oZW50cnkpO1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGluZGV4ZWRDb2xsZWN0aW9uID8gZW50cnkuZ2V0KDApIDogZW50cnlbMF0sXG4gICAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgxKSA6IGVudHJ5WzFdLFxuICAgICAgICAgICAgc3RlcFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRnJvbUVudHJpZXNTZXF1ZW5jZTtcbn0oS2V5ZWRTZXEpKTtcblxuVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPVxuICAgIGNhY2hlUmVzdWx0VGhyb3VnaDtcblxuZnVuY3Rpb24gZmxpcEZhY3RvcnkoY29sbGVjdGlvbikge1xuICB2YXIgZmxpcFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICBmbGlwU2VxdWVuY2UuX2l0ZXIgPSBjb2xsZWN0aW9uO1xuICBmbGlwU2VxdWVuY2Uuc2l6ZSA9IGNvbGxlY3Rpb24uc2l6ZTtcbiAgZmxpcFNlcXVlbmNlLmZsaXAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uOyB9O1xuICBmbGlwU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IGNvbGxlY3Rpb24ucmV2ZXJzZS5hcHBseSh0aGlzKTsgLy8gc3VwZXIucmV2ZXJzZSgpXG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbi5yZXZlcnNlKCk7IH07XG4gICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG4gIH07XG4gIGZsaXBTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmluY2x1ZGVzKGtleSk7IH07XG4gIGZsaXBTZXF1ZW5jZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNvbGxlY3Rpb24uaGFzKGtleSk7IH07XG4gIGZsaXBTZXF1ZW5jZS5jYWNoZVJlc3VsdCA9IGNhY2hlUmVzdWx0VGhyb3VnaDtcbiAgZmxpcFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIHJldHVybiBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4oaywgdiwgdGhpcyQxJDEpICE9PSBmYWxzZTsgfSwgcmV2ZXJzZSk7XG4gIH07XG4gIGZsaXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgICB2YXIgayA9IHN0ZXAudmFsdWVbMF07XG4gICAgICAgICAgc3RlcC52YWx1ZVswXSA9IHN0ZXAudmFsdWVbMV07XG4gICAgICAgICAgc3RlcC52YWx1ZVsxXSA9IGs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uX19pdGVyYXRvcihcbiAgICAgIHR5cGUgPT09IElURVJBVEVfVkFMVUVTID8gSVRFUkFURV9LRVlTIDogSVRFUkFURV9WQUxVRVMsXG4gICAgICByZXZlcnNlXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIGZsaXBTZXF1ZW5jZTtcbn1cblxuZnVuY3Rpb24gbWFwRmFjdG9yeShjb2xsZWN0aW9uLCBtYXBwZXIsIGNvbnRleHQpIHtcbiAgdmFyIG1hcHBlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICBtYXBwZWRTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplO1xuICBtYXBwZWRTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmhhcyhrZXkpOyB9O1xuICBtYXBwZWRTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHZhciB2ID0gY29sbGVjdGlvbi5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICByZXR1cm4gdiA9PT0gTk9UX1NFVFxuICAgICAgPyBub3RTZXRWYWx1ZVxuICAgICAgOiBtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrZXksIGNvbGxlY3Rpb24pO1xuICB9O1xuICBtYXBwZWRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICBmdW5jdGlvbiAodiwgaywgYykgeyByZXR1cm4gZm4obWFwcGVyLmNhbGwoY29udGV4dCwgdiwgaywgYyksIGssIHRoaXMkMSQxKSAhPT0gZmFsc2U7IH0sXG4gICAgICByZXZlcnNlXG4gICAgKTtcbiAgfTtcbiAgbWFwcGVkU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgIH1cbiAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICB2YXIga2V5ID0gZW50cnlbMF07XG4gICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgdHlwZSxcbiAgICAgICAga2V5LFxuICAgICAgICBtYXBwZXIuY2FsbChjb250ZXh0LCBlbnRyeVsxXSwga2V5LCBjb2xsZWN0aW9uKSxcbiAgICAgICAgc3RlcFxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIG1hcHBlZFNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlRmFjdG9yeShjb2xsZWN0aW9uLCB1c2VLZXlzKSB7XG4gIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIHJldmVyc2VkU2VxdWVuY2UuX2l0ZXIgPSBjb2xsZWN0aW9uO1xuICByZXZlcnNlZFNlcXVlbmNlLnNpemUgPSBjb2xsZWN0aW9uLnNpemU7XG4gIHJldmVyc2VkU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb247IH07XG4gIGlmIChjb2xsZWN0aW9uLmZsaXApIHtcbiAgICByZXZlcnNlZFNlcXVlbmNlLmZsaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpcFNlcXVlbmNlID0gZmxpcEZhY3RvcnkoY29sbGVjdGlvbik7XG4gICAgICBmbGlwU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb24uZmxpcCgpOyB9O1xuICAgICAgcmV0dXJuIGZsaXBTZXF1ZW5jZTtcbiAgICB9O1xuICB9XG4gIHJldmVyc2VkU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24gKGtleSwgbm90U2V0VmFsdWUpIHsgcmV0dXJuIGNvbGxlY3Rpb24uZ2V0KHVzZUtleXMgPyBrZXkgOiAtMSAtIGtleSwgbm90U2V0VmFsdWUpOyB9O1xuICByZXZlcnNlZFNlcXVlbmNlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNvbGxlY3Rpb24uaGFzKHVzZUtleXMgPyBrZXkgOiAtMSAtIGtleSk7IH07XG4gIHJldmVyc2VkU2VxdWVuY2UuaW5jbHVkZXMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGNvbGxlY3Rpb24uaW5jbHVkZXModmFsdWUpOyB9O1xuICByZXZlcnNlZFNlcXVlbmNlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuICByZXZlcnNlZFNlcXVlbmNlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgcmV2ZXJzZSAmJiBlbnN1cmVTaXplKGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiBjb2xsZWN0aW9uLl9faXRlcmF0ZShcbiAgICAgIGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IHJldmVyc2UgPyB0aGlzJDEkMS5zaXplIC0gKytpIDogaSsrLCB0aGlzJDEkMSk7IH0sXG4gICAgICAhcmV2ZXJzZVxuICAgICk7XG4gIH07XG4gIHJldmVyc2VkU2VxdWVuY2UuX19pdGVyYXRvciA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldmVyc2UgJiYgZW5zdXJlU2l6ZShjb2xsZWN0aW9uKTtcbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCAhcmV2ZXJzZSk7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICB9XG4gICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHVzZUtleXMgPyBlbnRyeVswXSA6IHJldmVyc2UgPyB0aGlzJDEkMS5zaXplIC0gKytpIDogaSsrLFxuICAgICAgICBlbnRyeVsxXSxcbiAgICAgICAgc3RlcFxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckZhY3RvcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG4gIHZhciBmaWx0ZXJTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgaWYgKHVzZUtleXMpIHtcbiAgICBmaWx0ZXJTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgdiA9IGNvbGxlY3Rpb24uZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgICByZXR1cm4gdiAhPT0gTk9UX1NFVCAmJiAhIXByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGtleSwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBmaWx0ZXJTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIHYgPSBjb2xsZWN0aW9uLmdldChrZXksIE5PVF9TRVQpO1xuICAgICAgcmV0dXJuIHYgIT09IE5PVF9TRVQgJiYgcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwga2V5LCBjb2xsZWN0aW9uKVxuICAgICAgICA/IHZcbiAgICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuICB9XG4gIGZpbHRlclNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaywgYykge1xuICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgcmV0dXJuIGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIHRoaXMkMSQxKTtcbiAgICAgIH1cbiAgICB9LCByZXZlcnNlKTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcbiAgZmlsdGVyU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIHZhciBrZXkgPSBlbnRyeVswXTtcbiAgICAgICAgdmFyIHZhbHVlID0gZW50cnlbMV07XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIHVzZUtleXMgPyBrZXkgOiBpdGVyYXRpb25zKyssIHZhbHVlLCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gZmlsdGVyU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIGNvdW50QnlGYWN0b3J5KGNvbGxlY3Rpb24sIGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgdmFyIGdyb3VwcyA9IE1hcCgpLmFzTXV0YWJsZSgpO1xuICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgIGdyb3Vwcy51cGRhdGUoZ3JvdXBlci5jYWxsKGNvbnRleHQsIHYsIGssIGNvbGxlY3Rpb24pLCAwLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSArIDE7IH0pO1xuICB9KTtcbiAgcmV0dXJuIGdyb3Vwcy5hc0ltbXV0YWJsZSgpO1xufVxuXG5mdW5jdGlvbiBncm91cEJ5RmFjdG9yeShjb2xsZWN0aW9uLCBncm91cGVyLCBjb250ZXh0KSB7XG4gIHZhciBpc0tleWVkSXRlciA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gIHZhciBncm91cHMgPSAoaXNPcmRlcmVkKGNvbGxlY3Rpb24pID8gT3JkZXJlZE1hcCgpIDogTWFwKCkpLmFzTXV0YWJsZSgpO1xuICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgIGdyb3Vwcy51cGRhdGUoXG4gICAgICBncm91cGVyLmNhbGwoY29udGV4dCwgdiwgaywgY29sbGVjdGlvbiksXG4gICAgICBmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChhID0gYSB8fCBbXSksIGEucHVzaChpc0tleWVkSXRlciA/IFtrLCB2XSA6IHYpLCBhKTsgfVxuICAgICk7XG4gIH0pO1xuICB2YXIgY29lcmNlID0gY29sbGVjdGlvbkNsYXNzKGNvbGxlY3Rpb24pO1xuICByZXR1cm4gZ3JvdXBzLm1hcChmdW5jdGlvbiAoYXJyKSB7IHJldHVybiByZWlmeShjb2xsZWN0aW9uLCBjb2VyY2UoYXJyKSk7IH0pLmFzSW1tdXRhYmxlKCk7XG59XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbkZhY3RvcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gIHZhciBpc0tleWVkSXRlciA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gIHZhciBncm91cHMgPSBbW10sIFtdXTtcbiAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICBncm91cHNbcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgY29sbGVjdGlvbikgPyAxIDogMF0ucHVzaChcbiAgICAgIGlzS2V5ZWRJdGVyID8gW2ssIHZdIDogdlxuICAgICk7XG4gIH0pO1xuICB2YXIgY29lcmNlID0gY29sbGVjdGlvbkNsYXNzKGNvbGxlY3Rpb24pO1xuICByZXR1cm4gZ3JvdXBzLm1hcChmdW5jdGlvbiAoYXJyKSB7IHJldHVybiByZWlmeShjb2xsZWN0aW9uLCBjb2VyY2UoYXJyKSk7IH0pO1xufVxuXG5mdW5jdGlvbiBzbGljZUZhY3RvcnkoY29sbGVjdGlvbiwgYmVnaW4sIGVuZCwgdXNlS2V5cykge1xuICB2YXIgb3JpZ2luYWxTaXplID0gY29sbGVjdGlvbi5zaXplO1xuXG4gIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIG9yaWdpbmFsU2l6ZSkpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuXG4gIC8vIGJlZ2luIG9yIGVuZCBjYW4gbm90IGJlIHJlc29sdmVkIGlmIHRoZXkgd2VyZSBwcm92aWRlZCBhcyBuZWdhdGl2ZSBudW1iZXJzIGFuZFxuICAvLyB0aGlzIGNvbGxlY3Rpb24ncyBzaXplIGlzIHVua25vd24uIEluIHRoYXQgY2FzZSwgY2FjaGUgZmlyc3Qgc28gdGhlcmUgaXNcbiAgLy8gYSBrbm93biBzaXplIGFuZCB0aGVzZSBkbyBub3QgcmVzb2x2ZSB0byBOYU4uXG4gIGlmICh0eXBlb2Ygb3JpZ2luYWxTaXplID09PSAndW5kZWZpbmVkJyAmJiAoYmVnaW4gPCAwIHx8IGVuZCA8IDApKSB7XG4gICAgcmV0dXJuIHNsaWNlRmFjdG9yeShjb2xsZWN0aW9uLnRvU2VxKCkuY2FjaGVSZXN1bHQoKSwgYmVnaW4sIGVuZCwgdXNlS2V5cyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZWRCZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgb3JpZ2luYWxTaXplKTtcbiAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIG9yaWdpbmFsU2l6ZSk7XG5cbiAgLy8gTm90ZTogcmVzb2x2ZWRFbmQgaXMgdW5kZWZpbmVkIHdoZW4gdGhlIG9yaWdpbmFsIHNlcXVlbmNlJ3MgbGVuZ3RoIGlzXG4gIC8vIHVua25vd24gYW5kIHRoaXMgc2xpY2UgZGlkIG5vdCBzdXBwbHkgYW4gZW5kIGFuZCBzaG91bGQgY29udGFpbiBhbGxcbiAgLy8gZWxlbWVudHMgYWZ0ZXIgcmVzb2x2ZWRCZWdpbi5cbiAgLy8gSW4gdGhhdCBjYXNlLCByZXNvbHZlZFNpemUgd2lsbCBiZSBOYU4gYW5kIHNsaWNlU2l6ZSB3aWxsIHJlbWFpbiB1bmRlZmluZWQuXG4gIHZhciByZXNvbHZlZFNpemUgPSByZXNvbHZlZEVuZCAtIHJlc29sdmVkQmVnaW47XG4gIHZhciBzbGljZVNpemU7XG4gIGlmIChyZXNvbHZlZFNpemUgPT09IHJlc29sdmVkU2l6ZSkge1xuICAgIHNsaWNlU2l6ZSA9IHJlc29sdmVkU2l6ZSA8IDAgPyAwIDogcmVzb2x2ZWRTaXplO1xuICB9XG5cbiAgdmFyIHNsaWNlU2VxID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuXG4gIC8vIElmIGNvbGxlY3Rpb24uc2l6ZSBpcyB1bmRlZmluZWQsIHRoZSBzaXplIG9mIHRoZSByZWFsaXplZCBzbGljZVNlcSBpc1xuICAvLyB1bmtub3duIGF0IHRoaXMgcG9pbnQgdW5sZXNzIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gc2xpY2UgaXMgMFxuICBzbGljZVNlcS5zaXplID1cbiAgICBzbGljZVNpemUgPT09IDAgPyBzbGljZVNpemUgOiAoY29sbGVjdGlvbi5zaXplICYmIHNsaWNlU2l6ZSkgfHwgdW5kZWZpbmVkO1xuXG4gIGlmICghdXNlS2V5cyAmJiBpc1NlcShjb2xsZWN0aW9uKSAmJiBzbGljZVNpemUgPj0gMCkge1xuICAgIHNsaWNlU2VxLmdldCA9IGZ1bmN0aW9uIChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgc2xpY2VTaXplXG4gICAgICAgID8gY29sbGVjdGlvbi5nZXQoaW5kZXggKyByZXNvbHZlZEJlZ2luLCBub3RTZXRWYWx1ZSlcbiAgICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgc2xpY2VTZXEuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgaWYgKHNsaWNlU2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBza2lwcGVkID0gMDtcbiAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gc2tpcHBlZCsrIDwgcmVzb2x2ZWRCZWdpbikpKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEkMSkgIT09IGZhbHNlICYmXG4gICAgICAgICAgaXRlcmF0aW9ucyAhPT0gc2xpY2VTaXplXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgc2xpY2VTZXEuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICBpZiAoc2xpY2VTaXplICE9PSAwICYmIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGluc3RhbnRpYXRpbmcgcGFyZW50IGl0ZXJhdG9yIGlmIHRha2luZyAwLlxuICAgIGlmIChzbGljZVNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoaXRlcmF0b3JEb25lKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIHZhciBza2lwcGVkID0gMDtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAoc2tpcHBlZCsrIDwgcmVzb2x2ZWRCZWdpbikge1xuICAgICAgICBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgICBpZiAoKytpdGVyYXRpb25zID4gc2xpY2VTaXplKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKHVzZUtleXMgfHwgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMgfHwgc3RlcC5kb25lKSB7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfS0VZUykge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zIC0gMSwgdW5kZWZpbmVkLCBzdGVwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMgLSAxLCBzdGVwLnZhbHVlWzFdLCBzdGVwKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gc2xpY2VTZXE7XG59XG5cbmZ1bmN0aW9uIHRha2VXaGlsZUZhY3RvcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gIHZhciB0YWtlU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIHRha2VTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICBmdW5jdGlvbiAodiwgaywgYykgeyByZXR1cm4gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykgJiYgKytpdGVyYXRpb25zICYmIGZuKHYsIGssIHRoaXMkMSQxKTsgfVxuICAgICk7XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG4gIHRha2VTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICB2YXIgaXRlcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghaXRlcmF0aW5nKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgIH1cbiAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICB2YXIgayA9IGVudHJ5WzBdO1xuICAgICAgdmFyIHYgPSBlbnRyeVsxXTtcbiAgICAgIGlmICghcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgdGhpcyQxJDEpKSB7XG4gICAgICAgIGl0ZXJhdGluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgc3RlcCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiB0YWtlU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIHNraXBXaGlsZUZhY3RvcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG4gIHZhciBza2lwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIHNraXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpKSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEkMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG4gIHNraXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICB2YXIgc2tpcHBpbmcgPSB0cnVlO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGs7XG4gICAgICB2YXIgdjtcbiAgICAgIGRvIHtcbiAgICAgICAgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIGlmICh1c2VLZXlzIHx8IHR5cGUgPT09IElURVJBVEVfVkFMVUVTKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfS0VZUykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB1bmRlZmluZWQsIHN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWVbMV0sIHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIGsgPSBlbnRyeVswXTtcbiAgICAgICAgdiA9IGVudHJ5WzFdO1xuICAgICAgICBza2lwcGluZyAmJiAoc2tpcHBpbmcgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDEkMSkpO1xuICAgICAgfSB3aGlsZSAoc2tpcHBpbmcpO1xuICAgICAgcmV0dXJuIHR5cGUgPT09IElURVJBVEVfRU5UUklFUyA/IHN0ZXAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGssIHYsIHN0ZXApO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gc2tpcFNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiBjb25jYXRGYWN0b3J5KGNvbGxlY3Rpb24sIHZhbHVlcykge1xuICB2YXIgaXNLZXllZENvbGxlY3Rpb24gPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICB2YXIgaXRlcnMgPSBbY29sbGVjdGlvbl1cbiAgICAuY29uY2F0KHZhbHVlcylcbiAgICAubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICBpZiAoIWlzQ29sbGVjdGlvbih2KSkge1xuICAgICAgICB2ID0gaXNLZXllZENvbGxlY3Rpb25cbiAgICAgICAgICA/IGtleWVkU2VxRnJvbVZhbHVlKHYpXG4gICAgICAgICAgOiBpbmRleGVkU2VxRnJvbVZhbHVlKEFycmF5LmlzQXJyYXkodikgPyB2IDogW3ZdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNLZXllZENvbGxlY3Rpb24pIHtcbiAgICAgICAgdiA9IEtleWVkQ29sbGVjdGlvbih2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH0pXG4gICAgLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gdi5zaXplICE9PSAwOyB9KTtcblxuICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH1cblxuICBpZiAoaXRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHNpbmdsZXRvbiA9IGl0ZXJzWzBdO1xuICAgIGlmIChcbiAgICAgIHNpbmdsZXRvbiA9PT0gY29sbGVjdGlvbiB8fFxuICAgICAgKGlzS2V5ZWRDb2xsZWN0aW9uICYmIGlzS2V5ZWQoc2luZ2xldG9uKSkgfHxcbiAgICAgIChpc0luZGV4ZWQoY29sbGVjdGlvbikgJiYgaXNJbmRleGVkKHNpbmdsZXRvbikpXG4gICAgKSB7XG4gICAgICByZXR1cm4gc2luZ2xldG9uO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb25jYXRTZXEgPSBuZXcgQXJyYXlTZXEoaXRlcnMpO1xuICBpZiAoaXNLZXllZENvbGxlY3Rpb24pIHtcbiAgICBjb25jYXRTZXEgPSBjb25jYXRTZXEudG9LZXllZFNlcSgpO1xuICB9IGVsc2UgaWYgKCFpc0luZGV4ZWQoY29sbGVjdGlvbikpIHtcbiAgICBjb25jYXRTZXEgPSBjb25jYXRTZXEudG9TZXRTZXEoKTtcbiAgfVxuICBjb25jYXRTZXEgPSBjb25jYXRTZXEuZmxhdHRlbih0cnVlKTtcbiAgY29uY2F0U2VxLnNpemUgPSBpdGVycy5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgc2VxKSB7XG4gICAgaWYgKHN1bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgc2l6ZSA9IHNlcS5zaXplO1xuICAgICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3VtICsgc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIDApO1xuICByZXR1cm4gY29uY2F0U2VxO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuRmFjdG9yeShjb2xsZWN0aW9uLCBkZXB0aCwgdXNlS2V5cykge1xuICB2YXIgZmxhdFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICBmbGF0U2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBmbGF0RGVlcChpdGVyLCBjdXJyZW50RGVwdGgpIHtcbiAgICAgIGl0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIGlmICgoIWRlcHRoIHx8IGN1cnJlbnREZXB0aCA8IGRlcHRoKSAmJiBpc0NvbGxlY3Rpb24odikpIHtcbiAgICAgICAgICBmbGF0RGVlcCh2LCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgaWYgKGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIGZsYXRTZXF1ZW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFzdG9wcGVkO1xuICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIGZsYXREZWVwKGNvbGxlY3Rpb24sIDApO1xuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuICBmbGF0U2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKGl0ZXJhdG9yKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lICE9PSBmYWxzZSkge1xuICAgICAgICAgIGl0ZXJhdG9yID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHYgPSBzdGVwLnZhbHVlO1xuICAgICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTKSB7XG4gICAgICAgICAgdiA9IHZbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghZGVwdGggfHwgc3RhY2subGVuZ3RoIDwgZGVwdGgpICYmIGlzQ29sbGVjdGlvbih2KSkge1xuICAgICAgICAgIHN0YWNrLnB1c2goaXRlcmF0b3IpO1xuICAgICAgICAgIGl0ZXJhdG9yID0gdi5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB1c2VLZXlzID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2LCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gZmxhdFNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiBmbGF0TWFwRmFjdG9yeShjb2xsZWN0aW9uLCBtYXBwZXIsIGNvbnRleHQpIHtcbiAgdmFyIGNvZXJjZSA9IGNvbGxlY3Rpb25DbGFzcyhjb2xsZWN0aW9uKTtcbiAgcmV0dXJuIGNvbGxlY3Rpb25cbiAgICAudG9TZXEoKVxuICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGNvZXJjZShtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBjb2xsZWN0aW9uKSk7IH0pXG4gICAgLmZsYXR0ZW4odHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGludGVycG9zZUZhY3RvcnkoY29sbGVjdGlvbiwgc2VwYXJhdG9yKSB7XG4gIHZhciBpbnRlcnBvc2VkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIGludGVycG9zZWRTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplICYmIGNvbGxlY3Rpb24uc2l6ZSAqIDIgLSAxO1xuICBpbnRlcnBvc2VkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgZnVuY3Rpb24gKHYpIHsgcmV0dXJuICghaXRlcmF0aW9ucyB8fCBmbihzZXBhcmF0b3IsIGl0ZXJhdGlvbnMrKywgdGhpcyQxJDEpICE9PSBmYWxzZSkgJiZcbiAgICAgICAgZm4odiwgaXRlcmF0aW9ucysrLCB0aGlzJDEkMSkgIT09IGZhbHNlOyB9LFxuICAgICAgcmV2ZXJzZVxuICAgICk7XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG4gIGludGVycG9zZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHZhciBzdGVwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzdGVwIHx8IGl0ZXJhdGlvbnMgJSAyKSB7XG4gICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnMgJSAyXG4gICAgICAgID8gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHNlcGFyYXRvcilcbiAgICAgICAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZSwgc3RlcCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBpbnRlcnBvc2VkU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIHNvcnRGYWN0b3J5KGNvbGxlY3Rpb24sIGNvbXBhcmF0b3IsIG1hcHBlcikge1xuICBpZiAoIWNvbXBhcmF0b3IpIHtcbiAgICBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3I7XG4gIH1cbiAgdmFyIGlzS2V5ZWRDb2xsZWN0aW9uID0gaXNLZXllZChjb2xsZWN0aW9uKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGVudHJpZXMgPSBjb2xsZWN0aW9uXG4gICAgLnRvU2VxKClcbiAgICAubWFwKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBbaywgdiwgaW5kZXgrKywgbWFwcGVyID8gbWFwcGVyKHYsIGssIGNvbGxlY3Rpb24pIDogdl07IH0pXG4gICAgLnZhbHVlU2VxKClcbiAgICAudG9BcnJheSgpO1xuICBlbnRyaWVzXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNvbXBhcmF0b3IoYVszXSwgYlszXSkgfHwgYVsyXSAtIGJbMl07IH0pXG4gICAgLmZvckVhY2goXG4gICAgICBpc0tleWVkQ29sbGVjdGlvblxuICAgICAgICA/IGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICBlbnRyaWVzW2ldLmxlbmd0aCA9IDI7XG4gICAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICBlbnRyaWVzW2ldID0gdlsxXTtcbiAgICAgICAgICB9XG4gICAgKTtcbiAgcmV0dXJuIGlzS2V5ZWRDb2xsZWN0aW9uXG4gICAgPyBLZXllZFNlcShlbnRyaWVzKVxuICAgIDogaXNJbmRleGVkKGNvbGxlY3Rpb24pXG4gICAgPyBJbmRleGVkU2VxKGVudHJpZXMpXG4gICAgOiBTZXRTZXEoZW50cmllcyk7XG59XG5cbmZ1bmN0aW9uIG1heEZhY3RvcnkoY29sbGVjdGlvbiwgY29tcGFyYXRvciwgbWFwcGVyKSB7XG4gIGlmICghY29tcGFyYXRvcikge1xuICAgIGNvbXBhcmF0b3IgPSBkZWZhdWx0Q29tcGFyYXRvcjtcbiAgfVxuICBpZiAobWFwcGVyKSB7XG4gICAgdmFyIGVudHJ5ID0gY29sbGVjdGlvblxuICAgICAgLnRvU2VxKClcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIFt2LCBtYXBwZXIodiwgaywgY29sbGVjdGlvbildOyB9KVxuICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKG1heENvbXBhcmUoY29tcGFyYXRvciwgYVsxXSwgYlsxXSkgPyBiIDogYSk7IH0pO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXTtcbiAgfVxuICByZXR1cm4gY29sbGVjdGlvbi5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGEsIGIpID8gYiA6IGEpOyB9KTtcbn1cblxuZnVuY3Rpb24gbWF4Q29tcGFyZShjb21wYXJhdG9yLCBhLCBiKSB7XG4gIHZhciBjb21wID0gY29tcGFyYXRvcihiLCBhKTtcbiAgLy8gYiBpcyBjb25zaWRlcmVkIHRoZSBuZXcgbWF4IGlmIHRoZSBjb21wYXJhdG9yIGRlY2xhcmVzIHRoZW0gZXF1YWwsIGJ1dFxuICAvLyB0aGV5IGFyZSBub3QgZXF1YWwgYW5kIGIgaXMgaW4gZmFjdCBhIG51bGxpc2ggdmFsdWUuXG4gIHJldHVybiAoXG4gICAgKGNvbXAgPT09IDAgJiYgYiAhPT0gYSAmJiAoYiA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiAhPT0gYikpIHx8XG4gICAgY29tcCA+IDBcbiAgKTtcbn1cblxuZnVuY3Rpb24gemlwV2l0aEZhY3Rvcnkoa2V5SXRlciwgemlwcGVyLCBpdGVycywgemlwQWxsKSB7XG4gIHZhciB6aXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShrZXlJdGVyKTtcbiAgdmFyIHNpemVzID0gbmV3IEFycmF5U2VxKGl0ZXJzKS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuc2l6ZTsgfSk7XG4gIHppcFNlcXVlbmNlLnNpemUgPSB6aXBBbGwgPyBzaXplcy5tYXgoKSA6IHNpemVzLm1pbigpO1xuICAvLyBOb3RlOiB0aGlzIGEgZ2VuZXJpYyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIF9faXRlcmF0ZSBpbiB0ZXJtcyBvZlxuICAvLyBfX2l0ZXJhdG9yIHdoaWNoIG1heSBiZSBtb3JlIGdlbmVyaWNhbGx5IHVzZWZ1bCBpbiB0aGUgZnV0dXJlLlxuICB6aXBTZXF1ZW5jZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICAvKiBnZW5lcmljOlxuICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgIHZhciBzdGVwO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICBpdGVyYXRpb25zKys7XG4gICAgICBpZiAoZm4oc3RlcC52YWx1ZVsxXSwgc3RlcC52YWx1ZVswXSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICAqL1xuICAgIC8vIGluZGV4ZWQ6XG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICB2YXIgc3RlcDtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgaWYgKGZuKHN0ZXAudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcbiAgemlwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgaXRlcmF0b3JzID0gaXRlcnMubWFwKFxuICAgICAgZnVuY3Rpb24gKGkpIHsgcmV0dXJuICgoaSA9IENvbGxlY3Rpb24oaSkpLCBnZXRJdGVyYXRvcihyZXZlcnNlID8gaS5yZXZlcnNlKCkgOiBpKSk7IH1cbiAgICApO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB2YXIgaXNEb25lID0gZmFsc2U7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcHM7XG4gICAgICBpZiAoIWlzRG9uZSkge1xuICAgICAgICBzdGVwcyA9IGl0ZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkubmV4dCgpOyB9KTtcbiAgICAgICAgaXNEb25lID0gemlwQWxsID8gc3RlcHMuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuZG9uZTsgfSkgOiBzdGVwcy5zb21lKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLmRvbmU7IH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRG9uZSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgdHlwZSxcbiAgICAgICAgaXRlcmF0aW9ucysrLFxuICAgICAgICB6aXBwZXIuYXBwbHkoXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBzdGVwcy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudmFsdWU7IH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiB6aXBTZXF1ZW5jZTtcbn1cblxuLy8gI3ByYWdtYSBIZWxwZXIgRnVuY3Rpb25zXG5cbmZ1bmN0aW9uIHJlaWZ5KGl0ZXIsIHNlcSkge1xuICByZXR1cm4gaXRlciA9PT0gc2VxID8gaXRlciA6IGlzU2VxKGl0ZXIpID8gc2VxIDogaXRlci5jb25zdHJ1Y3RvcihzZXEpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUVudHJ5KGVudHJ5KSB7XG4gIGlmIChlbnRyeSAhPT0gT2JqZWN0KGVudHJ5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFtLLCBWXSB0dXBsZTogJyArIGVudHJ5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uQ2xhc3MoY29sbGVjdGlvbikge1xuICByZXR1cm4gaXNLZXllZChjb2xsZWN0aW9uKVxuICAgID8gS2V5ZWRDb2xsZWN0aW9uXG4gICAgOiBpc0luZGV4ZWQoY29sbGVjdGlvbilcbiAgICA/IEluZGV4ZWRDb2xsZWN0aW9uXG4gICAgOiBTZXRDb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbikge1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShcbiAgICAoaXNLZXllZChjb2xsZWN0aW9uKVxuICAgICAgPyBLZXllZFNlcVxuICAgICAgOiBpc0luZGV4ZWQoY29sbGVjdGlvbilcbiAgICAgID8gSW5kZXhlZFNlcVxuICAgICAgOiBTZXRTZXFcbiAgICApLnByb3RvdHlwZVxuICApO1xufVxuXG5mdW5jdGlvbiBjYWNoZVJlc3VsdFRocm91Z2goKSB7XG4gIGlmICh0aGlzLl9pdGVyLmNhY2hlUmVzdWx0KSB7XG4gICAgdGhpcy5faXRlci5jYWNoZVJlc3VsdCgpO1xuICAgIHRoaXMuc2l6ZSA9IHRoaXMuX2l0ZXIuc2l6ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXR1cm4gU2VxLnByb3RvdHlwZS5jYWNoZVJlc3VsdC5jYWxsKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyYXRvcihhLCBiKSB7XG4gIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xufVxuXG5mdW5jdGlvbiBhcnJDb3B5KGFyciwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgYXJyLmxlbmd0aCAtIG9mZnNldCk7XG4gIHZhciBuZXdBcnIgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbjsgaWkrKykge1xuICAgIG5ld0FycltpaV0gPSBhcnJbaWkgKyBvZmZzZXRdO1xuICB9XG4gIHJldHVybiBuZXdBcnI7XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGVycm9yKSB7XG4gIGlmICghY29uZGl0aW9uKSB7IHRocm93IG5ldyBFcnJvcihlcnJvcik7IH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0Tm90SW5maW5pdGUoc2l6ZSkge1xuICBpbnZhcmlhbnQoXG4gICAgc2l6ZSAhPT0gSW5maW5pdHksXG4gICAgJ0Nhbm5vdCBwZXJmb3JtIHRoaXMgYWN0aW9uIHdpdGggYW4gaW5maW5pdGUgc2l6ZS4nXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNvZXJjZUtleVBhdGgoa2V5UGF0aCkge1xuICBpZiAoaXNBcnJheUxpa2Uoa2V5UGF0aCkgJiYgdHlwZW9mIGtleVBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGtleVBhdGg7XG4gIH1cbiAgaWYgKGlzT3JkZXJlZChrZXlQYXRoKSkge1xuICAgIHJldHVybiBrZXlQYXRoLnRvQXJyYXkoKTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdJbnZhbGlkIGtleVBhdGg6IGV4cGVjdGVkIE9yZGVyZWQgQ29sbGVjdGlvbiBvciBBcnJheTogJyArIGtleVBhdGhcbiAgKTtcbn1cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAvLyBUaGUgYmFzZSBwcm90b3R5cGUncyB0b1N0cmluZyBkZWFscyB3aXRoIEFyZ3VtZW50IG9iamVjdHMgYW5kIG5hdGl2ZSBuYW1lc3BhY2VzIGxpa2UgTWF0aFxuICBpZiAoXG4gICAgIXZhbHVlIHx8XG4gICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBPYmplY3RdJ1xuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEl0ZXJhdGl2ZWx5IGdvaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4gaXMgbmVlZGVkIGZvciBjcm9zcy1yZWFsbSBlbnZpcm9ubWVudHMgKGRpZmZlcmluZyBjb250ZXh0cywgaWZyYW1lcywgZXRjKVxuICB2YXIgcGFyZW50UHJvdG8gPSBwcm90bztcbiAgdmFyIG5leHRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIHdoaWxlIChuZXh0UHJvdG8gIT09IG51bGwpIHtcbiAgICBwYXJlbnRQcm90byA9IG5leHRQcm90bztcbiAgICBuZXh0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50UHJvdG8pO1xuICB9XG4gIHJldHVybiBwYXJlbnRQcm90byA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIHBvdGVudGlhbGx5LXBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmUsIGVpdGhlclxuICogcHJvdmlkZWQgYnkgSW1tdXRhYmxlLmpzIG9yIGEgcGxhaW4gQXJyYXkgb3IgT2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0RhdGFTdHJ1Y3R1cmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgKGlzSW1tdXRhYmxlKHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gcXVvdGVTdHJpbmcodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IFN0cmluZyh2YWx1ZSk7XG4gIH0gY2F0Y2ggKF9pZ25vcmVFcnJvcikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzKGNvbGxlY3Rpb24sIGtleSkge1xuICByZXR1cm4gaXNJbW11dGFibGUoY29sbGVjdGlvbilcbiAgICA/IGNvbGxlY3Rpb24uaGFzKGtleSlcbiAgICA6IGlzRGF0YVN0cnVjdHVyZShjb2xsZWN0aW9uKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbGxlY3Rpb24sIGtleSk7XG59XG5cbmZ1bmN0aW9uIGdldChjb2xsZWN0aW9uLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gIHJldHVybiBpc0ltbXV0YWJsZShjb2xsZWN0aW9uKVxuICAgID8gY29sbGVjdGlvbi5nZXQoa2V5LCBub3RTZXRWYWx1ZSlcbiAgICA6ICFoYXMoY29sbGVjdGlvbiwga2V5KVxuICAgID8gbm90U2V0VmFsdWVcbiAgICA6IHR5cGVvZiBjb2xsZWN0aW9uLmdldCA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gY29sbGVjdGlvbi5nZXQoa2V5KVxuICAgIDogY29sbGVjdGlvbltrZXldO1xufVxuXG5mdW5jdGlvbiBzaGFsbG93Q29weShmcm9tKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGZyb20pKSB7XG4gICAgcmV0dXJuIGFyckNvcHkoZnJvbSk7XG4gIH1cbiAgdmFyIHRvID0ge307XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoY29sbGVjdGlvbiwga2V5KSB7XG4gIGlmICghaXNEYXRhU3RydWN0dXJlKGNvbGxlY3Rpb24pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdDYW5ub3QgdXBkYXRlIG5vbi1kYXRhLXN0cnVjdHVyZSB2YWx1ZTogJyArIGNvbGxlY3Rpb25cbiAgICApO1xuICB9XG4gIGlmIChpc0ltbXV0YWJsZShjb2xsZWN0aW9uKSkge1xuICAgIGlmICghY29sbGVjdGlvbi5yZW1vdmUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdDYW5ub3QgdXBkYXRlIGltbXV0YWJsZSB2YWx1ZSB3aXRob3V0IC5yZW1vdmUoKSBtZXRob2Q6ICcgKyBjb2xsZWN0aW9uXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbi5yZW1vdmUoa2V5KTtcbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoY29sbGVjdGlvbiwga2V5KSkge1xuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9XG4gIHZhciBjb2xsZWN0aW9uQ29weSA9IHNoYWxsb3dDb3B5KGNvbGxlY3Rpb24pO1xuICBpZiAoQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uQ29weSkpIHtcbiAgICBjb2xsZWN0aW9uQ29weS5zcGxpY2Uoa2V5LCAxKTtcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgY29sbGVjdGlvbkNvcHlba2V5XTtcbiAgfVxuICByZXR1cm4gY29sbGVjdGlvbkNvcHk7XG59XG5cbmZ1bmN0aW9uIHNldChjb2xsZWN0aW9uLCBrZXksIHZhbHVlKSB7XG4gIGlmICghaXNEYXRhU3RydWN0dXJlKGNvbGxlY3Rpb24pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdDYW5ub3QgdXBkYXRlIG5vbi1kYXRhLXN0cnVjdHVyZSB2YWx1ZTogJyArIGNvbGxlY3Rpb25cbiAgICApO1xuICB9XG4gIGlmIChpc0ltbXV0YWJsZShjb2xsZWN0aW9uKSkge1xuICAgIGlmICghY29sbGVjdGlvbi5zZXQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdDYW5ub3QgdXBkYXRlIGltbXV0YWJsZSB2YWx1ZSB3aXRob3V0IC5zZXQoKSBtZXRob2Q6ICcgKyBjb2xsZWN0aW9uXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbi5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29sbGVjdGlvbiwga2V5KSAmJiB2YWx1ZSA9PT0gY29sbGVjdGlvbltrZXldKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH1cbiAgdmFyIGNvbGxlY3Rpb25Db3B5ID0gc2hhbGxvd0NvcHkoY29sbGVjdGlvbik7XG4gIGNvbGxlY3Rpb25Db3B5W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIGNvbGxlY3Rpb25Db3B5O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJbiQxKGNvbGxlY3Rpb24sIGtleVBhdGgsIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gIGlmICghdXBkYXRlcikge1xuICAgIHVwZGF0ZXIgPSBub3RTZXRWYWx1ZTtcbiAgICBub3RTZXRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgdXBkYXRlZFZhbHVlID0gdXBkYXRlSW5EZWVwbHkoXG4gICAgaXNJbW11dGFibGUoY29sbGVjdGlvbiksXG4gICAgY29sbGVjdGlvbixcbiAgICBjb2VyY2VLZXlQYXRoKGtleVBhdGgpLFxuICAgIDAsXG4gICAgbm90U2V0VmFsdWUsXG4gICAgdXBkYXRlclxuICApO1xuICByZXR1cm4gdXBkYXRlZFZhbHVlID09PSBOT1RfU0VUID8gbm90U2V0VmFsdWUgOiB1cGRhdGVkVmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUluRGVlcGx5KFxuICBpbkltbXV0YWJsZSxcbiAgZXhpc3RpbmcsXG4gIGtleVBhdGgsXG4gIGksXG4gIG5vdFNldFZhbHVlLFxuICB1cGRhdGVyXG4pIHtcbiAgdmFyIHdhc05vdFNldCA9IGV4aXN0aW5nID09PSBOT1RfU0VUO1xuICBpZiAoaSA9PT0ga2V5UGF0aC5sZW5ndGgpIHtcbiAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHdhc05vdFNldCA/IG5vdFNldFZhbHVlIDogZXhpc3Rpbmc7XG4gICAgdmFyIG5ld1ZhbHVlID0gdXBkYXRlcihleGlzdGluZ1ZhbHVlKTtcbiAgICByZXR1cm4gbmV3VmFsdWUgPT09IGV4aXN0aW5nVmFsdWUgPyBleGlzdGluZyA6IG5ld1ZhbHVlO1xuICB9XG4gIGlmICghd2FzTm90U2V0ICYmICFpc0RhdGFTdHJ1Y3R1cmUoZXhpc3RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdDYW5ub3QgdXBkYXRlIHdpdGhpbiBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWUgaW4gcGF0aCBbJyArXG4gICAgICAgIGtleVBhdGguc2xpY2UoMCwgaSkubWFwKHF1b3RlU3RyaW5nKSArXG4gICAgICAgICddOiAnICtcbiAgICAgICAgZXhpc3RpbmdcbiAgICApO1xuICB9XG4gIHZhciBrZXkgPSBrZXlQYXRoW2ldO1xuICB2YXIgbmV4dEV4aXN0aW5nID0gd2FzTm90U2V0ID8gTk9UX1NFVCA6IGdldChleGlzdGluZywga2V5LCBOT1RfU0VUKTtcbiAgdmFyIG5leHRVcGRhdGVkID0gdXBkYXRlSW5EZWVwbHkoXG4gICAgbmV4dEV4aXN0aW5nID09PSBOT1RfU0VUID8gaW5JbW11dGFibGUgOiBpc0ltbXV0YWJsZShuZXh0RXhpc3RpbmcpLFxuICAgIG5leHRFeGlzdGluZyxcbiAgICBrZXlQYXRoLFxuICAgIGkgKyAxLFxuICAgIG5vdFNldFZhbHVlLFxuICAgIHVwZGF0ZXJcbiAgKTtcbiAgcmV0dXJuIG5leHRVcGRhdGVkID09PSBuZXh0RXhpc3RpbmdcbiAgICA/IGV4aXN0aW5nXG4gICAgOiBuZXh0VXBkYXRlZCA9PT0gTk9UX1NFVFxuICAgID8gcmVtb3ZlKGV4aXN0aW5nLCBrZXkpXG4gICAgOiBzZXQoXG4gICAgICAgIHdhc05vdFNldCA/IChpbkltbXV0YWJsZSA/IGVtcHR5TWFwKCkgOiB7fSkgOiBleGlzdGluZyxcbiAgICAgICAga2V5LFxuICAgICAgICBuZXh0VXBkYXRlZFxuICAgICAgKTtcbn1cblxuZnVuY3Rpb24gc2V0SW4kMShjb2xsZWN0aW9uLCBrZXlQYXRoLCB2YWx1ZSkge1xuICByZXR1cm4gdXBkYXRlSW4kMShjb2xsZWN0aW9uLCBrZXlQYXRoLCBOT1RfU0VULCBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZTsgfSk7XG59XG5cbmZ1bmN0aW9uIHNldEluKGtleVBhdGgsIHYpIHtcbiAgcmV0dXJuIHNldEluJDEodGhpcywga2V5UGF0aCwgdik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUluKGNvbGxlY3Rpb24sIGtleVBhdGgpIHtcbiAgcmV0dXJuIHVwZGF0ZUluJDEoY29sbGVjdGlvbiwga2V5UGF0aCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gTk9UX1NFVDsgfSk7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZUluKGtleVBhdGgpIHtcbiAgcmV0dXJuIHJlbW92ZUluKHRoaXMsIGtleVBhdGgpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGUkMShjb2xsZWN0aW9uLCBrZXksIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gIHJldHVybiB1cGRhdGVJbiQxKGNvbGxlY3Rpb24sIFtrZXldLCBub3RTZXRWYWx1ZSwgdXBkYXRlcik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZShrZXksIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgPyBrZXkodGhpcylcbiAgICA6IHVwZGF0ZSQxKHRoaXMsIGtleSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJbihrZXlQYXRoLCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICByZXR1cm4gdXBkYXRlSW4kMSh0aGlzLCBrZXlQYXRoLCBub3RTZXRWYWx1ZSwgdXBkYXRlcik7XG59XG5cbmZ1bmN0aW9uIG1lcmdlJDEoKSB7XG4gIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gbWVyZ2VJbnRvS2V5ZWRXaXRoKHRoaXMsIGl0ZXJzKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VXaXRoJDEobWVyZ2VyKSB7XG4gIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICBpZiAodHlwZW9mIG1lcmdlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWVyZ2VyIGZ1bmN0aW9uOiAnICsgbWVyZ2VyKTtcbiAgfVxuICByZXR1cm4gbWVyZ2VJbnRvS2V5ZWRXaXRoKHRoaXMsIGl0ZXJzLCBtZXJnZXIpO1xufVxuXG5mdW5jdGlvbiBtZXJnZUludG9LZXllZFdpdGgoY29sbGVjdGlvbiwgY29sbGVjdGlvbnMsIG1lcmdlcikge1xuICB2YXIgaXRlcnMgPSBbXTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGNvbGxlY3Rpb25zLmxlbmd0aDsgaWkrKykge1xuICAgIHZhciBjb2xsZWN0aW9uJDEgPSBLZXllZENvbGxlY3Rpb24oY29sbGVjdGlvbnNbaWldKTtcbiAgICBpZiAoY29sbGVjdGlvbiQxLnNpemUgIT09IDApIHtcbiAgICAgIGl0ZXJzLnB1c2goY29sbGVjdGlvbiQxKTtcbiAgICB9XG4gIH1cbiAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9XG4gIGlmIChcbiAgICBjb2xsZWN0aW9uLnRvU2VxKCkuc2l6ZSA9PT0gMCAmJlxuICAgICFjb2xsZWN0aW9uLl9fb3duZXJJRCAmJlxuICAgIGl0ZXJzLmxlbmd0aCA9PT0gMVxuICApIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5jb25zdHJ1Y3RvcihpdGVyc1swXSk7XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3Rpb24ud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgIHZhciBtZXJnZUludG9Db2xsZWN0aW9uID0gbWVyZ2VyXG4gICAgICA/IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgdXBkYXRlJDEoY29sbGVjdGlvbiwga2V5LCBOT1RfU0VULCBmdW5jdGlvbiAob2xkVmFsKSB7IHJldHVybiBvbGRWYWwgPT09IE5PVF9TRVQgPyB2YWx1ZSA6IG1lcmdlcihvbGRWYWwsIHZhbHVlLCBrZXkpOyB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIGNvbGxlY3Rpb24uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIGl0ZXJzW2lpXS5mb3JFYWNoKG1lcmdlSW50b0NvbGxlY3Rpb24pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlKGNvbGxlY3Rpb24pIHtcbiAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICByZXR1cm4gbWVyZ2VXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VXaXRoKG1lcmdlciwgY29sbGVjdGlvbikge1xuICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMiBdO1xuXG4gIHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIG1lcmdlcik7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVlcCQxKGNvbGxlY3Rpb24pIHtcbiAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcyk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVlcFdpdGgkMShtZXJnZXIsIGNvbGxlY3Rpb24pIHtcbiAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDIgXTtcblxuICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VEZWVwV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKSB7XG4gIHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIGRlZXBNZXJnZXJXaXRoKG1lcmdlcikpO1xufVxuXG5mdW5jdGlvbiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIG1lcmdlcikge1xuICBpZiAoIWlzRGF0YVN0cnVjdHVyZShjb2xsZWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnQ2Fubm90IG1lcmdlIGludG8gbm9uLWRhdGEtc3RydWN0dXJlIHZhbHVlOiAnICsgY29sbGVjdGlvblxuICAgICk7XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXJnZXIgPT09ICdmdW5jdGlvbicgJiYgY29sbGVjdGlvbi5tZXJnZVdpdGhcbiAgICAgID8gY29sbGVjdGlvbi5tZXJnZVdpdGguYXBwbHkoY29sbGVjdGlvbiwgWyBtZXJnZXIgXS5jb25jYXQoIHNvdXJjZXMgKSlcbiAgICAgIDogY29sbGVjdGlvbi5tZXJnZVxuICAgICAgPyBjb2xsZWN0aW9uLm1lcmdlLmFwcGx5KGNvbGxlY3Rpb24sIHNvdXJjZXMpXG4gICAgICA6IGNvbGxlY3Rpb24uY29uY2F0LmFwcGx5KGNvbGxlY3Rpb24sIHNvdXJjZXMpO1xuICB9XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKTtcbiAgdmFyIG1lcmdlZCA9IGNvbGxlY3Rpb247XG4gIHZhciBDb2xsZWN0aW9uID0gaXNBcnJheSA/IEluZGV4ZWRDb2xsZWN0aW9uIDogS2V5ZWRDb2xsZWN0aW9uO1xuICB2YXIgbWVyZ2VJdGVtID0gaXNBcnJheVxuICAgID8gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIENvcHkgb24gd3JpdGVcbiAgICAgICAgaWYgKG1lcmdlZCA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICAgIG1lcmdlZCA9IHNoYWxsb3dDb3B5KG1lcmdlZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2VkLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIDogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIGhhc1ZhbCA9IGhhc093blByb3BlcnR5LmNhbGwobWVyZ2VkLCBrZXkpO1xuICAgICAgICB2YXIgbmV4dFZhbCA9XG4gICAgICAgICAgaGFzVmFsICYmIG1lcmdlciA/IG1lcmdlcihtZXJnZWRba2V5XSwgdmFsdWUsIGtleSkgOiB2YWx1ZTtcbiAgICAgICAgaWYgKCFoYXNWYWwgfHwgbmV4dFZhbCAhPT0gbWVyZ2VkW2tleV0pIHtcbiAgICAgICAgICAvLyBDb3B5IG9uIHdyaXRlXG4gICAgICAgICAgaWYgKG1lcmdlZCA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICAgICAgbWVyZ2VkID0gc2hhbGxvd0NvcHkobWVyZ2VkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVyZ2VkW2tleV0gPSBuZXh0VmFsO1xuICAgICAgICB9XG4gICAgICB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICBDb2xsZWN0aW9uKHNvdXJjZXNbaV0pLmZvckVhY2gobWVyZ2VJdGVtKTtcbiAgfVxuICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiBkZWVwTWVyZ2VyV2l0aChtZXJnZXIpIHtcbiAgZnVuY3Rpb24gZGVlcE1lcmdlcihvbGRWYWx1ZSwgbmV3VmFsdWUsIGtleSkge1xuICAgIHJldHVybiBpc0RhdGFTdHJ1Y3R1cmUob2xkVmFsdWUpICYmXG4gICAgICBpc0RhdGFTdHJ1Y3R1cmUobmV3VmFsdWUpICYmXG4gICAgICBhcmVNZXJnZWFibGUob2xkVmFsdWUsIG5ld1ZhbHVlKVxuICAgICAgPyBtZXJnZVdpdGhTb3VyY2VzKG9sZFZhbHVlLCBbbmV3VmFsdWVdLCBkZWVwTWVyZ2VyKVxuICAgICAgOiBtZXJnZXJcbiAgICAgID8gbWVyZ2VyKG9sZFZhbHVlLCBuZXdWYWx1ZSwga2V5KVxuICAgICAgOiBuZXdWYWx1ZTtcbiAgfVxuICByZXR1cm4gZGVlcE1lcmdlcjtcbn1cblxuLyoqXG4gKiBJdCdzIHVuY2xlYXIgd2hhdCB0aGUgZGVzaXJlZCBiZWhhdmlvciBpcyBmb3IgbWVyZ2luZyB0d28gY29sbGVjdGlvbnMgdGhhdFxuICogZmFsbCBpbnRvIHNlcGFyYXRlIGNhdGVnb3JpZXMgYmV0d2VlbiBrZXllZCwgaW5kZXhlZCwgb3Igc2V0LWxpa2UsIHNvIHdlIG9ubHlcbiAqIGNvbnNpZGVyIHRoZW0gbWVyZ2VhYmxlIGlmIHRoZXkgZmFsbCBpbnRvIHRoZSBzYW1lIGNhdGVnb3J5LlxuICovXG5mdW5jdGlvbiBhcmVNZXJnZWFibGUob2xkRGF0YVN0cnVjdHVyZSwgbmV3RGF0YVN0cnVjdHVyZSkge1xuICB2YXIgb2xkU2VxID0gU2VxKG9sZERhdGFTdHJ1Y3R1cmUpO1xuICB2YXIgbmV3U2VxID0gU2VxKG5ld0RhdGFTdHJ1Y3R1cmUpO1xuICAvLyBUaGlzIGxvZ2ljIGFzc3VtZXMgdGhhdCBhIHNlcXVlbmNlIGNhbiBvbmx5IGZhbGwgaW50byBvbmUgb2YgdGhlIHRocmVlXG4gIC8vIGNhdGVnb3JpZXMgbWVudGlvbmVkIGFib3ZlIChzaW5jZSB0aGVyZSdzIG5vIGBpc1NldExpa2UoKWAgbWV0aG9kKS5cbiAgcmV0dXJuIChcbiAgICBpc0luZGV4ZWQob2xkU2VxKSA9PT0gaXNJbmRleGVkKG5ld1NlcSkgJiZcbiAgICBpc0tleWVkKG9sZFNlcSkgPT09IGlzS2V5ZWQobmV3U2VxKVxuICApO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXAoKSB7XG4gIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXModGhpcywgaXRlcnMpO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXBXaXRoKG1lcmdlcikge1xuICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgcmV0dXJuIG1lcmdlRGVlcFdpdGhTb3VyY2VzKHRoaXMsIGl0ZXJzLCBtZXJnZXIpO1xufVxuXG5mdW5jdGlvbiBtZXJnZUluKGtleVBhdGgpIHtcbiAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIHJldHVybiB1cGRhdGVJbiQxKHRoaXMsIGtleVBhdGgsIGVtcHR5TWFwKCksIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKG0sIGl0ZXJzKTsgfSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVlcEluKGtleVBhdGgpIHtcbiAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIHJldHVybiB1cGRhdGVJbiQxKHRoaXMsIGtleVBhdGgsIGVtcHR5TWFwKCksIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyhtLCBpdGVycyk7IH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gd2l0aE11dGF0aW9ucyhmbikge1xuICB2YXIgbXV0YWJsZSA9IHRoaXMuYXNNdXRhYmxlKCk7XG4gIGZuKG11dGFibGUpO1xuICByZXR1cm4gbXV0YWJsZS53YXNBbHRlcmVkKCkgPyBtdXRhYmxlLl9fZW5zdXJlT3duZXIodGhpcy5fX293bmVySUQpIDogdGhpcztcbn1cblxuZnVuY3Rpb24gYXNNdXRhYmxlKCkge1xuICByZXR1cm4gdGhpcy5fX293bmVySUQgPyB0aGlzIDogdGhpcy5fX2Vuc3VyZU93bmVyKG5ldyBPd25lcklEKCkpO1xufVxuXG5mdW5jdGlvbiBhc0ltbXV0YWJsZSgpIHtcbiAgcmV0dXJuIHRoaXMuX19lbnN1cmVPd25lcigpO1xufVxuXG5mdW5jdGlvbiB3YXNBbHRlcmVkKCkge1xuICByZXR1cm4gdGhpcy5fX2FsdGVyZWQ7XG59XG5cbnZhciBNYXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChLZXllZENvbGxlY3Rpb24pIHtcbiAgZnVuY3Rpb24gTWFwKHZhbHVlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsXG4gICAgICA/IGVtcHR5TWFwKClcbiAgICAgIDogaXNNYXAodmFsdWUpICYmICFpc09yZGVyZWQodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IGVtcHR5TWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgdmFyIGl0ZXIgPSBLZXllZENvbGxlY3Rpb24odmFsdWUpO1xuICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBtYXAuc2V0KGssIHYpOyB9KTtcbiAgICAgICAgfSk7XG4gIH1cblxuICBpZiAoIEtleWVkQ29sbGVjdGlvbiApIE1hcC5fX3Byb3RvX18gPSBLZXllZENvbGxlY3Rpb247XG4gIE1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBLZXllZENvbGxlY3Rpb24gJiYgS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICBNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwO1xuXG4gIE1hcC5vZiA9IGZ1bmN0aW9uIG9mICgpIHtcbiAgICB2YXIga2V5VmFsdWVzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGtleVZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgcmV0dXJuIGVtcHR5TWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleVZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBpZiAoaSArIDEgPj0ga2V5VmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2YWx1ZSBmb3Iga2V5OiAnICsga2V5VmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBtYXAuc2V0KGtleVZhbHVlc1tpXSwga2V5VmFsdWVzW2kgKyAxXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdNYXAgeycsICd9Jyk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaywgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdFxuICAgICAgPyB0aGlzLl9yb290LmdldCgwLCB1bmRlZmluZWQsIGssIG5vdFNldFZhbHVlKVxuICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChrLCB2KSB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hcCh0aGlzLCBrLCB2KTtcbiAgfTtcblxuICBNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaykge1xuICAgIHJldHVybiB1cGRhdGVNYXAodGhpcywgaywgTk9UX1NFVCk7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS5kZWxldGVBbGwgPSBmdW5jdGlvbiBkZWxldGVBbGwgKGtleXMpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IENvbGxlY3Rpb24oa2V5cyk7XG5cbiAgICBpZiAoY29sbGVjdGlvbi5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBtYXAucmVtb3ZlKGtleSk7IH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5TWFwKCk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gIE1hcC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIHNvcnQgKGNvbXBhcmF0b3IpIHtcbiAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICByZXR1cm4gT3JkZXJlZE1hcChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbiBzb3J0QnkgKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgIC8vIExhdGUgYmluZGluZ1xuICAgIHJldHVybiBPcmRlcmVkTWFwKHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBtYXAuc2V0KGtleSwgbWFwcGVyLmNhbGwoY29udGV4dCwgdmFsdWUsIGtleSwgdGhpcyQxJDEpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTXV0YWJpbGl0eVxuXG4gIE1hcC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMsIHR5cGUsIHJldmVyc2UpO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgdGhpcy5fcm9vdCAmJlxuICAgICAgdGhpcy5fcm9vdC5pdGVyYXRlKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIHJldHVybiBmbihlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMkMSQxKTtcbiAgICAgIH0sIHJldmVyc2UpO1xuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5TWFwKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlTWFwKHRoaXMuc2l6ZSwgdGhpcy5fcm9vdCwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuICB9O1xuXG4gIHJldHVybiBNYXA7XG59KEtleWVkQ29sbGVjdGlvbikpO1xuXG5NYXAuaXNNYXAgPSBpc01hcDtcblxudmFyIE1hcFByb3RvdHlwZSA9IE1hcC5wcm90b3R5cGU7XG5NYXBQcm90b3R5cGVbSVNfTUFQX1NZTUJPTF0gPSB0cnVlO1xuTWFwUHJvdG90eXBlW0RFTEVURV0gPSBNYXBQcm90b3R5cGUucmVtb3ZlO1xuTWFwUHJvdG90eXBlLnJlbW92ZUFsbCA9IE1hcFByb3RvdHlwZS5kZWxldGVBbGw7XG5NYXBQcm90b3R5cGUuc2V0SW4gPSBzZXRJbjtcbk1hcFByb3RvdHlwZS5yZW1vdmVJbiA9IE1hcFByb3RvdHlwZS5kZWxldGVJbiA9IGRlbGV0ZUluO1xuTWFwUHJvdG90eXBlLnVwZGF0ZSA9IHVwZGF0ZTtcbk1hcFByb3RvdHlwZS51cGRhdGVJbiA9IHVwZGF0ZUluO1xuTWFwUHJvdG90eXBlLm1lcmdlID0gTWFwUHJvdG90eXBlLmNvbmNhdCA9IG1lcmdlJDE7XG5NYXBQcm90b3R5cGUubWVyZ2VXaXRoID0gbWVyZ2VXaXRoJDE7XG5NYXBQcm90b3R5cGUubWVyZ2VEZWVwID0gbWVyZ2VEZWVwO1xuTWFwUHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBtZXJnZURlZXBXaXRoO1xuTWFwUHJvdG90eXBlLm1lcmdlSW4gPSBtZXJnZUluO1xuTWFwUHJvdG90eXBlLm1lcmdlRGVlcEluID0gbWVyZ2VEZWVwSW47XG5NYXBQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IHdpdGhNdXRhdGlvbnM7XG5NYXBQcm90b3R5cGUud2FzQWx0ZXJlZCA9IHdhc0FsdGVyZWQ7XG5NYXBQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcbk1hcFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IE1hcFByb3RvdHlwZS5hc011dGFibGUgPSBhc011dGFibGU7XG5NYXBQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBhcnIpIHtcbiAgcmV0dXJuIHJlc3VsdC5zZXQoYXJyWzBdLCBhcnJbMV0pO1xufTtcbk1hcFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG59O1xuXG4vLyAjcHJhZ21hIFRyaWUgTm9kZXNcblxudmFyIEFycmF5TWFwTm9kZSA9IGZ1bmN0aW9uIEFycmF5TWFwTm9kZShvd25lcklELCBlbnRyaWVzKSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG59O1xuXG5BcnJheU1hcE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gIGZvciAodmFyIGlpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgaWYgKGlzKGtleSwgZW50cmllc1tpaV1bMF0pKSB7XG4gICAgICByZXR1cm4gZW50cmllc1tpaV1bMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBub3RTZXRWYWx1ZTtcbn07XG5cbkFycmF5TWFwTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcblxuICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aDtcbiAgZm9yICg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lkeF1bMF0pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIGV4aXN0cyA9IGlkeCA8IGxlbjtcblxuICBpZiAoZXhpc3RzID8gZW50cmllc1tpZHhdWzFdID09PSB2YWx1ZSA6IHJlbW92ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIFNldFJlZihkaWRBbHRlcik7XG4gIChyZW1vdmVkIHx8ICFleGlzdHMpICYmIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcblxuICBpZiAocmVtb3ZlZCAmJiBlbnRyaWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoIWV4aXN0cyAmJiAhcmVtb3ZlZCAmJiBlbnRyaWVzLmxlbmd0aCA+PSBNQVhfQVJSQVlfTUFQX1NJWkUpIHtcbiAgICByZXR1cm4gY3JlYXRlTm9kZXMob3duZXJJRCwgZW50cmllcywga2V5LCB2YWx1ZSk7XG4gIH1cblxuICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcblxuICBpZiAoZXhpc3RzKSB7XG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIGlkeCA9PT0gbGVuIC0gMVxuICAgICAgICA/IG5ld0VudHJpZXMucG9wKClcbiAgICAgICAgOiAobmV3RW50cmllc1tpZHhdID0gbmV3RW50cmllcy5wb3AoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0VudHJpZXNbaWR4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV3RW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH1cblxuICBpZiAoaXNFZGl0YWJsZSkge1xuICAgIHRoaXMuZW50cmllcyA9IG5ld0VudHJpZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gbmV3IEFycmF5TWFwTm9kZShvd25lcklELCBuZXdFbnRyaWVzKTtcbn07XG5cbnZhciBCaXRtYXBJbmRleGVkTm9kZSA9IGZ1bmN0aW9uIEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIGJpdG1hcCwgbm9kZXMpIHtcbiAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgdGhpcy5iaXRtYXAgPSBiaXRtYXA7XG4gIHRoaXMubm9kZXMgPSBub2Rlcztcbn07XG5cbkJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICB9XG4gIHZhciBiaXQgPSAxIDw8ICgoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSyk7XG4gIHZhciBiaXRtYXAgPSB0aGlzLmJpdG1hcDtcbiAgcmV0dXJuIChiaXRtYXAgJiBiaXQpID09PSAwXG4gICAgPyBub3RTZXRWYWx1ZVxuICAgIDogdGhpcy5ub2Rlc1twb3BDb3VudChiaXRtYXAgJiAoYml0IC0gMSkpXS5nZXQoXG4gICAgICAgIHNoaWZ0ICsgU0hJRlQsXG4gICAgICAgIGtleUhhc2gsXG4gICAgICAgIGtleSxcbiAgICAgICAgbm90U2V0VmFsdWVcbiAgICAgICk7XG59O1xuXG5CaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gIH1cbiAgdmFyIGtleUhhc2hGcmFnID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gIHZhciBiaXQgPSAxIDw8IGtleUhhc2hGcmFnO1xuICB2YXIgYml0bWFwID0gdGhpcy5iaXRtYXA7XG4gIHZhciBleGlzdHMgPSAoYml0bWFwICYgYml0KSAhPT0gMDtcblxuICBpZiAoIWV4aXN0cyAmJiB2YWx1ZSA9PT0gTk9UX1NFVCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGlkeCA9IHBvcENvdW50KGJpdG1hcCAmIChiaXQgLSAxKSk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gIHZhciBub2RlID0gZXhpc3RzID8gbm9kZXNbaWR4XSA6IHVuZGVmaW5lZDtcbiAgdmFyIG5ld05vZGUgPSB1cGRhdGVOb2RlKFxuICAgIG5vZGUsXG4gICAgb3duZXJJRCxcbiAgICBzaGlmdCArIFNISUZULFxuICAgIGtleUhhc2gsXG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIGRpZENoYW5nZVNpemUsXG4gICAgZGlkQWx0ZXJcbiAgKTtcblxuICBpZiAobmV3Tm9kZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKCFleGlzdHMgJiYgbmV3Tm9kZSAmJiBub2Rlcy5sZW5ndGggPj0gTUFYX0JJVE1BUF9JTkRFWEVEX1NJWkUpIHtcbiAgICByZXR1cm4gZXhwYW5kTm9kZXMob3duZXJJRCwgbm9kZXMsIGJpdG1hcCwga2V5SGFzaEZyYWcsIG5ld05vZGUpO1xuICB9XG5cbiAgaWYgKFxuICAgIGV4aXN0cyAmJlxuICAgICFuZXdOb2RlICYmXG4gICAgbm9kZXMubGVuZ3RoID09PSAyICYmXG4gICAgaXNMZWFmTm9kZShub2Rlc1tpZHggXiAxXSlcbiAgKSB7XG4gICAgcmV0dXJuIG5vZGVzW2lkeCBeIDFdO1xuICB9XG5cbiAgaWYgKGV4aXN0cyAmJiBuZXdOb2RlICYmIG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBpc0xlYWZOb2RlKG5ld05vZGUpKSB7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICB2YXIgbmV3Qml0bWFwID0gZXhpc3RzID8gKG5ld05vZGUgPyBiaXRtYXAgOiBiaXRtYXAgXiBiaXQpIDogYml0bWFwIHwgYml0O1xuICB2YXIgbmV3Tm9kZXMgPSBleGlzdHNcbiAgICA/IG5ld05vZGVcbiAgICAgID8gc2V0QXQobm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSlcbiAgICAgIDogc3BsaWNlT3V0KG5vZGVzLCBpZHgsIGlzRWRpdGFibGUpXG4gICAgOiBzcGxpY2VJbihub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKTtcblxuICBpZiAoaXNFZGl0YWJsZSkge1xuICAgIHRoaXMuYml0bWFwID0gbmV3Qml0bWFwO1xuICAgIHRoaXMubm9kZXMgPSBuZXdOb2RlcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgbmV3Qml0bWFwLCBuZXdOb2Rlcyk7XG59O1xuXG52YXIgSGFzaEFycmF5TWFwTm9kZSA9IGZ1bmN0aW9uIEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgY291bnQsIG5vZGVzKSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMuY291bnQgPSBjb3VudDtcbiAgdGhpcy5ub2RlcyA9IG5vZGVzO1xufTtcblxuSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgfVxuICB2YXIgaWR4ID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gIHZhciBub2RlID0gdGhpcy5ub2Rlc1tpZHhdO1xuICByZXR1cm4gbm9kZVxuICAgID8gbm9kZS5nZXQoc2hpZnQgKyBTSElGVCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSlcbiAgICA6IG5vdFNldFZhbHVlO1xufTtcblxuSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gIH1cbiAgdmFyIGlkeCA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICB2YXIgbm9kZSA9IG5vZGVzW2lkeF07XG5cbiAgaWYgKHJlbW92ZWQgJiYgIW5vZGUpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBuZXdOb2RlID0gdXBkYXRlTm9kZShcbiAgICBub2RlLFxuICAgIG93bmVySUQsXG4gICAgc2hpZnQgKyBTSElGVCxcbiAgICBrZXlIYXNoLFxuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICBkaWRDaGFuZ2VTaXplLFxuICAgIGRpZEFsdGVyXG4gICk7XG4gIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbmV3Q291bnQgPSB0aGlzLmNvdW50O1xuICBpZiAoIW5vZGUpIHtcbiAgICBuZXdDb3VudCsrO1xuICB9IGVsc2UgaWYgKCFuZXdOb2RlKSB7XG4gICAgbmV3Q291bnQtLTtcbiAgICBpZiAobmV3Q291bnQgPCBNSU5fSEFTSF9BUlJBWV9NQVBfU0laRSkge1xuICAgICAgcmV0dXJuIHBhY2tOb2Rlcyhvd25lcklELCBub2RlcywgbmV3Q291bnQsIGlkeCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgdmFyIG5ld05vZGVzID0gc2V0QXQobm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSk7XG5cbiAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICB0aGlzLmNvdW50ID0gbmV3Q291bnQ7XG4gICAgdGhpcy5ub2RlcyA9IG5ld05vZGVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBIYXNoQXJyYXlNYXBOb2RlKG93bmVySUQsIG5ld0NvdW50LCBuZXdOb2Rlcyk7XG59O1xuXG52YXIgSGFzaENvbGxpc2lvbk5vZGUgPSBmdW5jdGlvbiBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyaWVzKSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG4gIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG59O1xuXG5IYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgZm9yICh2YXIgaWkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcbiAgICAgIHJldHVybiBlbnRyaWVzW2lpXVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vdFNldFZhbHVlO1xufTtcblxuSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICB9XG5cbiAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcblxuICBpZiAoa2V5SGFzaCAhPT0gdGhpcy5rZXlIYXNoKSB7XG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICByZXR1cm4gbWVyZ2VJbnRvTm9kZSh0aGlzLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgfVxuXG4gIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoO1xuICBmb3IgKDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWR4XVswXSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgZXhpc3RzID0gaWR4IDwgbGVuO1xuXG4gIGlmIChleGlzdHMgPyBlbnRyaWVzW2lkeF1bMV0gPT09IHZhbHVlIDogcmVtb3ZlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgKHJlbW92ZWQgfHwgIWV4aXN0cykgJiYgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuXG4gIGlmIChyZW1vdmVkICYmIGxlbiA9PT0gMikge1xuICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgZW50cmllc1tpZHggXiAxXSk7XG4gIH1cblxuICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcblxuICBpZiAoZXhpc3RzKSB7XG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIGlkeCA9PT0gbGVuIC0gMVxuICAgICAgICA/IG5ld0VudHJpZXMucG9wKClcbiAgICAgICAgOiAobmV3RW50cmllc1tpZHhdID0gbmV3RW50cmllcy5wb3AoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0VudHJpZXNbaWR4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV3RW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH1cblxuICBpZiAoaXNFZGl0YWJsZSkge1xuICAgIHRoaXMuZW50cmllcyA9IG5ld0VudHJpZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gbmV3IEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgbmV3RW50cmllcyk7XG59O1xuXG52YXIgVmFsdWVOb2RlID0gZnVuY3Rpb24gVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJ5KSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG4gIHRoaXMuZW50cnkgPSBlbnRyeTtcbn07XG5cblZhbHVlTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICByZXR1cm4gaXMoa2V5LCB0aGlzLmVudHJ5WzBdKSA/IHRoaXMuZW50cnlbMV0gOiBub3RTZXRWYWx1ZTtcbn07XG5cblZhbHVlTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcbiAgdmFyIGtleU1hdGNoID0gaXMoa2V5LCB0aGlzLmVudHJ5WzBdKTtcbiAgaWYgKGtleU1hdGNoID8gdmFsdWUgPT09IHRoaXMuZW50cnlbMV0gOiByZW1vdmVkKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBTZXRSZWYoZGlkQWx0ZXIpO1xuXG4gIGlmIChyZW1vdmVkKSB7XG4gICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gIH1cblxuICBpZiAoa2V5TWF0Y2gpIHtcbiAgICBpZiAob3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQpIHtcbiAgICAgIHRoaXMuZW50cnlbMV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gIH1cblxuICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gIHJldHVybiBtZXJnZUludG9Ob2RlKHRoaXMsIG93bmVySUQsIHNoaWZ0LCBoYXNoKGtleSksIFtrZXksIHZhbHVlXSk7XG59O1xuXG4vLyAjcHJhZ21hIEl0ZXJhdG9yc1xuXG5BcnJheU1hcE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBIYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9XG4gIGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgIGZvciAodmFyIGlpID0gMCwgbWF4SW5kZXggPSBlbnRyaWVzLmxlbmd0aCAtIDE7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICBpZiAoZm4oZW50cmllc1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbkJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9XG4gIGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBtYXhJbmRleCA9IG5vZGVzLmxlbmd0aCAtIDE7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldO1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5pdGVyYXRlKGZuLCByZXZlcnNlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5WYWx1ZU5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgcmV0dXJuIGZuKHRoaXMuZW50cnkpO1xufTtcblxudmFyIE1hcEl0ZXJhdG9yID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSXRlcmF0b3IpIHtcbiAgZnVuY3Rpb24gTWFwSXRlcmF0b3IobWFwLCB0eXBlLCByZXZlcnNlKSB7XG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fcmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgdGhpcy5fc3RhY2sgPSBtYXAuX3Jvb3QgJiYgbWFwSXRlcmF0b3JGcmFtZShtYXAuX3Jvb3QpO1xuICB9XG5cbiAgaWYgKCBJdGVyYXRvciApIE1hcEl0ZXJhdG9yLl9fcHJvdG9fXyA9IEl0ZXJhdG9yO1xuICBNYXBJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJdGVyYXRvciAmJiBJdGVyYXRvci5wcm90b3R5cGUgKTtcbiAgTWFwSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwSXRlcmF0b3I7XG5cbiAgTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG4gICAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2s7XG4gICAgd2hpbGUgKHN0YWNrKSB7XG4gICAgICB2YXIgbm9kZSA9IHN0YWNrLm5vZGU7XG4gICAgICB2YXIgaW5kZXggPSBzdGFjay5pbmRleCsrO1xuICAgICAgdmFyIG1heEluZGV4ID0gKHZvaWQgMCk7XG4gICAgICBpZiAobm9kZS5lbnRyeSkge1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBub2RlLmVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmVudHJpZXMpIHtcbiAgICAgICAgbWF4SW5kZXggPSBub2RlLmVudHJpZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbm9kZS5lbnRyaWVzW3RoaXMuX3JldmVyc2UgPyBtYXhJbmRleCAtIGluZGV4IDogaW5kZXhdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4SW5kZXggPSBub2RlLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICAgIHZhciBzdWJOb2RlID0gbm9kZS5ub2Rlc1t0aGlzLl9yZXZlcnNlID8gbWF4SW5kZXggLSBpbmRleCA6IGluZGV4XTtcbiAgICAgICAgICBpZiAoc3ViTm9kZSkge1xuICAgICAgICAgICAgaWYgKHN1Yk5vZGUuZW50cnkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgc3ViTm9kZS5lbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gbWFwSXRlcmF0b3JGcmFtZShzdWJOb2RlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gdGhpcy5fc3RhY2suX19wcmV2O1xuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gIH07XG5cbiAgcmV0dXJuIE1hcEl0ZXJhdG9yO1xufShJdGVyYXRvcikpO1xuXG5mdW5jdGlvbiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5KSB7XG4gIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5WzBdLCBlbnRyeVsxXSk7XG59XG5cbmZ1bmN0aW9uIG1hcEl0ZXJhdG9yRnJhbWUobm9kZSwgcHJldikge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IG5vZGUsXG4gICAgaW5kZXg6IDAsXG4gICAgX19wcmV2OiBwcmV2LFxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlTWFwKHNpemUsIHJvb3QsIG93bmVySUQsIGhhc2gpIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUoTWFwUHJvdG90eXBlKTtcbiAgbWFwLnNpemUgPSBzaXplO1xuICBtYXAuX3Jvb3QgPSByb290O1xuICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgbWFwLl9faGFzaCA9IGhhc2g7XG4gIG1hcC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIEVNUFRZX01BUDtcbmZ1bmN0aW9uIGVtcHR5TWFwKCkge1xuICByZXR1cm4gRU1QVFlfTUFQIHx8IChFTVBUWV9NQVAgPSBtYWtlTWFwKDApKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWFwKG1hcCwgaywgdikge1xuICB2YXIgbmV3Um9vdDtcbiAgdmFyIG5ld1NpemU7XG4gIGlmICghbWFwLl9yb290KSB7XG4gICAgaWYgKHYgPT09IE5PVF9TRVQpIHtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIG5ld1NpemUgPSAxO1xuICAgIG5ld1Jvb3QgPSBuZXcgQXJyYXlNYXBOb2RlKG1hcC5fX293bmVySUQsIFtbaywgdl1dKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlkQ2hhbmdlU2l6ZSA9IE1ha2VSZWYoKTtcbiAgICB2YXIgZGlkQWx0ZXIgPSBNYWtlUmVmKCk7XG4gICAgbmV3Um9vdCA9IHVwZGF0ZU5vZGUoXG4gICAgICBtYXAuX3Jvb3QsXG4gICAgICBtYXAuX19vd25lcklELFxuICAgICAgMCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIGssXG4gICAgICB2LFxuICAgICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICAgIGRpZEFsdGVyXG4gICAgKTtcbiAgICBpZiAoIWRpZEFsdGVyLnZhbHVlKSB7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBuZXdTaXplID0gbWFwLnNpemUgKyAoZGlkQ2hhbmdlU2l6ZS52YWx1ZSA/ICh2ID09PSBOT1RfU0VUID8gLTEgOiAxKSA6IDApO1xuICB9XG4gIGlmIChtYXAuX19vd25lcklEKSB7XG4gICAgbWFwLnNpemUgPSBuZXdTaXplO1xuICAgIG1hcC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgbWFwLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICBtYXAuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIHJldHVybiBuZXdSb290ID8gbWFrZU1hcChuZXdTaXplLCBuZXdSb290KSA6IGVtcHR5TWFwKCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5vZGUoXG4gIG5vZGUsXG4gIG93bmVySUQsXG4gIHNoaWZ0LFxuICBrZXlIYXNoLFxuICBrZXksXG4gIHZhbHVlLFxuICBkaWRDaGFuZ2VTaXplLFxuICBkaWRBbHRlclxuKSB7XG4gIGlmICghbm9kZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gTk9UX1NFVCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gIH1cbiAgcmV0dXJuIG5vZGUudXBkYXRlKFxuICAgIG93bmVySUQsXG4gICAgc2hpZnQsXG4gICAga2V5SGFzaCxcbiAgICBrZXksXG4gICAgdmFsdWUsXG4gICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICBkaWRBbHRlclxuICApO1xufVxuXG5mdW5jdGlvbiBpc0xlYWZOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICBub2RlLmNvbnN0cnVjdG9yID09PSBWYWx1ZU5vZGUgfHwgbm9kZS5jb25zdHJ1Y3RvciA9PT0gSGFzaENvbGxpc2lvbk5vZGVcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VJbnRvTm9kZShub2RlLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwgZW50cnkpIHtcbiAgaWYgKG5vZGUua2V5SGFzaCA9PT0ga2V5SGFzaCkge1xuICAgIHJldHVybiBuZXcgSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwga2V5SGFzaCwgW25vZGUuZW50cnksIGVudHJ5XSk7XG4gIH1cblxuICB2YXIgaWR4MSA9IChzaGlmdCA9PT0gMCA/IG5vZGUua2V5SGFzaCA6IG5vZGUua2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgdmFyIGlkeDIgPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcblxuICB2YXIgbmV3Tm9kZTtcbiAgdmFyIG5vZGVzID1cbiAgICBpZHgxID09PSBpZHgyXG4gICAgICA/IFttZXJnZUludG9Ob2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGVudHJ5KV1cbiAgICAgIDogKChuZXdOb2RlID0gbmV3IFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyeSkpLFxuICAgICAgICBpZHgxIDwgaWR4MiA/IFtub2RlLCBuZXdOb2RlXSA6IFtuZXdOb2RlLCBub2RlXSk7XG5cbiAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCAoMSA8PCBpZHgxKSB8ICgxIDw8IGlkeDIpLCBub2Rlcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzKG93bmVySUQsIGVudHJpZXMsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCFvd25lcklEKSB7XG4gICAgb3duZXJJRCA9IG5ldyBPd25lcklEKCk7XG4gIH1cbiAgdmFyIG5vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGhhc2goa2V5KSwgW2tleSwgdmFsdWVdKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGVudHJpZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpaV07XG4gICAgbm9kZSA9IG5vZGUudXBkYXRlKG93bmVySUQsIDAsIHVuZGVmaW5lZCwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gcGFja05vZGVzKG93bmVySUQsIG5vZGVzLCBjb3VudCwgZXhjbHVkaW5nKSB7XG4gIHZhciBiaXRtYXAgPSAwO1xuICB2YXIgcGFja2VkSUkgPSAwO1xuICB2YXIgcGFja2VkTm9kZXMgPSBuZXcgQXJyYXkoY291bnQpO1xuICBmb3IgKHZhciBpaSA9IDAsIGJpdCA9IDEsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyssIGJpdCA8PD0gMSkge1xuICAgIHZhciBub2RlID0gbm9kZXNbaWldO1xuICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgaWkgIT09IGV4Y2x1ZGluZykge1xuICAgICAgYml0bWFwIHw9IGJpdDtcbiAgICAgIHBhY2tlZE5vZGVzW3BhY2tlZElJKytdID0gbm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIHBhY2tlZE5vZGVzKTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kTm9kZXMob3duZXJJRCwgbm9kZXMsIGJpdG1hcCwgaW5jbHVkaW5nLCBub2RlKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBleHBhbmRlZE5vZGVzID0gbmV3IEFycmF5KFNJWkUpO1xuICBmb3IgKHZhciBpaSA9IDA7IGJpdG1hcCAhPT0gMDsgaWkrKywgYml0bWFwID4+Pj0gMSkge1xuICAgIGV4cGFuZGVkTm9kZXNbaWldID0gYml0bWFwICYgMSA/IG5vZGVzW2NvdW50KytdIDogdW5kZWZpbmVkO1xuICB9XG4gIGV4cGFuZGVkTm9kZXNbaW5jbHVkaW5nXSA9IG5vZGU7XG4gIHJldHVybiBuZXcgSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBjb3VudCArIDEsIGV4cGFuZGVkTm9kZXMpO1xufVxuXG5mdW5jdGlvbiBwb3BDb3VudCh4KSB7XG4gIHggLT0gKHggPj4gMSkgJiAweDU1NTU1NTU1O1xuICB4ID0gKHggJiAweDMzMzMzMzMzKSArICgoeCA+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICB4ID0gKHggKyAoeCA+PiA0KSkgJiAweDBmMGYwZjBmO1xuICB4ICs9IHggPj4gODtcbiAgeCArPSB4ID4+IDE2O1xuICByZXR1cm4geCAmIDB4N2Y7XG59XG5cbmZ1bmN0aW9uIHNldEF0KGFycmF5LCBpZHgsIHZhbCwgY2FuRWRpdCkge1xuICB2YXIgbmV3QXJyYXkgPSBjYW5FZGl0ID8gYXJyYXkgOiBhcnJDb3B5KGFycmF5KTtcbiAgbmV3QXJyYXlbaWR4XSA9IHZhbDtcbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VJbihhcnJheSwgaWR4LCB2YWwsIGNhbkVkaXQpIHtcbiAgdmFyIG5ld0xlbiA9IGFycmF5Lmxlbmd0aCArIDE7XG4gIGlmIChjYW5FZGl0ICYmIGlkeCArIDEgPT09IG5ld0xlbikge1xuICAgIGFycmF5W2lkeF0gPSB2YWw7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdMZW4pO1xuICB2YXIgYWZ0ZXIgPSAwO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmV3TGVuOyBpaSsrKSB7XG4gICAgaWYgKGlpID09PSBpZHgpIHtcbiAgICAgIG5ld0FycmF5W2lpXSA9IHZhbDtcbiAgICAgIGFmdGVyID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0FycmF5W2lpXSA9IGFycmF5W2lpICsgYWZ0ZXJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU91dChhcnJheSwgaWR4LCBjYW5FZGl0KSB7XG4gIHZhciBuZXdMZW4gPSBhcnJheS5sZW5ndGggLSAxO1xuICBpZiAoY2FuRWRpdCAmJiBpZHggPT09IG5ld0xlbikge1xuICAgIGFycmF5LnBvcCgpO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgdmFyIGFmdGVyID0gMDtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5ld0xlbjsgaWkrKykge1xuICAgIGlmIChpaSA9PT0gaWR4KSB7XG4gICAgICBhZnRlciA9IDE7XG4gICAgfVxuICAgIG5ld0FycmF5W2lpXSA9IGFycmF5W2lpICsgYWZ0ZXJdO1xuICB9XG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxudmFyIE1BWF9BUlJBWV9NQVBfU0laRSA9IFNJWkUgLyA0O1xudmFyIE1BWF9CSVRNQVBfSU5ERVhFRF9TSVpFID0gU0laRSAvIDI7XG52YXIgTUlOX0hBU0hfQVJSQVlfTUFQX1NJWkUgPSBTSVpFIC8gNDtcblxudmFyIElTX0xJU1RfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfTElTVF9fQEAnO1xuXG5mdW5jdGlvbiBpc0xpc3QobWF5YmVMaXN0KSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlTGlzdCAmJiBtYXliZUxpc3RbSVNfTElTVF9TWU1CT0xdKTtcbn1cblxudmFyIExpc3QgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkQ29sbGVjdGlvbikge1xuICBmdW5jdGlvbiBMaXN0KHZhbHVlKSB7XG4gICAgdmFyIGVtcHR5ID0gZW1wdHlMaXN0KCk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG4gICAgaWYgKGlzTGlzdCh2YWx1ZSkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdmFyIGl0ZXIgPSBJbmRleGVkQ29sbGVjdGlvbih2YWx1ZSk7XG4gICAgdmFyIHNpemUgPSBpdGVyLnNpemU7XG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUoc2l6ZSk7XG4gICAgaWYgKHNpemUgPiAwICYmIHNpemUgPCBTSVpFKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gICAgICByZXR1cm4gbWFrZUxpc3QoMCwgc2l6ZSwgU0hJRlQsIG51bGwsIG5ldyBWTm9kZShpdGVyLnRvQXJyYXkoKSkpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gICAgcmV0dXJuIGVtcHR5LndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgIGxpc3Quc2V0U2l6ZShzaXplKTtcbiAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gbGlzdC5zZXQoaSwgdik7IH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCBJbmRleGVkQ29sbGVjdGlvbiApIExpc3QuX19wcm90b19fID0gSW5kZXhlZENvbGxlY3Rpb247XG4gIExpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZENvbGxlY3Rpb24gJiYgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gIExpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGlzdDtcblxuICBMaXN0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ0xpc3QgWycsICddJyk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICBMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuc2l6ZSkge1xuICAgICAgaW5kZXggKz0gdGhpcy5fb3JpZ2luO1xuICAgICAgdmFyIG5vZGUgPSBsaXN0Tm9kZUZvcih0aGlzLCBpbmRleCk7XG4gICAgICByZXR1cm4gbm9kZSAmJiBub2RlLmFycmF5W2luZGV4ICYgTUFTS107XG4gICAgfVxuICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gIExpc3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZUxpc3QodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGluZGV4KSB7XG4gICAgcmV0dXJuICF0aGlzLmhhcyhpbmRleClcbiAgICAgID8gdGhpc1xuICAgICAgOiBpbmRleCA9PT0gMFxuICAgICAgPyB0aGlzLnNoaWZ0KClcbiAgICAgIDogaW5kZXggPT09IHRoaXMuc2l6ZSAtIDFcbiAgICAgID8gdGhpcy5wb3AoKVxuICAgICAgOiB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0IChpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLnNpemUgPSB0aGlzLl9vcmlnaW4gPSB0aGlzLl9jYXBhY2l0eSA9IDA7XG4gICAgICB0aGlzLl9sZXZlbCA9IFNISUZUO1xuICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX3RhaWwgPSB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gZW1wdHlMaXN0KCk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKC8qLi4udmFsdWVzKi8pIHtcbiAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgIHZhciBvbGRTaXplID0gdGhpcy5zaXplO1xuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgMCwgb2xkU2l6ZSArIHZhbHVlcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZhbHVlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgbGlzdC5zZXQob2xkU2l6ZSArIGlpLCB2YWx1ZXNbaWldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiBwb3AgKCkge1xuICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDAsIC0xKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCAoLyouLi52YWx1ZXMqLykge1xuICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCAtdmFsdWVzLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmFsdWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBsaXN0LnNldChpaSwgdmFsdWVzW2lpXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCAoKSB7XG4gICAgcmV0dXJuIHNldExpc3RCb3VuZHModGhpcywgMSk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gIExpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAoLyouLi5jb2xsZWN0aW9ucyovKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIHNlcXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFyZ3VtZW50ID0gYXJndW1lbnRzJDFbaV07XG4gICAgICB2YXIgc2VxID0gSW5kZXhlZENvbGxlY3Rpb24oXG4gICAgICAgIHR5cGVvZiBhcmd1bWVudCAhPT0gJ3N0cmluZycgJiYgaGFzSXRlcmF0b3IoYXJndW1lbnQpXG4gICAgICAgICAgPyBhcmd1bWVudFxuICAgICAgICAgIDogW2FyZ3VtZW50XVxuICAgICAgKTtcbiAgICAgIGlmIChzZXEuc2l6ZSAhPT0gMCkge1xuICAgICAgICBzZXFzLnB1c2goc2VxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlcXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCAmJiAhdGhpcy5fX293bmVySUQgJiYgc2Vxcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHNlcXNbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICBzZXFzLmZvckVhY2goZnVuY3Rpb24gKHNlcSkgeyByZXR1cm4gc2VxLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBsaXN0LnB1c2godmFsdWUpOyB9KTsgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUgKHNpemUpIHtcbiAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAwLCBzaXplKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMkMSQxLnNpemU7IGkrKykge1xuICAgICAgICBsaXN0LnNldChpLCBtYXBwZXIuY2FsbChjb250ZXh0LCBsaXN0LmdldChpKSwgaSwgdGhpcyQxJDEpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIEl0ZXJhdGlvblxuXG4gIExpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKFxuICAgICAgdGhpcyxcbiAgICAgIHJlc29sdmVCZWdpbihiZWdpbiwgc2l6ZSksXG4gICAgICByZXNvbHZlRW5kKGVuZCwgc2l6ZSlcbiAgICApO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGluZGV4ID0gcmV2ZXJzZSA/IHRoaXMuc2l6ZSA6IDA7XG4gICAgdmFyIHZhbHVlcyA9IGl0ZXJhdGVMaXN0KHRoaXMsIHJldmVyc2UpO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzKCk7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IERPTkVcbiAgICAgICAgPyBpdGVyYXRvckRvbmUoKVxuICAgICAgICA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgcmV2ZXJzZSA/IC0taW5kZXggOiBpbmRleCsrLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBpbmRleCA9IHJldmVyc2UgPyB0aGlzLnNpemUgOiAwO1xuICAgIHZhciB2YWx1ZXMgPSBpdGVyYXRlTGlzdCh0aGlzLCByZXZlcnNlKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgd2hpbGUgKCh2YWx1ZSA9IHZhbHVlcygpKSAhPT0gRE9ORSkge1xuICAgICAgaWYgKGZuKHZhbHVlLCByZXZlcnNlID8gLS1pbmRleCA6IGluZGV4KyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eUxpc3QoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VMaXN0KFxuICAgICAgdGhpcy5fb3JpZ2luLFxuICAgICAgdGhpcy5fY2FwYWNpdHksXG4gICAgICB0aGlzLl9sZXZlbCxcbiAgICAgIHRoaXMuX3Jvb3QsXG4gICAgICB0aGlzLl90YWlsLFxuICAgICAgb3duZXJJRCxcbiAgICAgIHRoaXMuX19oYXNoXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gTGlzdDtcbn0oSW5kZXhlZENvbGxlY3Rpb24pKTtcblxuTGlzdC5pc0xpc3QgPSBpc0xpc3Q7XG5cbnZhciBMaXN0UHJvdG90eXBlID0gTGlzdC5wcm90b3R5cGU7XG5MaXN0UHJvdG90eXBlW0lTX0xJU1RfU1lNQk9MXSA9IHRydWU7XG5MaXN0UHJvdG90eXBlW0RFTEVURV0gPSBMaXN0UHJvdG90eXBlLnJlbW92ZTtcbkxpc3RQcm90b3R5cGUubWVyZ2UgPSBMaXN0UHJvdG90eXBlLmNvbmNhdDtcbkxpc3RQcm90b3R5cGUuc2V0SW4gPSBzZXRJbjtcbkxpc3RQcm90b3R5cGUuZGVsZXRlSW4gPSBMaXN0UHJvdG90eXBlLnJlbW92ZUluID0gZGVsZXRlSW47XG5MaXN0UHJvdG90eXBlLnVwZGF0ZSA9IHVwZGF0ZTtcbkxpc3RQcm90b3R5cGUudXBkYXRlSW4gPSB1cGRhdGVJbjtcbkxpc3RQcm90b3R5cGUubWVyZ2VJbiA9IG1lcmdlSW47XG5MaXN0UHJvdG90eXBlLm1lcmdlRGVlcEluID0gbWVyZ2VEZWVwSW47XG5MaXN0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuTGlzdFByb3RvdHlwZS53YXNBbHRlcmVkID0gd2FzQWx0ZXJlZDtcbkxpc3RQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcbkxpc3RQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBMaXN0UHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcbkxpc3RQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBhcnIpIHtcbiAgcmV0dXJuIHJlc3VsdC5wdXNoKGFycik7XG59O1xuTGlzdFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG59O1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZShhcnJheSwgb3duZXJJRCkge1xuICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG59O1xuXG4vLyBUT0RPOiBzZWVtcyBsaWtlIHRoZXNlIG1ldGhvZHMgYXJlIHZlcnkgc2ltaWxhclxuXG5WTm9kZS5wcm90b3R5cGUucmVtb3ZlQmVmb3JlID0gZnVuY3Rpb24gcmVtb3ZlQmVmb3JlIChvd25lcklELCBsZXZlbCwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSBsZXZlbCA/IDEgPDwgbGV2ZWwgOiB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBvcmlnaW5JbmRleCA9IChpbmRleCA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgaWYgKG9yaWdpbkluZGV4ID49IHRoaXMuYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShbXSwgb3duZXJJRCk7XG4gIH1cbiAgdmFyIHJlbW92aW5nRmlyc3QgPSBvcmlnaW5JbmRleCA9PT0gMDtcbiAgdmFyIG5ld0NoaWxkO1xuICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgdmFyIG9sZENoaWxkID0gdGhpcy5hcnJheVtvcmlnaW5JbmRleF07XG4gICAgbmV3Q2hpbGQgPVxuICAgICAgb2xkQ2hpbGQgJiYgb2xkQ2hpbGQucmVtb3ZlQmVmb3JlKG93bmVySUQsIGxldmVsIC0gU0hJRlQsIGluZGV4KTtcbiAgICBpZiAobmV3Q2hpbGQgPT09IG9sZENoaWxkICYmIHJlbW92aW5nRmlyc3QpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZpbmdGaXJzdCAmJiAhbmV3Q2hpbGQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YXIgZWRpdGFibGUgPSBlZGl0YWJsZVZOb2RlKHRoaXMsIG93bmVySUQpO1xuICBpZiAoIXJlbW92aW5nRmlyc3QpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgb3JpZ2luSW5kZXg7IGlpKyspIHtcbiAgICAgIGVkaXRhYmxlLmFycmF5W2lpXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgaWYgKG5ld0NoaWxkKSB7XG4gICAgZWRpdGFibGUuYXJyYXlbb3JpZ2luSW5kZXhdID0gbmV3Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIGVkaXRhYmxlO1xufTtcblxuVk5vZGUucHJvdG90eXBlLnJlbW92ZUFmdGVyID0gZnVuY3Rpb24gcmVtb3ZlQWZ0ZXIgKG93bmVySUQsIGxldmVsLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IChsZXZlbCA/IDEgPDwgbGV2ZWwgOiAwKSB8fCB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBzaXplSW5kZXggPSAoKGluZGV4IC0gMSkgPj4+IGxldmVsKSAmIE1BU0s7XG4gIGlmIChzaXplSW5kZXggPj0gdGhpcy5hcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBuZXdDaGlsZDtcbiAgaWYgKGxldmVsID4gMCkge1xuICAgIHZhciBvbGRDaGlsZCA9IHRoaXMuYXJyYXlbc2l6ZUluZGV4XTtcbiAgICBuZXdDaGlsZCA9XG4gICAgICBvbGRDaGlsZCAmJiBvbGRDaGlsZC5yZW1vdmVBZnRlcihvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCk7XG4gICAgaWYgKG5ld0NoaWxkID09PSBvbGRDaGlsZCAmJiBzaXplSW5kZXggPT09IHRoaXMuYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVkaXRhYmxlID0gZWRpdGFibGVWTm9kZSh0aGlzLCBvd25lcklEKTtcbiAgZWRpdGFibGUuYXJyYXkuc3BsaWNlKHNpemVJbmRleCArIDEpO1xuICBpZiAobmV3Q2hpbGQpIHtcbiAgICBlZGl0YWJsZS5hcnJheVtzaXplSW5kZXhdID0gbmV3Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIGVkaXRhYmxlO1xufTtcblxudmFyIERPTkUgPSB7fTtcblxuZnVuY3Rpb24gaXRlcmF0ZUxpc3QobGlzdCwgcmV2ZXJzZSkge1xuICB2YXIgbGVmdCA9IGxpc3QuX29yaWdpbjtcbiAgdmFyIHJpZ2h0ID0gbGlzdC5fY2FwYWNpdHk7XG4gIHZhciB0YWlsUG9zID0gZ2V0VGFpbE9mZnNldChyaWdodCk7XG4gIHZhciB0YWlsID0gbGlzdC5fdGFpbDtcblxuICByZXR1cm4gaXRlcmF0ZU5vZGVPckxlYWYobGlzdC5fcm9vdCwgbGlzdC5fbGV2ZWwsIDApO1xuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVOb2RlT3JMZWFmKG5vZGUsIGxldmVsLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gbGV2ZWwgPT09IDBcbiAgICAgID8gaXRlcmF0ZUxlYWYobm9kZSwgb2Zmc2V0KVxuICAgICAgOiBpdGVyYXRlTm9kZShub2RlLCBsZXZlbCwgb2Zmc2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVMZWFmKG5vZGUsIG9mZnNldCkge1xuICAgIHZhciBhcnJheSA9IG9mZnNldCA9PT0gdGFpbFBvcyA/IHRhaWwgJiYgdGFpbC5hcnJheSA6IG5vZGUgJiYgbm9kZS5hcnJheTtcbiAgICB2YXIgZnJvbSA9IG9mZnNldCA+IGxlZnQgPyAwIDogbGVmdCAtIG9mZnNldDtcbiAgICB2YXIgdG8gPSByaWdodCAtIG9mZnNldDtcbiAgICBpZiAodG8gPiBTSVpFKSB7XG4gICAgICB0byA9IFNJWkU7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgcmV0dXJuIERPTkU7XG4gICAgICB9XG4gICAgICB2YXIgaWR4ID0gcmV2ZXJzZSA/IC0tdG8gOiBmcm9tKys7XG4gICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXlbaWR4XTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZU5vZGUobm9kZSwgbGV2ZWwsIG9mZnNldCkge1xuICAgIHZhciB2YWx1ZXM7XG4gICAgdmFyIGFycmF5ID0gbm9kZSAmJiBub2RlLmFycmF5O1xuICAgIHZhciBmcm9tID0gb2Zmc2V0ID4gbGVmdCA/IDAgOiAobGVmdCAtIG9mZnNldCkgPj4gbGV2ZWw7XG4gICAgdmFyIHRvID0gKChyaWdodCAtIG9mZnNldCkgPj4gbGV2ZWwpICsgMTtcbiAgICBpZiAodG8gPiBTSVpFKSB7XG4gICAgICB0byA9IFNJWkU7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzKCk7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBET05FKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgcmV0dXJuIERPTkU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkeCA9IHJldmVyc2UgPyAtLXRvIDogZnJvbSsrO1xuICAgICAgICB2YWx1ZXMgPSBpdGVyYXRlTm9kZU9yTGVhZihcbiAgICAgICAgICBhcnJheSAmJiBhcnJheVtpZHhdLFxuICAgICAgICAgIGxldmVsIC0gU0hJRlQsXG4gICAgICAgICAgb2Zmc2V0ICsgKGlkeCA8PCBsZXZlbClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VMaXN0KG9yaWdpbiwgY2FwYWNpdHksIGxldmVsLCByb290LCB0YWlsLCBvd25lcklELCBoYXNoKSB7XG4gIHZhciBsaXN0ID0gT2JqZWN0LmNyZWF0ZShMaXN0UHJvdG90eXBlKTtcbiAgbGlzdC5zaXplID0gY2FwYWNpdHkgLSBvcmlnaW47XG4gIGxpc3QuX29yaWdpbiA9IG9yaWdpbjtcbiAgbGlzdC5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgbGlzdC5fbGV2ZWwgPSBsZXZlbDtcbiAgbGlzdC5fcm9vdCA9IHJvb3Q7XG4gIGxpc3QuX3RhaWwgPSB0YWlsO1xuICBsaXN0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gIGxpc3QuX19oYXNoID0gaGFzaDtcbiAgbGlzdC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGxpc3Q7XG59XG5cbnZhciBFTVBUWV9MSVNUO1xuZnVuY3Rpb24gZW1wdHlMaXN0KCkge1xuICByZXR1cm4gRU1QVFlfTElTVCB8fCAoRU1QVFlfTElTVCA9IG1ha2VMaXN0KDAsIDAsIFNISUZUKSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3QobGlzdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGluZGV4ID0gd3JhcEluZGV4KGxpc3QsIGluZGV4KTtcblxuICBpZiAoaW5kZXggIT09IGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICBpZiAoaW5kZXggPj0gbGlzdC5zaXplIHx8IGluZGV4IDwgMCkge1xuICAgIHJldHVybiBsaXN0LndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgIGluZGV4IDwgMFxuICAgICAgICA/IHNldExpc3RCb3VuZHMobGlzdCwgaW5kZXgpLnNldCgwLCB2YWx1ZSlcbiAgICAgICAgOiBzZXRMaXN0Qm91bmRzKGxpc3QsIDAsIGluZGV4ICsgMSkuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpbmRleCArPSBsaXN0Ll9vcmlnaW47XG5cbiAgdmFyIG5ld1RhaWwgPSBsaXN0Ll90YWlsO1xuICB2YXIgbmV3Um9vdCA9IGxpc3QuX3Jvb3Q7XG4gIHZhciBkaWRBbHRlciA9IE1ha2VSZWYoKTtcbiAgaWYgKGluZGV4ID49IGdldFRhaWxPZmZzZXQobGlzdC5fY2FwYWNpdHkpKSB7XG4gICAgbmV3VGFpbCA9IHVwZGF0ZVZOb2RlKG5ld1RhaWwsIGxpc3QuX19vd25lcklELCAwLCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKTtcbiAgfSBlbHNlIHtcbiAgICBuZXdSb290ID0gdXBkYXRlVk5vZGUoXG4gICAgICBuZXdSb290LFxuICAgICAgbGlzdC5fX293bmVySUQsXG4gICAgICBsaXN0Ll9sZXZlbCxcbiAgICAgIGluZGV4LFxuICAgICAgdmFsdWUsXG4gICAgICBkaWRBbHRlclxuICAgICk7XG4gIH1cblxuICBpZiAoIWRpZEFsdGVyLnZhbHVlKSB7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICBpZiAobGlzdC5fX293bmVySUQpIHtcbiAgICBsaXN0Ll9yb290ID0gbmV3Um9vdDtcbiAgICBsaXN0Ll90YWlsID0gbmV3VGFpbDtcbiAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICBsaXN0Ll9fYWx0ZXJlZCA9IHRydWU7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgcmV0dXJuIG1ha2VMaXN0KGxpc3QuX29yaWdpbiwgbGlzdC5fY2FwYWNpdHksIGxpc3QuX2xldmVsLCBuZXdSb290LCBuZXdUYWlsKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVk5vZGUobm9kZSwgb3duZXJJRCwgbGV2ZWwsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpIHtcbiAgdmFyIGlkeCA9IChpbmRleCA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgdmFyIG5vZGVIYXMgPSBub2RlICYmIGlkeCA8IG5vZGUuYXJyYXkubGVuZ3RoO1xuICBpZiAoIW5vZGVIYXMgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIG5ld05vZGU7XG5cbiAgaWYgKGxldmVsID4gMCkge1xuICAgIHZhciBsb3dlck5vZGUgPSBub2RlICYmIG5vZGUuYXJyYXlbaWR4XTtcbiAgICB2YXIgbmV3TG93ZXJOb2RlID0gdXBkYXRlVk5vZGUoXG4gICAgICBsb3dlck5vZGUsXG4gICAgICBvd25lcklELFxuICAgICAgbGV2ZWwgLSBTSElGVCxcbiAgICAgIGluZGV4LFxuICAgICAgdmFsdWUsXG4gICAgICBkaWRBbHRlclxuICAgICk7XG4gICAgaWYgKG5ld0xvd2VyTm9kZSA9PT0gbG93ZXJOb2RlKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgbmV3Tm9kZSA9IGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCk7XG4gICAgbmV3Tm9kZS5hcnJheVtpZHhdID0gbmV3TG93ZXJOb2RlO1xuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgaWYgKG5vZGVIYXMgJiYgbm9kZS5hcnJheVtpZHhdID09PSB2YWx1ZSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgaWYgKGRpZEFsdGVyKSB7XG4gICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgfVxuXG4gIG5ld05vZGUgPSBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBpZHggPT09IG5ld05vZGUuYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgIG5ld05vZGUuYXJyYXkucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgbmV3Tm9kZS5hcnJheVtpZHhdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG5ld05vZGU7XG59XG5cbmZ1bmN0aW9uIGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCkge1xuICBpZiAob3duZXJJRCAmJiBub2RlICYmIG93bmVySUQgPT09IG5vZGUub3duZXJJRCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiBuZXcgVk5vZGUobm9kZSA/IG5vZGUuYXJyYXkuc2xpY2UoKSA6IFtdLCBvd25lcklEKTtcbn1cblxuZnVuY3Rpb24gbGlzdE5vZGVGb3IobGlzdCwgcmF3SW5kZXgpIHtcbiAgaWYgKHJhd0luZGV4ID49IGdldFRhaWxPZmZzZXQobGlzdC5fY2FwYWNpdHkpKSB7XG4gICAgcmV0dXJuIGxpc3QuX3RhaWw7XG4gIH1cbiAgaWYgKHJhd0luZGV4IDwgMSA8PCAobGlzdC5fbGV2ZWwgKyBTSElGVCkpIHtcbiAgICB2YXIgbm9kZSA9IGxpc3QuX3Jvb3Q7XG4gICAgdmFyIGxldmVsID0gbGlzdC5fbGV2ZWw7XG4gICAgd2hpbGUgKG5vZGUgJiYgbGV2ZWwgPiAwKSB7XG4gICAgICBub2RlID0gbm9kZS5hcnJheVsocmF3SW5kZXggPj4+IGxldmVsKSAmIE1BU0tdO1xuICAgICAgbGV2ZWwgLT0gU0hJRlQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldExpc3RCb3VuZHMobGlzdCwgYmVnaW4sIGVuZCkge1xuICAvLyBTYW5pdGl6ZSBiZWdpbiAmIGVuZCB1c2luZyB0aGlzIHNob3J0aGFuZCBmb3IgVG9JbnQzMihhcmd1bWVudClcbiAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50MzJcbiAgaWYgKGJlZ2luICE9PSB1bmRlZmluZWQpIHtcbiAgICBiZWdpbiB8PSAwO1xuICB9XG4gIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCB8PSAwO1xuICB9XG4gIHZhciBvd25lciA9IGxpc3QuX19vd25lcklEIHx8IG5ldyBPd25lcklEKCk7XG4gIHZhciBvbGRPcmlnaW4gPSBsaXN0Ll9vcmlnaW47XG4gIHZhciBvbGRDYXBhY2l0eSA9IGxpc3QuX2NhcGFjaXR5O1xuICB2YXIgbmV3T3JpZ2luID0gb2xkT3JpZ2luICsgYmVnaW47XG4gIHZhciBuZXdDYXBhY2l0eSA9XG4gICAgZW5kID09PSB1bmRlZmluZWRcbiAgICAgID8gb2xkQ2FwYWNpdHlcbiAgICAgIDogZW5kIDwgMFxuICAgICAgPyBvbGRDYXBhY2l0eSArIGVuZFxuICAgICAgOiBvbGRPcmlnaW4gKyBlbmQ7XG4gIGlmIChuZXdPcmlnaW4gPT09IG9sZE9yaWdpbiAmJiBuZXdDYXBhY2l0eSA9PT0gb2xkQ2FwYWNpdHkpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIC8vIElmIGl0J3MgZ29pbmcgdG8gZW5kIGFmdGVyIGl0IHN0YXJ0cywgaXQncyBlbXB0eS5cbiAgaWYgKG5ld09yaWdpbiA+PSBuZXdDYXBhY2l0eSkge1xuICAgIHJldHVybiBsaXN0LmNsZWFyKCk7XG4gIH1cblxuICB2YXIgbmV3TGV2ZWwgPSBsaXN0Ll9sZXZlbDtcbiAgdmFyIG5ld1Jvb3QgPSBsaXN0Ll9yb290O1xuXG4gIC8vIE5ldyBvcmlnaW4gbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICB2YXIgb2Zmc2V0U2hpZnQgPSAwO1xuICB3aGlsZSAobmV3T3JpZ2luICsgb2Zmc2V0U2hpZnQgPCAwKSB7XG4gICAgbmV3Um9vdCA9IG5ldyBWTm9kZShcbiAgICAgIG5ld1Jvb3QgJiYgbmV3Um9vdC5hcnJheS5sZW5ndGggPyBbdW5kZWZpbmVkLCBuZXdSb290XSA6IFtdLFxuICAgICAgb3duZXJcbiAgICApO1xuICAgIG5ld0xldmVsICs9IFNISUZUO1xuICAgIG9mZnNldFNoaWZ0ICs9IDEgPDwgbmV3TGV2ZWw7XG4gIH1cbiAgaWYgKG9mZnNldFNoaWZ0KSB7XG4gICAgbmV3T3JpZ2luICs9IG9mZnNldFNoaWZ0O1xuICAgIG9sZE9yaWdpbiArPSBvZmZzZXRTaGlmdDtcbiAgICBuZXdDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgICBvbGRDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgfVxuXG4gIHZhciBvbGRUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChvbGRDYXBhY2l0eSk7XG4gIHZhciBuZXdUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChuZXdDYXBhY2l0eSk7XG5cbiAgLy8gTmV3IHNpemUgbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICB3aGlsZSAobmV3VGFpbE9mZnNldCA+PSAxIDw8IChuZXdMZXZlbCArIFNISUZUKSkge1xuICAgIG5ld1Jvb3QgPSBuZXcgVk5vZGUoXG4gICAgICBuZXdSb290ICYmIG5ld1Jvb3QuYXJyYXkubGVuZ3RoID8gW25ld1Jvb3RdIDogW10sXG4gICAgICBvd25lclxuICAgICk7XG4gICAgbmV3TGV2ZWwgKz0gU0hJRlQ7XG4gIH1cblxuICAvLyBMb2NhdGUgb3IgY3JlYXRlIHRoZSBuZXcgdGFpbC5cbiAgdmFyIG9sZFRhaWwgPSBsaXN0Ll90YWlsO1xuICB2YXIgbmV3VGFpbCA9XG4gICAgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXRcbiAgICAgID8gbGlzdE5vZGVGb3IobGlzdCwgbmV3Q2FwYWNpdHkgLSAxKVxuICAgICAgOiBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldFxuICAgICAgPyBuZXcgVk5vZGUoW10sIG93bmVyKVxuICAgICAgOiBvbGRUYWlsO1xuXG4gIC8vIE1lcmdlIFRhaWwgaW50byB0cmVlLlxuICBpZiAoXG4gICAgb2xkVGFpbCAmJlxuICAgIG5ld1RhaWxPZmZzZXQgPiBvbGRUYWlsT2Zmc2V0ICYmXG4gICAgbmV3T3JpZ2luIDwgb2xkQ2FwYWNpdHkgJiZcbiAgICBvbGRUYWlsLmFycmF5Lmxlbmd0aFxuICApIHtcbiAgICBuZXdSb290ID0gZWRpdGFibGVWTm9kZShuZXdSb290LCBvd25lcik7XG4gICAgdmFyIG5vZGUgPSBuZXdSb290O1xuICAgIGZvciAodmFyIGxldmVsID0gbmV3TGV2ZWw7IGxldmVsID4gU0hJRlQ7IGxldmVsIC09IFNISUZUKSB7XG4gICAgICB2YXIgaWR4ID0gKG9sZFRhaWxPZmZzZXQgPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgICBub2RlID0gbm9kZS5hcnJheVtpZHhdID0gZWRpdGFibGVWTm9kZShub2RlLmFycmF5W2lkeF0sIG93bmVyKTtcbiAgICB9XG4gICAgbm9kZS5hcnJheVsob2xkVGFpbE9mZnNldCA+Pj4gU0hJRlQpICYgTUFTS10gPSBvbGRUYWlsO1xuICB9XG5cbiAgLy8gSWYgdGhlIHNpemUgaGFzIGJlZW4gcmVkdWNlZCwgdGhlcmUncyBhIGNoYW5jZSB0aGUgdGFpbCBuZWVkcyB0byBiZSB0cmltbWVkLlxuICBpZiAobmV3Q2FwYWNpdHkgPCBvbGRDYXBhY2l0eSkge1xuICAgIG5ld1RhaWwgPSBuZXdUYWlsICYmIG5ld1RhaWwucmVtb3ZlQWZ0ZXIob3duZXIsIDAsIG5ld0NhcGFjaXR5KTtcbiAgfVxuXG4gIC8vIElmIHRoZSBuZXcgb3JpZ2luIGlzIHdpdGhpbiB0aGUgdGFpbCwgdGhlbiB3ZSBkbyBub3QgbmVlZCBhIHJvb3QuXG4gIGlmIChuZXdPcmlnaW4gPj0gbmV3VGFpbE9mZnNldCkge1xuICAgIG5ld09yaWdpbiAtPSBuZXdUYWlsT2Zmc2V0O1xuICAgIG5ld0NhcGFjaXR5IC09IG5ld1RhaWxPZmZzZXQ7XG4gICAgbmV3TGV2ZWwgPSBTSElGVDtcbiAgICBuZXdSb290ID0gbnVsbDtcbiAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUJlZm9yZShvd25lciwgMCwgbmV3T3JpZ2luKTtcblxuICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIHJvb3QgaGFzIGJlZW4gdHJpbW1lZCwgZ2FyYmFnZSBjb2xsZWN0LlxuICB9IGVsc2UgaWYgKG5ld09yaWdpbiA+IG9sZE9yaWdpbiB8fCBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCkge1xuICAgIG9mZnNldFNoaWZ0ID0gMDtcblxuICAgIC8vIElkZW50aWZ5IHRoZSBuZXcgdG9wIHJvb3Qgbm9kZSBvZiB0aGUgc3VidHJlZSBvZiB0aGUgb2xkIHJvb3QuXG4gICAgd2hpbGUgKG5ld1Jvb3QpIHtcbiAgICAgIHZhciBiZWdpbkluZGV4ID0gKG5ld09yaWdpbiA+Pj4gbmV3TGV2ZWwpICYgTUFTSztcbiAgICAgIGlmICgoYmVnaW5JbmRleCAhPT0gbmV3VGFpbE9mZnNldCA+Pj4gbmV3TGV2ZWwpICYgTUFTSykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChiZWdpbkluZGV4KSB7XG4gICAgICAgIG9mZnNldFNoaWZ0ICs9ICgxIDw8IG5ld0xldmVsKSAqIGJlZ2luSW5kZXg7XG4gICAgICB9XG4gICAgICBuZXdMZXZlbCAtPSBTSElGVDtcbiAgICAgIG5ld1Jvb3QgPSBuZXdSb290LmFycmF5W2JlZ2luSW5kZXhdO1xuICAgIH1cblxuICAgIC8vIFRyaW0gdGhlIG5ldyBzaWRlcyBvZiB0aGUgbmV3IHJvb3QuXG4gICAgaWYgKG5ld1Jvb3QgJiYgbmV3T3JpZ2luID4gb2xkT3JpZ2luKSB7XG4gICAgICBuZXdSb290ID0gbmV3Um9vdC5yZW1vdmVCZWZvcmUob3duZXIsIG5ld0xldmVsLCBuZXdPcmlnaW4gLSBvZmZzZXRTaGlmdCk7XG4gICAgfVxuICAgIGlmIChuZXdSb290ICYmIG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0KSB7XG4gICAgICBuZXdSb290ID0gbmV3Um9vdC5yZW1vdmVBZnRlcihcbiAgICAgICAgb3duZXIsXG4gICAgICAgIG5ld0xldmVsLFxuICAgICAgICBuZXdUYWlsT2Zmc2V0IC0gb2Zmc2V0U2hpZnRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvZmZzZXRTaGlmdCkge1xuICAgICAgbmV3T3JpZ2luIC09IG9mZnNldFNoaWZ0O1xuICAgICAgbmV3Q2FwYWNpdHkgLT0gb2Zmc2V0U2hpZnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxpc3QuX19vd25lcklEKSB7XG4gICAgbGlzdC5zaXplID0gbmV3Q2FwYWNpdHkgLSBuZXdPcmlnaW47XG4gICAgbGlzdC5fb3JpZ2luID0gbmV3T3JpZ2luO1xuICAgIGxpc3QuX2NhcGFjaXR5ID0gbmV3Q2FwYWNpdHk7XG4gICAgbGlzdC5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICBsaXN0Ll9yb290ID0gbmV3Um9vdDtcbiAgICBsaXN0Ll90YWlsID0gbmV3VGFpbDtcbiAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICBsaXN0Ll9fYWx0ZXJlZCA9IHRydWU7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgcmV0dXJuIG1ha2VMaXN0KG5ld09yaWdpbiwgbmV3Q2FwYWNpdHksIG5ld0xldmVsLCBuZXdSb290LCBuZXdUYWlsKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFpbE9mZnNldChzaXplKSB7XG4gIHJldHVybiBzaXplIDwgU0laRSA/IDAgOiAoKHNpemUgLSAxKSA+Pj4gU0hJRlQpIDw8IFNISUZUO1xufVxuXG52YXIgT3JkZXJlZE1hcCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKE1hcCkge1xuICBmdW5jdGlvbiBPcmRlcmVkTWFwKHZhbHVlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsXG4gICAgICA/IGVtcHR5T3JkZXJlZE1hcCgpXG4gICAgICA6IGlzT3JkZXJlZE1hcCh2YWx1ZSlcbiAgICAgID8gdmFsdWVcbiAgICAgIDogZW1wdHlPcmRlcmVkTWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgdmFyIGl0ZXIgPSBLZXllZENvbGxlY3Rpb24odmFsdWUpO1xuICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBtYXAuc2V0KGssIHYpOyB9KTtcbiAgICAgICAgfSk7XG4gIH1cblxuICBpZiAoIE1hcCApIE9yZGVyZWRNYXAuX19wcm90b19fID0gTWFwO1xuICBPcmRlcmVkTWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hcCAmJiBNYXAucHJvdG90eXBlICk7XG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3JkZXJlZE1hcDtcblxuICBPcmRlcmVkTWFwLm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICB9O1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ09yZGVyZWRNYXAgeycsICd9Jyk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGssIG5vdFNldFZhbHVlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fbWFwLmdldChrKTtcbiAgICByZXR1cm4gaW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2xpc3QuZ2V0KGluZGV4KVsxXSA6IG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgT3JkZXJlZE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgICAgdGhpcy5fbGlzdC5jbGVhcigpO1xuICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eU9yZGVyZWRNYXAoKTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGssIHYpIHtcbiAgICByZXR1cm4gdXBkYXRlT3JkZXJlZE1hcCh0aGlzLCBrLCB2KTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGspIHtcbiAgICByZXR1cm4gdXBkYXRlT3JkZXJlZE1hcCh0aGlzLCBrLCBOT1RfU0VUKTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLl9saXN0Ll9faXRlcmF0ZShcbiAgICAgIGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkgJiYgZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzJDEkMSk7IH0sXG4gICAgICByZXZlcnNlXG4gICAgKTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHJldHVybiB0aGlzLl9saXN0LmZyb21FbnRyeVNlcSgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgdmFyIG5ld0xpc3QgPSB0aGlzLl9saXN0Ll9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eU9yZGVyZWRNYXAoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9tYXAgPSBuZXdNYXA7XG4gICAgICB0aGlzLl9saXN0ID0gbmV3TGlzdDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZU9yZGVyZWRNYXAobmV3TWFwLCBuZXdMaXN0LCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gIH07XG5cbiAgcmV0dXJuIE9yZGVyZWRNYXA7XG59KE1hcCkpO1xuXG5PcmRlcmVkTWFwLmlzT3JkZXJlZE1hcCA9IGlzT3JkZXJlZE1hcDtcblxuT3JkZXJlZE1hcC5wcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcbk9yZGVyZWRNYXAucHJvdG90eXBlW0RFTEVURV0gPSBPcmRlcmVkTWFwLnByb3RvdHlwZS5yZW1vdmU7XG5cbmZ1bmN0aW9uIG1ha2VPcmRlcmVkTWFwKG1hcCwgbGlzdCwgb3duZXJJRCwgaGFzaCkge1xuICB2YXIgb21hcCA9IE9iamVjdC5jcmVhdGUoT3JkZXJlZE1hcC5wcm90b3R5cGUpO1xuICBvbWFwLnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG4gIG9tYXAuX21hcCA9IG1hcDtcbiAgb21hcC5fbGlzdCA9IGxpc3Q7XG4gIG9tYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgb21hcC5fX2hhc2ggPSBoYXNoO1xuICBvbWFwLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICByZXR1cm4gb21hcDtcbn1cblxudmFyIEVNUFRZX09SREVSRURfTUFQO1xuZnVuY3Rpb24gZW1wdHlPcmRlcmVkTWFwKCkge1xuICByZXR1cm4gKFxuICAgIEVNUFRZX09SREVSRURfTUFQIHx8XG4gICAgKEVNUFRZX09SREVSRURfTUFQID0gbWFrZU9yZGVyZWRNYXAoZW1wdHlNYXAoKSwgZW1wdHlMaXN0KCkpKVxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPcmRlcmVkTWFwKG9tYXAsIGssIHYpIHtcbiAgdmFyIG1hcCA9IG9tYXAuX21hcDtcbiAgdmFyIGxpc3QgPSBvbWFwLl9saXN0O1xuICB2YXIgaSA9IG1hcC5nZXQoayk7XG4gIHZhciBoYXMgPSBpICE9PSB1bmRlZmluZWQ7XG4gIHZhciBuZXdNYXA7XG4gIHZhciBuZXdMaXN0O1xuICBpZiAodiA9PT0gTk9UX1NFVCkge1xuICAgIC8vIHJlbW92ZWRcbiAgICBpZiAoIWhhcykge1xuICAgICAgcmV0dXJuIG9tYXA7XG4gICAgfVxuICAgIGlmIChsaXN0LnNpemUgPj0gU0laRSAmJiBsaXN0LnNpemUgPj0gbWFwLnNpemUgKiAyKSB7XG4gICAgICBuZXdMaXN0ID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5LCBpZHgpIHsgcmV0dXJuIGVudHJ5ICE9PSB1bmRlZmluZWQgJiYgaSAhPT0gaWR4OyB9KTtcbiAgICAgIG5ld01hcCA9IG5ld0xpc3RcbiAgICAgICAgLnRvS2V5ZWRTZXEoKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnlbMF07IH0pXG4gICAgICAgIC5mbGlwKClcbiAgICAgICAgLnRvTWFwKCk7XG4gICAgICBpZiAob21hcC5fX293bmVySUQpIHtcbiAgICAgICAgbmV3TWFwLl9fb3duZXJJRCA9IG5ld0xpc3QuX19vd25lcklEID0gb21hcC5fX293bmVySUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld01hcCA9IG1hcC5yZW1vdmUoayk7XG4gICAgICBuZXdMaXN0ID0gaSA9PT0gbGlzdC5zaXplIC0gMSA/IGxpc3QucG9wKCkgOiBsaXN0LnNldChpLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChoYXMpIHtcbiAgICBpZiAodiA9PT0gbGlzdC5nZXQoaSlbMV0pIHtcbiAgICAgIHJldHVybiBvbWFwO1xuICAgIH1cbiAgICBuZXdNYXAgPSBtYXA7XG4gICAgbmV3TGlzdCA9IGxpc3Quc2V0KGksIFtrLCB2XSk7XG4gIH0gZWxzZSB7XG4gICAgbmV3TWFwID0gbWFwLnNldChrLCBsaXN0LnNpemUpO1xuICAgIG5ld0xpc3QgPSBsaXN0LnNldChsaXN0LnNpemUsIFtrLCB2XSk7XG4gIH1cbiAgaWYgKG9tYXAuX19vd25lcklEKSB7XG4gICAgb21hcC5zaXplID0gbmV3TWFwLnNpemU7XG4gICAgb21hcC5fbWFwID0gbmV3TWFwO1xuICAgIG9tYXAuX2xpc3QgPSBuZXdMaXN0O1xuICAgIG9tYXAuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgIG9tYXAuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gb21hcDtcbiAgfVxuICByZXR1cm4gbWFrZU9yZGVyZWRNYXAobmV3TWFwLCBuZXdMaXN0KTtcbn1cblxudmFyIElTX1NUQUNLX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1NUQUNLX19AQCc7XG5cbmZ1bmN0aW9uIGlzU3RhY2sobWF5YmVTdGFjaykge1xuICByZXR1cm4gQm9vbGVhbihtYXliZVN0YWNrICYmIG1heWJlU3RhY2tbSVNfU1RBQ0tfU1lNQk9MXSk7XG59XG5cbnZhciBTdGFjayA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRDb2xsZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFN0YWNrKHZhbHVlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsXG4gICAgICA/IGVtcHR5U3RhY2soKVxuICAgICAgOiBpc1N0YWNrKHZhbHVlKVxuICAgICAgPyB2YWx1ZVxuICAgICAgOiBlbXB0eVN0YWNrKCkucHVzaEFsbCh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIEluZGV4ZWRDb2xsZWN0aW9uICkgU3RhY2suX19wcm90b19fID0gSW5kZXhlZENvbGxlY3Rpb247XG4gIFN0YWNrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRDb2xsZWN0aW9uICYmIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICBTdGFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGFjaztcblxuICBTdGFjay5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU3RhY2sgWycsICddJyk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgIHdoaWxlIChoZWFkICYmIGluZGV4LS0pIHtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBoZWFkID8gaGVhZC52YWx1ZSA6IG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gcGVlayAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWQgJiYgdGhpcy5faGVhZC52YWx1ZTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gIFN0YWNrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAoLyouLi52YWx1ZXMqLykge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemUgKyBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICBmb3IgKHZhciBpaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpaSA+PSAwOyBpaS0tKSB7XG4gICAgICBoZWFkID0ge1xuICAgICAgICB2YWx1ZTogYXJndW1lbnRzJDFbaWldLFxuICAgICAgICBuZXh0OiBoZWFkLFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xuICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG4gICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZVN0YWNrKG5ld1NpemUsIGhlYWQpO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5wdXNoQWxsID0gZnVuY3Rpb24gcHVzaEFsbCAoaXRlcikge1xuICAgIGl0ZXIgPSBJbmRleGVkQ29sbGVjdGlvbihpdGVyKTtcbiAgICBpZiAoaXRlci5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCAmJiBpc1N0YWNrKGl0ZXIpKSB7XG4gICAgICByZXR1cm4gaXRlcjtcbiAgICB9XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgaXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBuZXdTaXplKys7XG4gICAgICBoZWFkID0ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIG5leHQ6IGhlYWQsXG4gICAgICB9O1xuICAgIH0sIC8qIHJldmVyc2UgKi8gdHJ1ZSk7XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xuICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG4gICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZVN0YWNrKG5ld1NpemUsIGhlYWQpO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiBwb3AgKCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKDEpO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eVN0YWNrKCk7XG4gIH07XG5cbiAgU3RhY2sucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCB0aGlzLnNpemUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIHJlc29sdmVkQmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIHRoaXMuc2l6ZSk7XG4gICAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIHRoaXMuc2l6ZSk7XG4gICAgaWYgKHJlc29sdmVkRW5kICE9PSB0aGlzLnNpemUpIHtcbiAgICAgIC8vIHN1cGVyLnNsaWNlKGJlZ2luLCBlbmQpO1xuICAgICAgcmV0dXJuIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIH1cbiAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZSAtIHJlc29sdmVkQmVnaW47XG4gICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgIHdoaWxlIChyZXNvbHZlZEJlZ2luLS0pIHtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIE11dGFiaWxpdHlcblxuICBTdGFjay5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5U3RhY2soKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VTdGFjayh0aGlzLnNpemUsIHRoaXMuX2hlYWQsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIEl0ZXJhdGlvblxuXG4gIFN0YWNrLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gbmV3IEFycmF5U2VxKHRoaXMudG9BcnJheSgpKS5fX2l0ZXJhdGUoXG4gICAgICAgIGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmbih2LCBrLCB0aGlzJDEkMSk7IH0sXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYWQ7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGlmIChmbihub2RlLnZhbHVlLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gbmV3IEFycmF5U2VxKHRoaXMudG9BcnJheSgpKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFN0YWNrO1xufShJbmRleGVkQ29sbGVjdGlvbikpO1xuXG5TdGFjay5pc1N0YWNrID0gaXNTdGFjaztcblxudmFyIFN0YWNrUHJvdG90eXBlID0gU3RhY2sucHJvdG90eXBlO1xuU3RhY2tQcm90b3R5cGVbSVNfU1RBQ0tfU1lNQk9MXSA9IHRydWU7XG5TdGFja1Byb3RvdHlwZS5zaGlmdCA9IFN0YWNrUHJvdG90eXBlLnBvcDtcblN0YWNrUHJvdG90eXBlLnVuc2hpZnQgPSBTdGFja1Byb3RvdHlwZS5wdXNoO1xuU3RhY2tQcm90b3R5cGUudW5zaGlmdEFsbCA9IFN0YWNrUHJvdG90eXBlLnB1c2hBbGw7XG5TdGFja1Byb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcblN0YWNrUHJvdG90eXBlLndhc0FsdGVyZWQgPSB3YXNBbHRlcmVkO1xuU3RhY2tQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcblN0YWNrUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gU3RhY2tQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuU3RhY2tQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBhcnIpIHtcbiAgcmV0dXJuIHJlc3VsdC51bnNoaWZ0KGFycik7XG59O1xuU3RhY2tQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iai5hc0ltbXV0YWJsZSgpO1xufTtcblxuZnVuY3Rpb24gbWFrZVN0YWNrKHNpemUsIGhlYWQsIG93bmVySUQsIGhhc2gpIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUoU3RhY2tQcm90b3R5cGUpO1xuICBtYXAuc2l6ZSA9IHNpemU7XG4gIG1hcC5faGVhZCA9IGhlYWQ7XG4gIG1hcC5fX293bmVySUQgPSBvd25lcklEO1xuICBtYXAuX19oYXNoID0gaGFzaDtcbiAgbWFwLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICByZXR1cm4gbWFwO1xufVxuXG52YXIgRU1QVFlfU1RBQ0s7XG5mdW5jdGlvbiBlbXB0eVN0YWNrKCkge1xuICByZXR1cm4gRU1QVFlfU1RBQ0sgfHwgKEVNUFRZX1NUQUNLID0gbWFrZVN0YWNrKDApKTtcbn1cblxudmFyIElTX1NFVF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9TRVRfX0BAJztcblxuZnVuY3Rpb24gaXNTZXQobWF5YmVTZXQpIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVTZXQgJiYgbWF5YmVTZXRbSVNfU0VUX1NZTUJPTF0pO1xufVxuXG5mdW5jdGlvbiBpc09yZGVyZWRTZXQobWF5YmVPcmRlcmVkU2V0KSB7XG4gIHJldHVybiBpc1NldChtYXliZU9yZGVyZWRTZXQpICYmIGlzT3JkZXJlZChtYXliZU9yZGVyZWRTZXQpO1xufVxuXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKFxuICAgICFpc0NvbGxlY3Rpb24oYikgfHxcbiAgICAoYS5zaXplICE9PSB1bmRlZmluZWQgJiYgYi5zaXplICE9PSB1bmRlZmluZWQgJiYgYS5zaXplICE9PSBiLnNpemUpIHx8XG4gICAgKGEuX19oYXNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGIuX19oYXNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGEuX19oYXNoICE9PSBiLl9faGFzaCkgfHxcbiAgICBpc0tleWVkKGEpICE9PSBpc0tleWVkKGIpIHx8XG4gICAgaXNJbmRleGVkKGEpICE9PSBpc0luZGV4ZWQoYikgfHxcbiAgICBpc09yZGVyZWQoYSkgIT09IGlzT3JkZXJlZChiKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5zaXplID09PSAwICYmIGIuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG5vdEFzc29jaWF0aXZlID0gIWlzQXNzb2NpYXRpdmUoYSk7XG5cbiAgaWYgKGlzT3JkZXJlZChhKSkge1xuICAgIHZhciBlbnRyaWVzID0gYS5lbnRyaWVzKCk7XG4gICAgcmV0dXJuIChcbiAgICAgIGIuZXZlcnkoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllcy5uZXh0KCkudmFsdWU7XG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBpcyhlbnRyeVsxXSwgdikgJiYgKG5vdEFzc29jaWF0aXZlIHx8IGlzKGVudHJ5WzBdLCBrKSk7XG4gICAgICB9KSAmJiBlbnRyaWVzLm5leHQoKS5kb25lXG4gICAgKTtcbiAgfVxuXG4gIHZhciBmbGlwcGVkID0gZmFsc2U7XG5cbiAgaWYgKGEuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGIuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGEuY2FjaGVSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYS5jYWNoZVJlc3VsdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmbGlwcGVkID0gdHJ1ZTtcbiAgICAgIHZhciBfID0gYTtcbiAgICAgIGEgPSBiO1xuICAgICAgYiA9IF87XG4gICAgfVxuICB9XG5cbiAgdmFyIGFsbEVxdWFsID0gdHJ1ZTtcbiAgdmFyIGJTaXplID0gYi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICBpZiAoXG4gICAgICBub3RBc3NvY2lhdGl2ZVxuICAgICAgICA/ICFhLmhhcyh2KVxuICAgICAgICA6IGZsaXBwZWRcbiAgICAgICAgPyAhaXModiwgYS5nZXQoaywgTk9UX1NFVCkpXG4gICAgICAgIDogIWlzKGEuZ2V0KGssIE5PVF9TRVQpLCB2KVxuICAgICkge1xuICAgICAgYWxsRXF1YWwgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhbGxFcXVhbCAmJiBhLnNpemUgPT09IGJTaXplO1xufVxuXG5mdW5jdGlvbiBtaXhpbihjdG9yLCBtZXRob2RzKSB7XG4gIHZhciBrZXlDb3BpZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgY3Rvci5wcm90b3R5cGVba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgfTtcbiAgT2JqZWN0LmtleXMobWV0aG9kcykuZm9yRWFjaChrZXlDb3BpZXIpO1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtZXRob2RzKS5mb3JFYWNoKGtleUNvcGllcik7XG4gIHJldHVybiBjdG9yO1xufVxuXG5mdW5jdGlvbiB0b0pTKHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoIWlzQ29sbGVjdGlvbih2YWx1ZSkpIHtcbiAgICBpZiAoIWlzRGF0YVN0cnVjdHVyZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBTZXEodmFsdWUpO1xuICB9XG4gIGlmIChpc0tleWVkKHZhbHVlKSkge1xuICAgIHZhciByZXN1bHQkMSA9IHt9O1xuICAgIHZhbHVlLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgcmVzdWx0JDFba10gPSB0b0pTKHYpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQkMTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhbHVlLl9faXRlcmF0ZShmdW5jdGlvbiAodikge1xuICAgIHJlc3VsdC5wdXNoKHRvSlModikpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFNldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNldENvbGxlY3Rpb24pIHtcbiAgZnVuY3Rpb24gU2V0KHZhbHVlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsXG4gICAgICA/IGVtcHR5U2V0KClcbiAgICAgIDogaXNTZXQodmFsdWUpICYmICFpc09yZGVyZWQodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IGVtcHR5U2V0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgdmFyIGl0ZXIgPSBTZXRDb2xsZWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gc2V0LmFkZCh2KTsgfSk7XG4gICAgICAgIH0pO1xuICB9XG5cbiAgaWYgKCBTZXRDb2xsZWN0aW9uICkgU2V0Ll9fcHJvdG9fXyA9IFNldENvbGxlY3Rpb247XG4gIFNldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXRDb2xsZWN0aW9uICYmIFNldENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gIFNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXQ7XG5cbiAgU2V0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICB9O1xuXG4gIFNldC5mcm9tS2V5cyA9IGZ1bmN0aW9uIGZyb21LZXlzICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzKEtleWVkQ29sbGVjdGlvbih2YWx1ZSkua2V5U2VxKCkpO1xuICB9O1xuXG4gIFNldC5pbnRlcnNlY3QgPSBmdW5jdGlvbiBpbnRlcnNlY3QgKHNldHMpIHtcbiAgICBzZXRzID0gQ29sbGVjdGlvbihzZXRzKS50b0FycmF5KCk7XG4gICAgcmV0dXJuIHNldHMubGVuZ3RoXG4gICAgICA/IFNldFByb3RvdHlwZS5pbnRlcnNlY3QuYXBwbHkoU2V0KHNldHMucG9wKCkpLCBzZXRzKVxuICAgICAgOiBlbXB0eVNldCgpO1xuICB9O1xuXG4gIFNldC51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uIChzZXRzKSB7XG4gICAgc2V0cyA9IENvbGxlY3Rpb24oc2V0cykudG9BcnJheSgpO1xuICAgIHJldHVybiBzZXRzLmxlbmd0aFxuICAgICAgPyBTZXRQcm90b3R5cGUudW5pb24uYXBwbHkoU2V0KHNldHMucG9wKCkpLCBzZXRzKVxuICAgICAgOiBlbXB0eVNldCgpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2V0IHsnLCAnfScpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXModmFsdWUpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuc2V0KHZhbHVlLCB2YWx1ZSkpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICh2YWx1ZSkge1xuICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLnJlbW92ZSh2YWx1ZSkpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuY2xlYXIoKSk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gIFNldC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgLy8ga2VlcCB0cmFjayBpZiB0aGUgc2V0IGlzIGFsdGVyZWQgYnkgdGhlIG1hcCBmdW5jdGlvblxuICAgIHZhciBkaWRDaGFuZ2VzID0gZmFsc2U7XG5cbiAgICB2YXIgbmV3TWFwID0gdXBkYXRlU2V0KFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMuX21hcC5tYXBFbnRyaWVzKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIHYgPSByZWZbMV07XG5cbiAgICAgICAgdmFyIG1hcHBlZCA9IG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIHYsIHRoaXMkMSQxKTtcblxuICAgICAgICBpZiAobWFwcGVkICE9PSB2KSB7XG4gICAgICAgICAgZGlkQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW21hcHBlZCwgbWFwcGVkXTtcbiAgICAgIH0sIGNvbnRleHQpXG4gICAgKTtcblxuICAgIHJldHVybiBkaWRDaGFuZ2VzID8gbmV3TWFwIDogdGhpcztcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24gdW5pb24gKCkge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgaXRlcnMgPSBpdGVycy5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2l6ZSAhPT0gMDsgfSk7XG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLnNpemUgPT09IDAgJiYgIXRoaXMuX19vd25lcklEICYmIGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IoaXRlcnNbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyc1tpaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgc2V0LmFkZChpdGVyc1tpaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFNldENvbGxlY3Rpb24oaXRlcnNbaWldKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc2V0LmFkZCh2YWx1ZSk7IH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgU2V0LnByb3RvdHlwZS5pbnRlcnNlY3QgPSBmdW5jdGlvbiBpbnRlcnNlY3QgKCkge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGl0ZXJzID0gaXRlcnMubWFwKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBTZXRDb2xsZWN0aW9uKGl0ZXIpOyB9KTtcbiAgICB2YXIgdG9SZW1vdmUgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoIWl0ZXJzLmV2ZXJ5KGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKTsgfSkpIHtcbiAgICAgICAgdG9SZW1vdmUucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICB0b1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzZXQucmVtb3ZlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdCAoKSB7XG4gICAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaXRlcnMgPSBpdGVycy5tYXAoZnVuY3Rpb24gKGl0ZXIpIHsgcmV0dXJuIFNldENvbGxlY3Rpb24oaXRlcik7IH0pO1xuICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChpdGVycy5zb21lKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKTsgfSkpIHtcbiAgICAgICAgdG9SZW1vdmUucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICB0b1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzZXQucmVtb3ZlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIHNvcnQgKGNvbXBhcmF0b3IpIHtcbiAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICByZXR1cm4gT3JkZXJlZFNldChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gIH07XG5cbiAgU2V0LnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbiBzb3J0QnkgKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgIC8vIExhdGUgYmluZGluZ1xuICAgIHJldHVybiBPcmRlcmVkU2V0KHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uIHdhc0FsdGVyZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5fbWFwLl9faXRlcmF0ZShmdW5jdGlvbiAoaykgeyByZXR1cm4gZm4oaywgaywgdGhpcyQxJDEpOyB9LCByZXZlcnNlKTtcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZW1wdHkoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX21ha2UobmV3TWFwLCBvd25lcklEKTtcbiAgfTtcblxuICByZXR1cm4gU2V0O1xufShTZXRDb2xsZWN0aW9uKSk7XG5cblNldC5pc1NldCA9IGlzU2V0O1xuXG52YXIgU2V0UHJvdG90eXBlID0gU2V0LnByb3RvdHlwZTtcblNldFByb3RvdHlwZVtJU19TRVRfU1lNQk9MXSA9IHRydWU7XG5TZXRQcm90b3R5cGVbREVMRVRFXSA9IFNldFByb3RvdHlwZS5yZW1vdmU7XG5TZXRQcm90b3R5cGUubWVyZ2UgPSBTZXRQcm90b3R5cGUuY29uY2F0ID0gU2V0UHJvdG90eXBlLnVuaW9uO1xuU2V0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuU2V0UHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG5TZXRQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBTZXRQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuU2V0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgYXJyKSB7XG4gIHJldHVybiByZXN1bHQuYWRkKGFycik7XG59O1xuU2V0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbn07XG5cblNldFByb3RvdHlwZS5fX2VtcHR5ID0gZW1wdHlTZXQ7XG5TZXRQcm90b3R5cGUuX19tYWtlID0gbWFrZVNldDtcblxuZnVuY3Rpb24gdXBkYXRlU2V0KHNldCwgbmV3TWFwKSB7XG4gIGlmIChzZXQuX19vd25lcklEKSB7XG4gICAgc2V0LnNpemUgPSBuZXdNYXAuc2l6ZTtcbiAgICBzZXQuX21hcCA9IG5ld01hcDtcbiAgICByZXR1cm4gc2V0O1xuICB9XG4gIHJldHVybiBuZXdNYXAgPT09IHNldC5fbWFwXG4gICAgPyBzZXRcbiAgICA6IG5ld01hcC5zaXplID09PSAwXG4gICAgPyBzZXQuX19lbXB0eSgpXG4gICAgOiBzZXQuX19tYWtlKG5ld01hcCk7XG59XG5cbmZ1bmN0aW9uIG1ha2VTZXQobWFwLCBvd25lcklEKSB7XG4gIHZhciBzZXQgPSBPYmplY3QuY3JlYXRlKFNldFByb3RvdHlwZSk7XG4gIHNldC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICBzZXQuX21hcCA9IG1hcDtcbiAgc2V0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gIHJldHVybiBzZXQ7XG59XG5cbnZhciBFTVBUWV9TRVQ7XG5mdW5jdGlvbiBlbXB0eVNldCgpIHtcbiAgcmV0dXJuIEVNUFRZX1NFVCB8fCAoRU1QVFlfU0VUID0gbWFrZVNldChlbXB0eU1hcCgpKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxhenkgc2VxIG9mIG51bXMgZnJvbSBzdGFydCAoaW5jbHVzaXZlKSB0byBlbmRcbiAqIChleGNsdXNpdmUpLCBieSBzdGVwLCB3aGVyZSBzdGFydCBkZWZhdWx0cyB0byAwLCBzdGVwIHRvIDEsIGFuZCBlbmQgdG9cbiAqIGluZmluaXR5LiBXaGVuIHN0YXJ0IGlzIGVxdWFsIHRvIGVuZCwgcmV0dXJucyBlbXB0eSBsaXN0LlxuICovXG52YXIgUmFuZ2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gIGZ1bmN0aW9uIFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoc3RlcCAhPT0gMCwgJ0Nhbm5vdCBzdGVwIGEgUmFuZ2UgYnkgMCcpO1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IEluZmluaXR5O1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gMSA6IE1hdGguYWJzKHN0ZXApO1xuICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgc3RlcCA9IC1zdGVwO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICB0aGlzLnNpemUgPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGVuZCAtIHN0YXJ0KSAvIHN0ZXAgLSAxKSArIDEpO1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIGlmIChFTVBUWV9SQU5HRSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gICAgICAgIHJldHVybiBFTVBUWV9SQU5HRTtcbiAgICAgIH1cbiAgICAgIEVNUFRZX1JBTkdFID0gdGhpcztcbiAgICB9XG4gIH1cblxuICBpZiAoIEluZGV4ZWRTZXEgKSBSYW5nZS5fX3Byb3RvX18gPSBJbmRleGVkU2VxO1xuICBSYW5nZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gIFJhbmdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhbmdlO1xuXG4gIFJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gJ1JhbmdlIFtdJztcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgICdSYW5nZSBbICcgK1xuICAgICAgdGhpcy5fc3RhcnQgK1xuICAgICAgJy4uLicgK1xuICAgICAgdGhpcy5fZW5kICtcbiAgICAgICh0aGlzLl9zdGVwICE9PSAxID8gJyBieSAnICsgdGhpcy5fc3RlcCA6ICcnKSArXG4gICAgICAnIF0nXG4gICAgKTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpXG4gICAgICA/IHRoaXMuX3N0YXJ0ICsgd3JhcEluZGV4KHRoaXMsIGluZGV4KSAqIHRoaXMuX3N0ZXBcbiAgICAgIDogbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgUmFuZ2UucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHNlYXJjaFZhbHVlKSB7XG4gICAgdmFyIHBvc3NpYmxlSW5kZXggPSAoc2VhcmNoVmFsdWUgLSB0aGlzLl9zdGFydCkgLyB0aGlzLl9zdGVwO1xuICAgIHJldHVybiAoXG4gICAgICBwb3NzaWJsZUluZGV4ID49IDAgJiZcbiAgICAgIHBvc3NpYmxlSW5kZXggPCB0aGlzLnNpemUgJiZcbiAgICAgIHBvc3NpYmxlSW5kZXggPT09IE1hdGguZmxvb3IocG9zc2libGVJbmRleClcbiAgICApO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgdGhpcy5zaXplKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCB0aGlzLnNpemUpO1xuICAgIGVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLnNpemUpO1xuICAgIGlmIChlbmQgPD0gYmVnaW4pIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoMCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmFuZ2UoXG4gICAgICB0aGlzLmdldChiZWdpbiwgdGhpcy5fZW5kKSxcbiAgICAgIHRoaXMuZ2V0KGVuZCwgdGhpcy5fZW5kKSxcbiAgICAgIHRoaXMuX3N0ZXBcbiAgICApO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAoc2VhcmNoVmFsdWUpIHtcbiAgICB2YXIgb2Zmc2V0VmFsdWUgPSBzZWFyY2hWYWx1ZSAtIHRoaXMuX3N0YXJ0O1xuICAgIGlmIChvZmZzZXRWYWx1ZSAlIHRoaXMuX3N0ZXAgPT09IDApIHtcbiAgICAgIHZhciBpbmRleCA9IG9mZnNldFZhbHVlIC8gdGhpcy5fc3RlcDtcbiAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmluZGV4T2Yoc2VhcmNoVmFsdWUpO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuICAgIHZhciB2YWx1ZSA9IHJldmVyc2UgPyB0aGlzLl9zdGFydCArIChzaXplIC0gMSkgKiBzdGVwIDogdGhpcy5fc3RhcnQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICBpZiAoZm4odmFsdWUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YWx1ZSArPSByZXZlcnNlID8gLXN0ZXAgOiBzdGVwO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB2YXIgc3RlcCA9IHRoaXMuX3N0ZXA7XG4gICAgdmFyIHZhbHVlID0gcmV2ZXJzZSA/IHRoaXMuX3N0YXJ0ICsgKHNpemUgLSAxKSAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgdiA9IHZhbHVlO1xuICAgICAgdmFsdWUgKz0gcmV2ZXJzZSA/IC1zdGVwIDogc3RlcDtcbiAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB2KTtcbiAgICB9KTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChvdGhlcikge1xuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFJhbmdlXG4gICAgICA/IHRoaXMuX3N0YXJ0ID09PSBvdGhlci5fc3RhcnQgJiZcbiAgICAgICAgICB0aGlzLl9lbmQgPT09IG90aGVyLl9lbmQgJiZcbiAgICAgICAgICB0aGlzLl9zdGVwID09PSBvdGhlci5fc3RlcFxuICAgICAgOiBkZWVwRXF1YWwodGhpcywgb3RoZXIpO1xuICB9O1xuXG4gIHJldHVybiBSYW5nZTtcbn0oSW5kZXhlZFNlcSkpO1xuXG52YXIgRU1QVFlfUkFOR0U7XG5cbmZ1bmN0aW9uIGdldEluJDEoY29sbGVjdGlvbiwgc2VhcmNoS2V5UGF0aCwgbm90U2V0VmFsdWUpIHtcbiAgdmFyIGtleVBhdGggPSBjb2VyY2VLZXlQYXRoKHNlYXJjaEtleVBhdGgpO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpICE9PSBrZXlQYXRoLmxlbmd0aCkge1xuICAgIGNvbGxlY3Rpb24gPSBnZXQoY29sbGVjdGlvbiwga2V5UGF0aFtpKytdLCBOT1RfU0VUKTtcbiAgICBpZiAoY29sbGVjdGlvbiA9PT0gTk9UX1NFVCkge1xuICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0SW4oc2VhcmNoS2V5UGF0aCwgbm90U2V0VmFsdWUpIHtcbiAgcmV0dXJuIGdldEluJDEodGhpcywgc2VhcmNoS2V5UGF0aCwgbm90U2V0VmFsdWUpO1xufVxuXG5mdW5jdGlvbiBoYXNJbiQxKGNvbGxlY3Rpb24sIGtleVBhdGgpIHtcbiAgcmV0dXJuIGdldEluJDEoY29sbGVjdGlvbiwga2V5UGF0aCwgTk9UX1NFVCkgIT09IE5PVF9TRVQ7XG59XG5cbmZ1bmN0aW9uIGhhc0luKHNlYXJjaEtleVBhdGgpIHtcbiAgcmV0dXJuIGhhc0luJDEodGhpcywgc2VhcmNoS2V5UGF0aCk7XG59XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICB2YXIgb2JqZWN0ID0ge307XG4gIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgb2JqZWN0W2tdID0gdjtcbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8vIE5vdGU6IGFsbCBvZiB0aGVzZSBtZXRob2RzIGFyZSBkZXByZWNhdGVkLlxuQ29sbGVjdGlvbi5pc0l0ZXJhYmxlID0gaXNDb2xsZWN0aW9uO1xuQ29sbGVjdGlvbi5pc0tleWVkID0gaXNLZXllZDtcbkNvbGxlY3Rpb24uaXNJbmRleGVkID0gaXNJbmRleGVkO1xuQ29sbGVjdGlvbi5pc0Fzc29jaWF0aXZlID0gaXNBc3NvY2lhdGl2ZTtcbkNvbGxlY3Rpb24uaXNPcmRlcmVkID0gaXNPcmRlcmVkO1xuXG5Db2xsZWN0aW9uLkl0ZXJhdG9yID0gSXRlcmF0b3I7XG5cbm1peGluKENvbGxlY3Rpb24sIHtcbiAgLy8gIyMjIENvbnZlcnNpb24gdG8gb3RoZXIgdHlwZXNcblxuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHRoaXMuc2l6ZSB8fCAwKTtcbiAgICB2YXIgdXNlVHVwbGVzID0gaXNLZXllZCh0aGlzKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIC8vIEtleWVkIGNvbGxlY3Rpb25zIHByb2R1Y2UgYW4gYXJyYXkgb2YgdHVwbGVzLlxuICAgICAgYXJyYXlbaSsrXSA9IHVzZVR1cGxlcyA/IFtrLCB2XSA6IHY7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuXG4gIHRvSW5kZXhlZFNlcTogZnVuY3Rpb24gdG9JbmRleGVkU2VxKCkge1xuICAgIHJldHVybiBuZXcgVG9JbmRleGVkU2VxdWVuY2UodGhpcyk7XG4gIH0sXG5cbiAgdG9KUzogZnVuY3Rpb24gdG9KUyQxKCkge1xuICAgIHJldHVybiB0b0pTKHRoaXMpO1xuICB9LFxuXG4gIHRvS2V5ZWRTZXE6IGZ1bmN0aW9uIHRvS2V5ZWRTZXEoKSB7XG4gICAgcmV0dXJuIG5ldyBUb0tleWVkU2VxdWVuY2UodGhpcywgdHJ1ZSk7XG4gIH0sXG5cbiAgdG9NYXA6IGZ1bmN0aW9uIHRvTWFwKCkge1xuICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICByZXR1cm4gTWFwKHRoaXMudG9LZXllZFNlcSgpKTtcbiAgfSxcblxuICB0b09iamVjdDogdG9PYmplY3QsXG5cbiAgdG9PcmRlcmVkTWFwOiBmdW5jdGlvbiB0b09yZGVyZWRNYXAoKSB7XG4gICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgIHJldHVybiBPcmRlcmVkTWFwKHRoaXMudG9LZXllZFNlcSgpKTtcbiAgfSxcblxuICB0b09yZGVyZWRTZXQ6IGZ1bmN0aW9uIHRvT3JkZXJlZFNldCgpIHtcbiAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgcmV0dXJuIE9yZGVyZWRTZXQoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICB9LFxuXG4gIHRvU2V0OiBmdW5jdGlvbiB0b1NldCgpIHtcbiAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgcmV0dXJuIFNldChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gIH0sXG5cbiAgdG9TZXRTZXE6IGZ1bmN0aW9uIHRvU2V0U2VxKCkge1xuICAgIHJldHVybiBuZXcgVG9TZXRTZXF1ZW5jZSh0aGlzKTtcbiAgfSxcblxuICB0b1NlcTogZnVuY3Rpb24gdG9TZXEoKSB7XG4gICAgcmV0dXJuIGlzSW5kZXhlZCh0aGlzKVxuICAgICAgPyB0aGlzLnRvSW5kZXhlZFNlcSgpXG4gICAgICA6IGlzS2V5ZWQodGhpcylcbiAgICAgID8gdGhpcy50b0tleWVkU2VxKClcbiAgICAgIDogdGhpcy50b1NldFNlcSgpO1xuICB9LFxuXG4gIHRvU3RhY2s6IGZ1bmN0aW9uIHRvU3RhY2soKSB7XG4gICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgIHJldHVybiBTdGFjayhpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gIH0sXG5cbiAgdG9MaXN0OiBmdW5jdGlvbiB0b0xpc3QoKSB7XG4gICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgIHJldHVybiBMaXN0KGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgfSxcblxuICAvLyAjIyMgQ29tbW9uIEphdmFTY3JpcHQgbWV0aG9kcyBhbmQgcHJvcGVydGllc1xuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tDb2xsZWN0aW9uXSc7XG4gIH0sXG5cbiAgX190b1N0cmluZzogZnVuY3Rpb24gX190b1N0cmluZyhoZWFkLCB0YWlsKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgaGVhZCArXG4gICAgICAnICcgK1xuICAgICAgdGhpcy50b1NlcSgpLm1hcCh0aGlzLl9fdG9TdHJpbmdNYXBwZXIpLmpvaW4oJywgJykgK1xuICAgICAgJyAnICtcbiAgICAgIHRhaWxcbiAgICApO1xuICB9LFxuXG4gIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgdmFsdWVzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIHZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGNvbmNhdEZhY3RvcnkodGhpcywgdmFsdWVzKSk7XG4gIH0sXG5cbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzKHZhbHVlLCBzZWFyY2hWYWx1ZSk7IH0pO1xuICB9LFxuXG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMpO1xuICB9LFxuXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgIGlmICghcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfSxcblxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmlsdGVyRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcbiAgfSxcblxuICBwYXJ0aXRpb246IGZ1bmN0aW9uIHBhcnRpdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcGFydGl0aW9uRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICB9LFxuXG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMV0gOiBub3RTZXRWYWx1ZTtcbiAgfSxcblxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKHNpZGVFZmZlY3QsIGNvbnRleHQpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgIHJldHVybiB0aGlzLl9faXRlcmF0ZShjb250ZXh0ID8gc2lkZUVmZmVjdC5iaW5kKGNvbnRleHQpIDogc2lkZUVmZmVjdCk7XG4gIH0sXG5cbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gJycgKyBzZXBhcmF0b3IgOiAnLCc7XG4gICAgdmFyIGpvaW5lZCA9ICcnO1xuICAgIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodikge1xuICAgICAgaXNGaXJzdCA/IChpc0ZpcnN0ID0gZmFsc2UpIDogKGpvaW5lZCArPSBzZXBhcmF0b3IpO1xuICAgICAgam9pbmVkICs9IHYgIT09IG51bGwgJiYgdiAhPT0gdW5kZWZpbmVkID8gdi50b1N0cmluZygpIDogJyc7XG4gICAgfSk7XG4gICAgcmV0dXJuIGpvaW5lZDtcbiAgfSxcblxuICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9LRVlTKTtcbiAgfSxcblxuICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgbWFwRmFjdG9yeSh0aGlzLCBtYXBwZXIsIGNvbnRleHQpKTtcbiAgfSxcblxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZSQxKHJlZHVjZXIsIGluaXRpYWxSZWR1Y3Rpb24sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVkdWNlKFxuICAgICAgdGhpcyxcbiAgICAgIHJlZHVjZXIsXG4gICAgICBpbml0aWFsUmVkdWN0aW9uLFxuICAgICAgY29udGV4dCxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPCAyLFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9LFxuXG4gIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChyZWR1Y2VyLCBpbml0aWFsUmVkdWN0aW9uLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlZHVjZShcbiAgICAgIHRoaXMsXG4gICAgICByZWR1Y2VyLFxuICAgICAgaW5pdGlhbFJlZHVjdGlvbixcbiAgICAgIGNvbnRleHQsXG4gICAgICBhcmd1bWVudHMubGVuZ3RoIDwgMixcbiAgICAgIHRydWVcbiAgICApO1xuICB9LFxuXG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHJldmVyc2VGYWN0b3J5KHRoaXMsIHRydWUpKTtcbiAgfSxcblxuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBzbGljZUZhY3RvcnkodGhpcywgYmVnaW4sIGVuZCwgdHJ1ZSkpO1xuICB9LFxuXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaywgYykge1xuICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfSxcblxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvcikpO1xuICB9LFxuXG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMpO1xuICB9LFxuXG4gIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG4gIGJ1dExhc3Q6IGZ1bmN0aW9uIGJ1dExhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgLTEpO1xuICB9LFxuXG4gIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5zaXplID09PSAwIDogIXRoaXMuc29tZShmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcbiAgfSxcblxuICBjb3VudDogZnVuY3Rpb24gY291bnQocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGVuc3VyZVNpemUoXG4gICAgICBwcmVkaWNhdGUgPyB0aGlzLnRvU2VxKCkuZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCkgOiB0aGlzXG4gICAgKTtcbiAgfSxcblxuICBjb3VudEJ5OiBmdW5jdGlvbiBjb3VudEJ5KGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY291bnRCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gZGVlcEVxdWFsKHRoaXMsIG90aGVyKTtcbiAgfSxcblxuICBlbnRyeVNlcTogZnVuY3Rpb24gZW50cnlTZXEoKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xuICAgIGlmIChjb2xsZWN0aW9uLl9jYWNoZSkge1xuICAgICAgLy8gV2UgY2FjaGUgYXMgYW4gZW50cmllcyBhcnJheSwgc28gd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBjYWNoZSFcbiAgICAgIHJldHVybiBuZXcgQXJyYXlTZXEoY29sbGVjdGlvbi5fY2FjaGUpO1xuICAgIH1cbiAgICB2YXIgZW50cmllc1NlcXVlbmNlID0gY29sbGVjdGlvbi50b1NlcSgpLm1hcChlbnRyeU1hcHBlcikudG9JbmRleGVkU2VxKCk7XG4gICAgZW50cmllc1NlcXVlbmNlLmZyb21FbnRyeVNlcSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb24udG9TZXEoKTsgfTtcbiAgICByZXR1cm4gZW50cmllc1NlcXVlbmNlO1xuICB9LFxuXG4gIGZpbHRlck5vdDogZnVuY3Rpb24gZmlsdGVyTm90KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gIH0sXG5cbiAgZmluZEVudHJ5OiBmdW5jdGlvbiBmaW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgIHZhciBmb3VuZCA9IG5vdFNldFZhbHVlO1xuICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgZm91bmQgPSBbaywgdl07XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH0sXG5cbiAgZmluZEtleTogZnVuY3Rpb24gZmluZEtleShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXTtcbiAgfSxcblxuICBmaW5kTGFzdDogZnVuY3Rpb24gZmluZExhc3QocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKTtcbiAgfSxcblxuICBmaW5kTGFzdEVudHJ5OiBmdW5jdGlvbiBmaW5kTGFzdEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgZmluZExhc3RLZXk6IGZ1bmN0aW9uIGZpbmRMYXN0S2V5KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkuZmluZEtleShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICB9LFxuXG4gIGZpcnN0OiBmdW5jdGlvbiBmaXJzdChub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmZpbmQocmV0dXJuVHJ1ZSwgbnVsbCwgbm90U2V0VmFsdWUpO1xuICB9LFxuXG4gIGZsYXRNYXA6IGZ1bmN0aW9uIGZsYXRNYXAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsYXRNYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCkpO1xuICB9LFxuXG4gIGZsYXR0ZW46IGZ1bmN0aW9uIGZsYXR0ZW4oZGVwdGgpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdHRlbkZhY3RvcnkodGhpcywgZGVwdGgsIHRydWUpKTtcbiAgfSxcblxuICBmcm9tRW50cnlTZXE6IGZ1bmN0aW9uIGZyb21FbnRyeVNlcSgpIHtcbiAgICByZXR1cm4gbmV3IEZyb21FbnRyaWVzU2VxdWVuY2UodGhpcyk7XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbiBnZXQoc2VhcmNoS2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmZpbmQoZnVuY3Rpb24gKF8sIGtleSkgeyByZXR1cm4gaXMoa2V5LCBzZWFyY2hLZXkpOyB9LCB1bmRlZmluZWQsIG5vdFNldFZhbHVlKTtcbiAgfSxcblxuICBnZXRJbjogZ2V0SW4sXG5cbiAgZ3JvdXBCeTogZnVuY3Rpb24gZ3JvdXBCeShncm91cGVyLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGdyb3VwQnlGYWN0b3J5KHRoaXMsIGdyb3VwZXIsIGNvbnRleHQpO1xuICB9LFxuXG4gIGhhczogZnVuY3Rpb24gaGFzKHNlYXJjaEtleSkge1xuICAgIHJldHVybiB0aGlzLmdldChzZWFyY2hLZXksIE5PVF9TRVQpICE9PSBOT1RfU0VUO1xuICB9LFxuXG4gIGhhc0luOiBoYXNJbixcblxuICBpc1N1YnNldDogZnVuY3Rpb24gaXNTdWJzZXQoaXRlcikge1xuICAgIGl0ZXIgPSB0eXBlb2YgaXRlci5pbmNsdWRlcyA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZXIgOiBDb2xsZWN0aW9uKGl0ZXIpO1xuICAgIHJldHVybiB0aGlzLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSk7IH0pO1xuICB9LFxuXG4gIGlzU3VwZXJzZXQ6IGZ1bmN0aW9uIGlzU3VwZXJzZXQoaXRlcikge1xuICAgIGl0ZXIgPSB0eXBlb2YgaXRlci5pc1N1YnNldCA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZXIgOiBDb2xsZWN0aW9uKGl0ZXIpO1xuICAgIHJldHVybiBpdGVyLmlzU3Vic2V0KHRoaXMpO1xuICB9LFxuXG4gIGtleU9mOiBmdW5jdGlvbiBrZXlPZihzZWFyY2hWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmZpbmRLZXkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpcyh2YWx1ZSwgc2VhcmNoVmFsdWUpOyB9KTtcbiAgfSxcblxuICBrZXlTZXE6IGZ1bmN0aW9uIGtleVNlcSgpIHtcbiAgICByZXR1cm4gdGhpcy50b1NlcSgpLm1hcChrZXlNYXBwZXIpLnRvSW5kZXhlZFNlcSgpO1xuICB9LFxuXG4gIGxhc3Q6IGZ1bmN0aW9uIGxhc3Qobm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50b1NlcSgpLnJldmVyc2UoKS5maXJzdChub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgbGFzdEtleU9mOiBmdW5jdGlvbiBsYXN0S2V5T2Yoc2VhcmNoVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpLmtleU9mKHNlYXJjaFZhbHVlKTtcbiAgfSxcblxuICBtYXg6IGZ1bmN0aW9uIG1heChjb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIG1heEZhY3RvcnkodGhpcywgY29tcGFyYXRvcik7XG4gIH0sXG5cbiAgbWF4Qnk6IGZ1bmN0aW9uIG1heEJ5KG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcik7XG4gIH0sXG5cbiAgbWluOiBmdW5jdGlvbiBtaW4oY29tcGFyYXRvcikge1xuICAgIHJldHVybiBtYXhGYWN0b3J5KFxuICAgICAgdGhpcyxcbiAgICAgIGNvbXBhcmF0b3IgPyBuZWcoY29tcGFyYXRvcikgOiBkZWZhdWx0TmVnQ29tcGFyYXRvclxuICAgICk7XG4gIH0sXG5cbiAgbWluQnk6IGZ1bmN0aW9uIG1pbkJ5KG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgIHJldHVybiBtYXhGYWN0b3J5KFxuICAgICAgdGhpcyxcbiAgICAgIGNvbXBhcmF0b3IgPyBuZWcoY29tcGFyYXRvcikgOiBkZWZhdWx0TmVnQ29tcGFyYXRvcixcbiAgICAgIG1hcHBlclxuICAgICk7XG4gIH0sXG5cbiAgcmVzdDogZnVuY3Rpb24gcmVzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgxKTtcbiAgfSxcblxuICBza2lwOiBmdW5jdGlvbiBza2lwKGFtb3VudCkge1xuICAgIHJldHVybiBhbW91bnQgPT09IDAgPyB0aGlzIDogdGhpcy5zbGljZShNYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgfSxcblxuICBza2lwTGFzdDogZnVuY3Rpb24gc2tpcExhc3QoYW1vdW50KSB7XG4gICAgcmV0dXJuIGFtb3VudCA9PT0gMCA/IHRoaXMgOiB0aGlzLnNsaWNlKDAsIC1NYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgfSxcblxuICBza2lwV2hpbGU6IGZ1bmN0aW9uIHNraXBXaGlsZShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgc2tpcFdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcbiAgfSxcblxuICBza2lwVW50aWw6IGZ1bmN0aW9uIHNraXBVbnRpbChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5za2lwV2hpbGUobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICB9LFxuXG4gIHNvcnRCeTogZnVuY3Rpb24gc29ydEJ5KG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcbiAgfSxcblxuICB0YWtlOiBmdW5jdGlvbiB0YWtlKGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIE1hdGgubWF4KDAsIGFtb3VudCkpO1xuICB9LFxuXG4gIHRha2VMYXN0OiBmdW5jdGlvbiB0YWtlTGFzdChhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgtTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gIH0sXG5cbiAgdGFrZVdoaWxlOiBmdW5jdGlvbiB0YWtlV2hpbGUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHRha2VXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KSk7XG4gIH0sXG5cbiAgdGFrZVVudGlsOiBmdW5jdGlvbiB0YWtlVW50aWwocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMudGFrZVdoaWxlKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShmbikge1xuICAgIHJldHVybiBmbih0aGlzKTtcbiAgfSxcblxuICB2YWx1ZVNlcTogZnVuY3Rpb24gdmFsdWVTZXEoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JbmRleGVkU2VxKCk7XG4gIH0sXG5cbiAgLy8gIyMjIEhhc2hhYmxlIE9iamVjdFxuXG4gIGhhc2hDb2RlOiBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2hhc2ggfHwgKHRoaXMuX19oYXNoID0gaGFzaENvbGxlY3Rpb24odGhpcykpO1xuICB9LFxuXG4gIC8vICMjIyBJbnRlcm5hbFxuXG4gIC8vIGFic3RyYWN0IF9faXRlcmF0ZShmbiwgcmV2ZXJzZSlcblxuICAvLyBhYnN0cmFjdCBfX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpXG59KTtcblxudmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbkNvbGxlY3Rpb25Qcm90b3R5cGVbSVNfQ09MTEVDVElPTl9TWU1CT0xdID0gdHJ1ZTtcbkNvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IENvbGxlY3Rpb25Qcm90b3R5cGUudmFsdWVzO1xuQ29sbGVjdGlvblByb3RvdHlwZS50b0pTT04gPSBDb2xsZWN0aW9uUHJvdG90eXBlLnRvQXJyYXk7XG5Db2xsZWN0aW9uUHJvdG90eXBlLl9fdG9TdHJpbmdNYXBwZXIgPSBxdW90ZVN0cmluZztcbkNvbGxlY3Rpb25Qcm90b3R5cGUuaW5zcGVjdCA9IENvbGxlY3Rpb25Qcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG59O1xuQ29sbGVjdGlvblByb3RvdHlwZS5jaGFpbiA9IENvbGxlY3Rpb25Qcm90b3R5cGUuZmxhdE1hcDtcbkNvbGxlY3Rpb25Qcm90b3R5cGUuY29udGFpbnMgPSBDb2xsZWN0aW9uUHJvdG90eXBlLmluY2x1ZGVzO1xuXG5taXhpbihLZXllZENvbGxlY3Rpb24sIHtcbiAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cbiAgZmxpcDogZnVuY3Rpb24gZmxpcCgpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmxpcEZhY3RvcnkodGhpcykpO1xuICB9LFxuXG4gIG1hcEVudHJpZXM6IGZ1bmN0aW9uIG1hcEVudHJpZXMobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIHRoaXMkMSQxID0gdGhpcztcblxuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICByZXR1cm4gcmVpZnkoXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy50b1NlcSgpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIG1hcHBlci5jYWxsKGNvbnRleHQsIFtrLCB2XSwgaXRlcmF0aW9ucysrLCB0aGlzJDEkMSk7IH0pXG4gICAgICAgIC5mcm9tRW50cnlTZXEoKVxuICAgICk7XG4gIH0sXG5cbiAgbWFwS2V5czogZnVuY3Rpb24gbWFwS2V5cyhtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgdGhpcyQxJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHJlaWZ5KFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMudG9TZXEoKVxuICAgICAgICAuZmxpcCgpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGssIHYpIHsgcmV0dXJuIG1hcHBlci5jYWxsKGNvbnRleHQsIGssIHYsIHRoaXMkMSQxKTsgfSlcbiAgICAgICAgLmZsaXAoKVxuICAgICk7XG4gIH0sXG59KTtcblxudmFyIEtleWVkQ29sbGVjdGlvblByb3RvdHlwZSA9IEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGU7XG5LZXllZENvbGxlY3Rpb25Qcm90b3R5cGVbSVNfS0VZRURfU1lNQk9MXSA9IHRydWU7XG5LZXllZENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IENvbGxlY3Rpb25Qcm90b3R5cGUuZW50cmllcztcbktleWVkQ29sbGVjdGlvblByb3RvdHlwZS50b0pTT04gPSB0b09iamVjdDtcbktleWVkQ29sbGVjdGlvblByb3RvdHlwZS5fX3RvU3RyaW5nTWFwcGVyID0gZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIHF1b3RlU3RyaW5nKGspICsgJzogJyArIHF1b3RlU3RyaW5nKHYpOyB9O1xuXG5taXhpbihJbmRleGVkQ29sbGVjdGlvbiwge1xuICAvLyAjIyMgQ29udmVyc2lvbiB0byBvdGhlciB0eXBlc1xuXG4gIHRvS2V5ZWRTZXE6IGZ1bmN0aW9uIHRvS2V5ZWRTZXEoKSB7XG4gICAgcmV0dXJuIG5ldyBUb0tleWVkU2VxdWVuY2UodGhpcywgZmFsc2UpO1xuICB9LFxuXG4gIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmlsdGVyRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIGZhbHNlKSk7XG4gIH0sXG5cbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gZW50cnkgPyBlbnRyeVswXSA6IC0xO1xuICB9LFxuXG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoVmFsdWUpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXlPZihzZWFyY2hWYWx1ZSk7XG4gICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID8gLTEgOiBrZXk7XG4gIH0sXG5cbiAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaFZhbHVlKSB7XG4gICAgdmFyIGtleSA9IHRoaXMubGFzdEtleU9mKHNlYXJjaFZhbHVlKTtcbiAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgPyAtMSA6IGtleTtcbiAgfSxcblxuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCByZXZlcnNlRmFjdG9yeSh0aGlzLCBmYWxzZSkpO1xuICB9LFxuXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNsaWNlRmFjdG9yeSh0aGlzLCBiZWdpbiwgZW5kLCBmYWxzZSkpO1xuICB9LFxuXG4gIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKGluZGV4LCByZW1vdmVOdW0gLyosIC4uLnZhbHVlcyovKSB7XG4gICAgdmFyIG51bUFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJlbW92ZU51bSA9IE1hdGgubWF4KHJlbW92ZU51bSB8fCAwLCAwKTtcbiAgICBpZiAobnVtQXJncyA9PT0gMCB8fCAobnVtQXJncyA9PT0gMiAmJiAhcmVtb3ZlTnVtKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIElmIGluZGV4IGlzIG5lZ2F0aXZlLCBpdCBzaG91bGQgcmVzb2x2ZSByZWxhdGl2ZSB0byB0aGUgc2l6ZSBvZiB0aGVcbiAgICAvLyBjb2xsZWN0aW9uLiBIb3dldmVyIHNpemUgbWF5IGJlIGV4cGVuc2l2ZSB0byBjb21wdXRlIGlmIG5vdCBjYWNoZWQsIHNvXG4gICAgLy8gb25seSBjYWxsIGNvdW50KCkgaWYgdGhlIG51bWJlciBpcyBpbiBmYWN0IG5lZ2F0aXZlLlxuICAgIGluZGV4ID0gcmVzb2x2ZUJlZ2luKGluZGV4LCBpbmRleCA8IDAgPyB0aGlzLmNvdW50KCkgOiB0aGlzLnNpemUpO1xuICAgIHZhciBzcGxpY2VkID0gdGhpcy5zbGljZSgwLCBpbmRleCk7XG4gICAgcmV0dXJuIHJlaWZ5KFxuICAgICAgdGhpcyxcbiAgICAgIG51bUFyZ3MgPT09IDFcbiAgICAgICAgPyBzcGxpY2VkXG4gICAgICAgIDogc3BsaWNlZC5jb25jYXQoYXJyQ29weShhcmd1bWVudHMsIDIpLCB0aGlzLnNsaWNlKGluZGV4ICsgcmVtb3ZlTnVtKSlcbiAgICApO1xuICB9LFxuXG4gIC8vICMjIyBNb3JlIGNvbGxlY3Rpb24gbWV0aG9kc1xuXG4gIGZpbmRMYXN0SW5kZXg6IGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kTGFzdEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMF0gOiAtMTtcbiAgfSxcblxuICBmaXJzdDogZnVuY3Rpb24gZmlyc3Qobm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoMCwgbm90U2V0VmFsdWUpO1xuICB9LFxuXG4gIGZsYXR0ZW46IGZ1bmN0aW9uIGZsYXR0ZW4oZGVwdGgpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdHRlbkZhY3RvcnkodGhpcywgZGVwdGgsIGZhbHNlKSk7XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbiBnZXQoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgIHJldHVybiBpbmRleCA8IDAgfHxcbiAgICAgIHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHxcbiAgICAgICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZCAmJiBpbmRleCA+IHRoaXMuc2l6ZSlcbiAgICAgID8gbm90U2V0VmFsdWVcbiAgICAgIDogdGhpcy5maW5kKGZ1bmN0aW9uIChfLCBrZXkpIHsgcmV0dXJuIGtleSA9PT0gaW5kZXg7IH0sIHVuZGVmaW5lZCwgbm90U2V0VmFsdWUpO1xuICB9LFxuXG4gIGhhczogZnVuY3Rpb24gaGFzKGluZGV4KSB7XG4gICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgIHJldHVybiAoXG4gICAgICBpbmRleCA+PSAwICYmXG4gICAgICAodGhpcy5zaXplICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyB0aGlzLnNpemUgPT09IEluZmluaXR5IHx8IGluZGV4IDwgdGhpcy5zaXplXG4gICAgICAgIDogdGhpcy5pbmRleE9mKGluZGV4KSAhPT0gLTEpXG4gICAgKTtcbiAgfSxcblxuICBpbnRlcnBvc2U6IGZ1bmN0aW9uIGludGVycG9zZShzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgaW50ZXJwb3NlRmFjdG9yeSh0aGlzLCBzZXBhcmF0b3IpKTtcbiAgfSxcblxuICBpbnRlcmxlYXZlOiBmdW5jdGlvbiBpbnRlcmxlYXZlKC8qLi4uY29sbGVjdGlvbnMqLykge1xuICAgIHZhciBjb2xsZWN0aW9ucyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcbiAgICB2YXIgemlwcGVkID0gemlwV2l0aEZhY3RvcnkodGhpcy50b1NlcSgpLCBJbmRleGVkU2VxLm9mLCBjb2xsZWN0aW9ucyk7XG4gICAgdmFyIGludGVybGVhdmVkID0gemlwcGVkLmZsYXR0ZW4odHJ1ZSk7XG4gICAgaWYgKHppcHBlZC5zaXplKSB7XG4gICAgICBpbnRlcmxlYXZlZC5zaXplID0gemlwcGVkLnNpemUgKiBjb2xsZWN0aW9ucy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZWlmeSh0aGlzLCBpbnRlcmxlYXZlZCk7XG4gIH0sXG5cbiAga2V5U2VxOiBmdW5jdGlvbiBrZXlTZXEoKSB7XG4gICAgcmV0dXJuIFJhbmdlKDAsIHRoaXMuc2l6ZSk7XG4gIH0sXG5cbiAgbGFzdDogZnVuY3Rpb24gbGFzdChub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldCgtMSwgbm90U2V0VmFsdWUpO1xuICB9LFxuXG4gIHNraXBXaGlsZTogZnVuY3Rpb24gc2tpcFdoaWxlKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBza2lwV2hpbGVGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgZmFsc2UpKTtcbiAgfSxcblxuICB6aXA6IGZ1bmN0aW9uIHppcCgvKiwgLi4uY29sbGVjdGlvbnMgKi8pIHtcbiAgICB2YXIgY29sbGVjdGlvbnMgPSBbdGhpc10uY29uY2F0KGFyckNvcHkoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHppcFdpdGhGYWN0b3J5KHRoaXMsIGRlZmF1bHRaaXBwZXIsIGNvbGxlY3Rpb25zKSk7XG4gIH0sXG5cbiAgemlwQWxsOiBmdW5jdGlvbiB6aXBBbGwoLyosIC4uLmNvbGxlY3Rpb25zICovKSB7XG4gICAgdmFyIGNvbGxlY3Rpb25zID0gW3RoaXNdLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cykpO1xuICAgIHJldHVybiByZWlmeSh0aGlzLCB6aXBXaXRoRmFjdG9yeSh0aGlzLCBkZWZhdWx0WmlwcGVyLCBjb2xsZWN0aW9ucywgdHJ1ZSkpO1xuICB9LFxuXG4gIHppcFdpdGg6IGZ1bmN0aW9uIHppcFdpdGgoemlwcGVyIC8qLCAuLi5jb2xsZWN0aW9ucyAqLykge1xuICAgIHZhciBjb2xsZWN0aW9ucyA9IGFyckNvcHkoYXJndW1lbnRzKTtcbiAgICBjb2xsZWN0aW9uc1swXSA9IHRoaXM7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHppcFdpdGhGYWN0b3J5KHRoaXMsIHppcHBlciwgY29sbGVjdGlvbnMpKTtcbiAgfSxcbn0pO1xuXG52YXIgSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGUgPSBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGU7XG5JbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZVtJU19JTkRFWEVEX1NZTUJPTF0gPSB0cnVlO1xuSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcblxubWl4aW4oU2V0Q29sbGVjdGlvbiwge1xuICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgZ2V0OiBmdW5jdGlvbiBnZXQodmFsdWUsIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKHZhbHVlKSA/IHZhbHVlIDogbm90U2V0VmFsdWU7XG4gIH0sXG5cbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKHZhbHVlKTtcbiAgfSxcblxuICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICBrZXlTZXE6IGZ1bmN0aW9uIGtleVNlcSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVNlcSgpO1xuICB9LFxufSk7XG5cbnZhciBTZXRDb2xsZWN0aW9uUHJvdG90eXBlID0gU2V0Q29sbGVjdGlvbi5wcm90b3R5cGU7XG5TZXRDb2xsZWN0aW9uUHJvdG90eXBlLmhhcyA9IENvbGxlY3Rpb25Qcm90b3R5cGUuaW5jbHVkZXM7XG5TZXRDb2xsZWN0aW9uUHJvdG90eXBlLmNvbnRhaW5zID0gU2V0Q29sbGVjdGlvblByb3RvdHlwZS5pbmNsdWRlcztcblNldENvbGxlY3Rpb25Qcm90b3R5cGUua2V5cyA9IFNldENvbGxlY3Rpb25Qcm90b3R5cGUudmFsdWVzO1xuXG4vLyBNaXhpbiBzdWJjbGFzc2VzXG5cbm1peGluKEtleWVkU2VxLCBLZXllZENvbGxlY3Rpb25Qcm90b3R5cGUpO1xubWl4aW4oSW5kZXhlZFNlcSwgSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGUpO1xubWl4aW4oU2V0U2VxLCBTZXRDb2xsZWN0aW9uUHJvdG90eXBlKTtcblxuLy8gI3ByYWdtYSBIZWxwZXIgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCByZWR1Y2VyLCByZWR1Y3Rpb24sIGNvbnRleHQsIHVzZUZpcnN0LCByZXZlcnNlKSB7XG4gIGFzc2VydE5vdEluZmluaXRlKGNvbGxlY3Rpb24uc2l6ZSk7XG4gIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgaWYgKHVzZUZpcnN0KSB7XG4gICAgICB1c2VGaXJzdCA9IGZhbHNlO1xuICAgICAgcmVkdWN0aW9uID0gdjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkdWN0aW9uID0gcmVkdWNlci5jYWxsKGNvbnRleHQsIHJlZHVjdGlvbiwgdiwgaywgYyk7XG4gICAgfVxuICB9LCByZXZlcnNlKTtcbiAgcmV0dXJuIHJlZHVjdGlvbjtcbn1cblxuZnVuY3Rpb24ga2V5TWFwcGVyKHYsIGspIHtcbiAgcmV0dXJuIGs7XG59XG5cbmZ1bmN0aW9uIGVudHJ5TWFwcGVyKHYsIGspIHtcbiAgcmV0dXJuIFtrLCB2XTtcbn1cblxuZnVuY3Rpb24gbm90KHByZWRpY2F0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5lZyhwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gLXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0WmlwcGVyKCkge1xuICByZXR1cm4gYXJyQ29weShhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0TmVnQ29tcGFyYXRvcihhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IDEgOiBhID4gYiA/IC0xIDogMDtcbn1cblxuZnVuY3Rpb24gaGFzaENvbGxlY3Rpb24oY29sbGVjdGlvbikge1xuICBpZiAoY29sbGVjdGlvbi5zaXplID09PSBJbmZpbml0eSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBvcmRlcmVkID0gaXNPcmRlcmVkKGNvbGxlY3Rpb24pO1xuICB2YXIga2V5ZWQgPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICB2YXIgaCA9IG9yZGVyZWQgPyAxIDogMDtcbiAgdmFyIHNpemUgPSBjb2xsZWN0aW9uLl9faXRlcmF0ZShcbiAgICBrZXllZFxuICAgICAgPyBvcmRlcmVkXG4gICAgICAgID8gZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgIGggPSAoMzEgKiBoICsgaGFzaE1lcmdlKGhhc2godiksIGhhc2goaykpKSB8IDA7XG4gICAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICBoID0gKGggKyBoYXNoTWVyZ2UoaGFzaCh2KSwgaGFzaChrKSkpIHwgMDtcbiAgICAgICAgICB9XG4gICAgICA6IG9yZGVyZWRcbiAgICAgID8gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBoID0gKDMxICogaCArIGhhc2godikpIHwgMDtcbiAgICAgICAgfVxuICAgICAgOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgIGggPSAoaCArIGhhc2godikpIHwgMDtcbiAgICAgICAgfVxuICApO1xuICByZXR1cm4gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKTtcbn1cblxuZnVuY3Rpb24gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKSB7XG4gIGggPSBpbXVsKGgsIDB4Y2M5ZTJkNTEpO1xuICBoID0gaW11bCgoaCA8PCAxNSkgfCAoaCA+Pj4gLTE1KSwgMHgxYjg3MzU5Myk7XG4gIGggPSBpbXVsKChoIDw8IDEzKSB8IChoID4+PiAtMTMpLCA1KTtcbiAgaCA9ICgoaCArIDB4ZTY1NDZiNjQpIHwgMCkgXiBzaXplO1xuICBoID0gaW11bChoIF4gKGggPj4+IDE2KSwgMHg4NWViY2E2Yik7XG4gIGggPSBpbXVsKGggXiAoaCA+Pj4gMTMpLCAweGMyYjJhZTM1KTtcbiAgaCA9IHNtaShoIF4gKGggPj4+IDE2KSk7XG4gIHJldHVybiBoO1xufVxuXG5mdW5jdGlvbiBoYXNoTWVyZ2UoYSwgYikge1xuICByZXR1cm4gKGEgXiAoYiArIDB4OWUzNzc5YjkgKyAoYSA8PCA2KSArIChhID4+IDIpKSkgfCAwOyAvLyBpbnRcbn1cblxudmFyIE9yZGVyZWRTZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXQpIHtcbiAgZnVuY3Rpb24gT3JkZXJlZFNldCh2YWx1ZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbFxuICAgICAgPyBlbXB0eU9yZGVyZWRTZXQoKVxuICAgICAgOiBpc09yZGVyZWRTZXQodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6IGVtcHR5T3JkZXJlZFNldCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgIHZhciBpdGVyID0gU2V0Q29sbGVjdGlvbih2YWx1ZSk7XG4gICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHNldC5hZGQodik7IH0pO1xuICAgICAgICB9KTtcbiAgfVxuXG4gIGlmICggU2V0ICkgT3JkZXJlZFNldC5fX3Byb3RvX18gPSBTZXQ7XG4gIE9yZGVyZWRTZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2V0ICYmIFNldC5wcm90b3R5cGUgKTtcbiAgT3JkZXJlZFNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPcmRlcmVkU2V0O1xuXG4gIE9yZGVyZWRTZXQub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgT3JkZXJlZFNldC5mcm9tS2V5cyA9IGZ1bmN0aW9uIGZyb21LZXlzICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzKEtleWVkQ29sbGVjdGlvbih2YWx1ZSkua2V5U2VxKCkpO1xuICB9O1xuXG4gIE9yZGVyZWRTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ09yZGVyZWRTZXQgeycsICd9Jyk7XG4gIH07XG5cbiAgcmV0dXJuIE9yZGVyZWRTZXQ7XG59KFNldCkpO1xuXG5PcmRlcmVkU2V0LmlzT3JkZXJlZFNldCA9IGlzT3JkZXJlZFNldDtcblxudmFyIE9yZGVyZWRTZXRQcm90b3R5cGUgPSBPcmRlcmVkU2V0LnByb3RvdHlwZTtcbk9yZGVyZWRTZXRQcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcbk9yZGVyZWRTZXRQcm90b3R5cGUuemlwID0gSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGUuemlwO1xuT3JkZXJlZFNldFByb3RvdHlwZS56aXBXaXRoID0gSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGUuemlwV2l0aDtcbk9yZGVyZWRTZXRQcm90b3R5cGUuemlwQWxsID0gSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGUuemlwQWxsO1xuXG5PcmRlcmVkU2V0UHJvdG90eXBlLl9fZW1wdHkgPSBlbXB0eU9yZGVyZWRTZXQ7XG5PcmRlcmVkU2V0UHJvdG90eXBlLl9fbWFrZSA9IG1ha2VPcmRlcmVkU2V0O1xuXG5mdW5jdGlvbiBtYWtlT3JkZXJlZFNldChtYXAsIG93bmVySUQpIHtcbiAgdmFyIHNldCA9IE9iamVjdC5jcmVhdGUoT3JkZXJlZFNldFByb3RvdHlwZSk7XG4gIHNldC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICBzZXQuX21hcCA9IG1hcDtcbiAgc2V0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gIHJldHVybiBzZXQ7XG59XG5cbnZhciBFTVBUWV9PUkRFUkVEX1NFVDtcbmZ1bmN0aW9uIGVtcHR5T3JkZXJlZFNldCgpIHtcbiAgcmV0dXJuIChcbiAgICBFTVBUWV9PUkRFUkVEX1NFVCB8fCAoRU1QVFlfT1JERVJFRF9TRVQgPSBtYWtlT3JkZXJlZFNldChlbXB0eU9yZGVyZWRNYXAoKSkpXG4gICk7XG59XG5cbnZhciBQYWlyU29ydGluZyA9IHtcbiAgTGVmdFRoZW5SaWdodDogLTEsXG4gIFJpZ2h0VGhlbkxlZnQ6ICsxLFxufTtcblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWREZWZhdWx0VmFsdWVzKGRlZmF1bHRWYWx1ZXMpIHtcbiAgaWYgKGlzUmVjb3JkKGRlZmF1bHRWYWx1ZXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0NhbiBub3QgY2FsbCBgUmVjb3JkYCB3aXRoIGFuIGltbXV0YWJsZSBSZWNvcmQgYXMgZGVmYXVsdCB2YWx1ZXMuIFVzZSBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IGluc3RlYWQuJ1xuICAgICk7XG4gIH1cblxuICBpZiAoaXNJbW11dGFibGUoZGVmYXVsdFZhbHVlcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2FuIG5vdCBjYWxsIGBSZWNvcmRgIHdpdGggYW4gaW1tdXRhYmxlIENvbGxlY3Rpb24gYXMgZGVmYXVsdCB2YWx1ZXMuIFVzZSBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IGluc3RlYWQuJ1xuICAgICk7XG4gIH1cblxuICBpZiAoZGVmYXVsdFZhbHVlcyA9PT0gbnVsbCB8fCB0eXBlb2YgZGVmYXVsdFZhbHVlcyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2FuIG5vdCBjYWxsIGBSZWNvcmRgIHdpdGggYSBub24tb2JqZWN0IGFzIGRlZmF1bHQgdmFsdWVzLiBVc2UgYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCBpbnN0ZWFkLidcbiAgICApO1xuICB9XG59XG5cbnZhciBSZWNvcmQgPSBmdW5jdGlvbiBSZWNvcmQoZGVmYXVsdFZhbHVlcywgbmFtZSkge1xuICB2YXIgaGFzSW5pdGlhbGl6ZWQ7XG5cbiAgdGhyb3dPbkludmFsaWREZWZhdWx0VmFsdWVzKGRlZmF1bHRWYWx1ZXMpO1xuXG4gIHZhciBSZWNvcmRUeXBlID0gZnVuY3Rpb24gUmVjb3JkKHZhbHVlcykge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUmVjb3JkVHlwZSkge1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlY29yZFR5cGUpKSB7XG4gICAgICByZXR1cm4gbmV3IFJlY29yZFR5cGUodmFsdWVzKTtcbiAgICB9XG4gICAgaWYgKCFoYXNJbml0aWFsaXplZCkge1xuICAgICAgaGFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0VmFsdWVzKTtcbiAgICAgIHZhciBpbmRpY2VzID0gKFJlY29yZFR5cGVQcm90b3R5cGUuX2luZGljZXMgPSB7fSk7XG4gICAgICAvLyBEZXByZWNhdGVkOiBsZWZ0IHRvIGF0dGVtcHQgbm90IHRvIGJyZWFrIGFueSBleHRlcm5hbCBjb2RlIHdoaWNoXG4gICAgICAvLyByZWxpZXMgb24gYSAuX25hbWUgcHJvcGVydHkgZXhpc3Rpbmcgb24gcmVjb3JkIGluc3RhbmNlcy5cbiAgICAgIC8vIFVzZSBSZWNvcmQuZ2V0RGVzY3JpcHRpdmVOYW1lKCkgaW5zdGVhZFxuICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fbmFtZSA9IG5hbWU7XG4gICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9rZXlzID0ga2V5cztcbiAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuX2RlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0VmFsdWVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IGtleXNbaV07XG4gICAgICAgIGluZGljZXNbcHJvcE5hbWVdID0gaTtcbiAgICAgICAgaWYgKFJlY29yZFR5cGVQcm90b3R5cGVbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgIHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICdDYW5ub3QgZGVmaW5lICcgK1xuICAgICAgICAgICAgICAgIHJlY29yZE5hbWUodGhpcykgK1xuICAgICAgICAgICAgICAgICcgd2l0aCBwcm9wZXJ0eSBcIicgK1xuICAgICAgICAgICAgICAgIHByb3BOYW1lICtcbiAgICAgICAgICAgICAgICAnXCIgc2luY2UgdGhhdCBwcm9wZXJ0eSBuYW1lIGlzIHBhcnQgb2YgdGhlIFJlY29yZCBBUEkuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRQcm9wKFJlY29yZFR5cGVQcm90b3R5cGUsIHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9fb3duZXJJRCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZXMgPSBMaXN0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobCkge1xuICAgICAgbC5zZXRTaXplKHRoaXMkMSQxLl9rZXlzLmxlbmd0aCk7XG4gICAgICBLZXllZENvbGxlY3Rpb24odmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIGwuc2V0KHRoaXMkMSQxLl9pbmRpY2VzW2tdLCB2ID09PSB0aGlzJDEkMS5fZGVmYXVsdFZhbHVlc1trXSA/IHVuZGVmaW5lZCA6IHYpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIFJlY29yZFR5cGVQcm90b3R5cGUgPSAoUmVjb3JkVHlwZS5wcm90b3R5cGUgPVxuICAgIE9iamVjdC5jcmVhdGUoUmVjb3JkUHJvdG90eXBlKSk7XG4gIFJlY29yZFR5cGVQcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWNvcmRUeXBlO1xuXG4gIGlmIChuYW1lKSB7XG4gICAgUmVjb3JkVHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gIHJldHVybiBSZWNvcmRUeXBlO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIHN0ciA9IHJlY29yZE5hbWUodGhpcykgKyAnIHsgJztcbiAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICB2YXIgaztcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSAhPT0gbDsgaSsrKSB7XG4gICAgayA9IGtleXNbaV07XG4gICAgc3RyICs9IChpID8gJywgJyA6ICcnKSArIGsgKyAnOiAnICsgcXVvdGVTdHJpbmcodGhpcy5nZXQoaykpO1xuICB9XG4gIHJldHVybiBzdHIgKyAnIH0nO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcyA9PT0gb3RoZXIgfHxcbiAgICAoaXNSZWNvcmQob3RoZXIpICYmIHJlY29yZFNlcSh0aGlzKS5lcXVhbHMocmVjb3JkU2VxKG90aGVyKSkpXG4gICk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUgKCkge1xuICByZXR1cm4gcmVjb3JkU2VxKHRoaXMpLmhhc2hDb2RlKCk7XG59O1xuXG4vLyBAcHJhZ21hIEFjY2Vzc1xuXG5SZWNvcmQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoaykge1xuICByZXR1cm4gdGhpcy5faW5kaWNlcy5oYXNPd25Qcm9wZXJ0eShrKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrLCBub3RTZXRWYWx1ZSkge1xuICBpZiAoIXRoaXMuaGFzKGspKSB7XG4gICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICB9XG4gIHZhciBpbmRleCA9IHRoaXMuX2luZGljZXNba107XG4gIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlcy5nZXQoaW5kZXgpO1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHRoaXMuX2RlZmF1bHRWYWx1ZXNba10gOiB2YWx1ZTtcbn07XG5cbi8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cblJlY29yZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChrLCB2KSB7XG4gIGlmICh0aGlzLmhhcyhrKSkge1xuICAgIHZhciBuZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXMuc2V0KFxuICAgICAgdGhpcy5faW5kaWNlc1trXSxcbiAgICAgIHYgPT09IHRoaXMuX2RlZmF1bHRWYWx1ZXNba10gPyB1bmRlZmluZWQgOiB2XG4gICAgKTtcbiAgICBpZiAobmV3VmFsdWVzICE9PSB0aGlzLl92YWx1ZXMgJiYgIXRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdWYWx1ZXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblJlY29yZC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChrKSB7XG4gIHJldHVybiB0aGlzLnNldChrKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gIHZhciBuZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXMuY2xlYXIoKS5zZXRTaXplKHRoaXMuX2tleXMubGVuZ3RoKTtcblxuICByZXR1cm4gdGhpcy5fX293bmVySUQgPyB0aGlzIDogbWFrZVJlY29yZCh0aGlzLCBuZXdWYWx1ZXMpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24gd2FzQWx0ZXJlZCAoKSB7XG4gIHJldHVybiB0aGlzLl92YWx1ZXMud2FzQWx0ZXJlZCgpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS50b1NlcSA9IGZ1bmN0aW9uIHRvU2VxICgpIHtcbiAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUudG9KUyA9IGZ1bmN0aW9uIHRvSlMkMSAoKSB7XG4gIHJldHVybiB0b0pTKHRoaXMpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcyAoKSB7XG4gIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xufTtcblxuUmVjb3JkLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gIHJldHVybiByZWNvcmRTZXEodGhpcykuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIG5ld1ZhbHVlcyA9IHRoaXMuX3ZhbHVlcy5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICBpZiAoIW93bmVySUQpIHtcbiAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgdGhpcy5fdmFsdWVzID0gbmV3VmFsdWVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJldHVybiBtYWtlUmVjb3JkKHRoaXMsIG5ld1ZhbHVlcywgb3duZXJJRCk7XG59O1xuXG5SZWNvcmQuaXNSZWNvcmQgPSBpc1JlY29yZDtcblJlY29yZC5nZXREZXNjcmlwdGl2ZU5hbWUgPSByZWNvcmROYW1lO1xudmFyIFJlY29yZFByb3RvdHlwZSA9IFJlY29yZC5wcm90b3R5cGU7XG5SZWNvcmRQcm90b3R5cGVbSVNfUkVDT1JEX1NZTUJPTF0gPSB0cnVlO1xuUmVjb3JkUHJvdG90eXBlW0RFTEVURV0gPSBSZWNvcmRQcm90b3R5cGUucmVtb3ZlO1xuUmVjb3JkUHJvdG90eXBlLmRlbGV0ZUluID0gUmVjb3JkUHJvdG90eXBlLnJlbW92ZUluID0gZGVsZXRlSW47XG5SZWNvcmRQcm90b3R5cGUuZ2V0SW4gPSBnZXRJbjtcblJlY29yZFByb3RvdHlwZS5oYXNJbiA9IENvbGxlY3Rpb25Qcm90b3R5cGUuaGFzSW47XG5SZWNvcmRQcm90b3R5cGUubWVyZ2UgPSBtZXJnZSQxO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlV2l0aCA9IG1lcmdlV2l0aCQxO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlSW4gPSBtZXJnZUluO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcCA9IG1lcmdlRGVlcDtcblJlY29yZFByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gbWVyZ2VEZWVwV2l0aDtcblJlY29yZFByb3RvdHlwZS5tZXJnZURlZXBJbiA9IG1lcmdlRGVlcEluO1xuUmVjb3JkUHJvdG90eXBlLnNldEluID0gc2V0SW47XG5SZWNvcmRQcm90b3R5cGUudXBkYXRlID0gdXBkYXRlO1xuUmVjb3JkUHJvdG90eXBlLnVwZGF0ZUluID0gdXBkYXRlSW47XG5SZWNvcmRQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IHdpdGhNdXRhdGlvbnM7XG5SZWNvcmRQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuUmVjb3JkUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG5SZWNvcmRQcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IFJlY29yZFByb3RvdHlwZS5lbnRyaWVzO1xuUmVjb3JkUHJvdG90eXBlLnRvSlNPTiA9IFJlY29yZFByb3RvdHlwZS50b09iamVjdCA9XG4gIENvbGxlY3Rpb25Qcm90b3R5cGUudG9PYmplY3Q7XG5SZWNvcmRQcm90b3R5cGUuaW5zcGVjdCA9IFJlY29yZFByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbn07XG5cbmZ1bmN0aW9uIG1ha2VSZWNvcmQobGlrZVJlY29yZCwgdmFsdWVzLCBvd25lcklEKSB7XG4gIHZhciByZWNvcmQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihsaWtlUmVjb3JkKSk7XG4gIHJlY29yZC5fdmFsdWVzID0gdmFsdWVzO1xuICByZWNvcmQuX19vd25lcklEID0gb3duZXJJRDtcbiAgcmV0dXJuIHJlY29yZDtcbn1cblxuZnVuY3Rpb24gcmVjb3JkTmFtZShyZWNvcmQpIHtcbiAgcmV0dXJuIHJlY29yZC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCByZWNvcmQuY29uc3RydWN0b3IubmFtZSB8fCAnUmVjb3JkJztcbn1cblxuZnVuY3Rpb24gcmVjb3JkU2VxKHJlY29yZCkge1xuICByZXR1cm4ga2V5ZWRTZXFGcm9tVmFsdWUocmVjb3JkLl9rZXlzLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gW2ssIHJlY29yZC5nZXQoayldOyB9KSk7XG59XG5cbmZ1bmN0aW9uIHNldFByb3AocHJvdG90eXBlLCBuYW1lKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChuYW1lKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpbnZhcmlhbnQodGhpcy5fX293bmVySUQsICdDYW5ub3Qgc2V0IG9uIGFuIGltbXV0YWJsZSByZWNvcmQuJyk7XG4gICAgICAgIHRoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5IGZhaWxlZC4gUHJvYmFibHkgSUU4LlxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxhenkgU2VxIG9mIGB2YWx1ZWAgcmVwZWF0ZWQgYHRpbWVzYCB0aW1lcy4gV2hlbiBgdGltZXNgIGlzXG4gKiB1bmRlZmluZWQsIHJldHVybnMgYW4gaW5maW5pdGUgc2VxdWVuY2Ugb2YgYHZhbHVlYC5cbiAqL1xudmFyIFJlcGVhdCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRTZXEpIHtcbiAgZnVuY3Rpb24gUmVwZWF0KHZhbHVlLCB0aW1lcykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXBlYXQpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gICAgICByZXR1cm4gbmV3IFJlcGVhdCh2YWx1ZSwgdGltZXMpO1xuICAgIH1cbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuc2l6ZSA9IHRpbWVzID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IE1hdGgubWF4KDAsIHRpbWVzKTtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICBpZiAoRU1QVFlfUkVQRUFUKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cbiAgICAgICAgcmV0dXJuIEVNUFRZX1JFUEVBVDtcbiAgICAgIH1cbiAgICAgIEVNUFRZX1JFUEVBVCA9IHRoaXM7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBJbmRleGVkU2VxICkgUmVwZWF0Ll9fcHJvdG9fXyA9IEluZGV4ZWRTZXE7XG4gIFJlcGVhdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gIFJlcGVhdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXBlYXQ7XG5cbiAgUmVwZWF0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gJ1JlcGVhdCBbXSc7XG4gICAgfVxuICAgIHJldHVybiAnUmVwZWF0IFsgJyArIHRoaXMuX3ZhbHVlICsgJyAnICsgdGhpcy5zaXplICsgJyB0aW1lcyBdJztcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGluZGV4KSA/IHRoaXMuX3ZhbHVlIDogbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzIChzZWFyY2hWYWx1ZSkge1xuICAgIHJldHVybiBpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoYmVnaW4sIGVuZCkge1xuICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgIHJldHVybiB3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHNpemUpXG4gICAgICA/IHRoaXNcbiAgICAgIDogbmV3IFJlcGVhdChcbiAgICAgICAgICB0aGlzLl92YWx1ZSxcbiAgICAgICAgICByZXNvbHZlRW5kKGVuZCwgc2l6ZSkgLSByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpXG4gICAgICAgICk7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAoc2VhcmNoVmFsdWUpIHtcbiAgICBpZiAoaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHNlYXJjaFZhbHVlKSB7XG4gICAgaWYgKGlzKHRoaXMuX3ZhbHVlLCBzZWFyY2hWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgIGlmIChmbih0aGlzLl92YWx1ZSwgcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7IHJldHVybiBpID09PSBzaXplXG4gICAgICAgID8gaXRlcmF0b3JEb25lKClcbiAgICAgICAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB0aGlzJDEkMS5fdmFsdWUpOyB9XG4gICAgKTtcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBSZXBlYXRcbiAgICAgID8gaXModGhpcy5fdmFsdWUsIG90aGVyLl92YWx1ZSlcbiAgICAgIDogZGVlcEVxdWFsKHRoaXMsIG90aGVyKTtcbiAgfTtcblxuICByZXR1cm4gUmVwZWF0O1xufShJbmRleGVkU2VxKSk7XG5cbnZhciBFTVBUWV9SRVBFQVQ7XG5cbmZ1bmN0aW9uIGZyb21KUyh2YWx1ZSwgY29udmVydGVyKSB7XG4gIHJldHVybiBmcm9tSlNXaXRoKFxuICAgIFtdLFxuICAgIGNvbnZlcnRlciB8fCBkZWZhdWx0Q29udmVydGVyLFxuICAgIHZhbHVlLFxuICAgICcnLFxuICAgIGNvbnZlcnRlciAmJiBjb252ZXJ0ZXIubGVuZ3RoID4gMiA/IFtdIDogdW5kZWZpbmVkLFxuICAgIHsgJyc6IHZhbHVlIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gZnJvbUpTV2l0aChzdGFjaywgY29udmVydGVyLCB2YWx1ZSwga2V5LCBrZXlQYXRoLCBwYXJlbnRWYWx1ZSkge1xuICBpZiAoXG4gICAgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgICFpc0ltbXV0YWJsZSh2YWx1ZSkgJiZcbiAgICAoaXNBcnJheUxpa2UodmFsdWUpIHx8IGhhc0l0ZXJhdG9yKHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSlcbiAgKSB7XG4gICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEltbXV0YWJsZScpO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICBrZXlQYXRoICYmIGtleSAhPT0gJycgJiYga2V5UGF0aC5wdXNoKGtleSk7XG4gICAgdmFyIGNvbnZlcnRlZCA9IGNvbnZlcnRlci5jYWxsKFxuICAgICAgcGFyZW50VmFsdWUsXG4gICAgICBrZXksXG4gICAgICBTZXEodmFsdWUpLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZnJvbUpTV2l0aChzdGFjaywgY29udmVydGVyLCB2LCBrLCBrZXlQYXRoLCB2YWx1ZSk7IH1cbiAgICAgICksXG4gICAgICBrZXlQYXRoICYmIGtleVBhdGguc2xpY2UoKVxuICAgICk7XG4gICAgc3RhY2sucG9wKCk7XG4gICAga2V5UGF0aCAmJiBrZXlQYXRoLnBvcCgpO1xuICAgIHJldHVybiBjb252ZXJ0ZWQ7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29udmVydGVyKGssIHYpIHtcbiAgLy8gRWZmZWN0aXZlbHkgdGhlIG9wcG9zaXRlIG9mIFwiQ29sbGVjdGlvbi50b1NlcSgpXCJcbiAgcmV0dXJuIGlzSW5kZXhlZCh2KSA/IHYudG9MaXN0KCkgOiBpc0tleWVkKHYpID8gdi50b01hcCgpIDogdi50b1NldCgpO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiNC4zLjdcIjtcblxudmFyIEltbXV0YWJsZSA9IHtcbiAgdmVyc2lvbjogdmVyc2lvbixcblxuICBDb2xsZWN0aW9uOiBDb2xsZWN0aW9uLFxuICAvLyBOb3RlOiBJdGVyYWJsZSBpcyBkZXByZWNhdGVkXG4gIEl0ZXJhYmxlOiBDb2xsZWN0aW9uLFxuXG4gIFNlcTogU2VxLFxuICBNYXA6IE1hcCxcbiAgT3JkZXJlZE1hcDogT3JkZXJlZE1hcCxcbiAgTGlzdDogTGlzdCxcbiAgU3RhY2s6IFN0YWNrLFxuICBTZXQ6IFNldCxcbiAgT3JkZXJlZFNldDogT3JkZXJlZFNldCxcbiAgUGFpclNvcnRpbmc6IFBhaXJTb3J0aW5nLFxuXG4gIFJlY29yZDogUmVjb3JkLFxuICBSYW5nZTogUmFuZ2UsXG4gIFJlcGVhdDogUmVwZWF0LFxuXG4gIGlzOiBpcyxcbiAgZnJvbUpTOiBmcm9tSlMsXG4gIGhhc2g6IGhhc2gsXG5cbiAgaXNJbW11dGFibGU6IGlzSW1tdXRhYmxlLFxuICBpc0NvbGxlY3Rpb246IGlzQ29sbGVjdGlvbixcbiAgaXNLZXllZDogaXNLZXllZCxcbiAgaXNJbmRleGVkOiBpc0luZGV4ZWQsXG4gIGlzQXNzb2NpYXRpdmU6IGlzQXNzb2NpYXRpdmUsXG4gIGlzT3JkZXJlZDogaXNPcmRlcmVkLFxuICBpc1ZhbHVlT2JqZWN0OiBpc1ZhbHVlT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICBpc1NlcTogaXNTZXEsXG4gIGlzTGlzdDogaXNMaXN0LFxuICBpc01hcDogaXNNYXAsXG4gIGlzT3JkZXJlZE1hcDogaXNPcmRlcmVkTWFwLFxuICBpc1N0YWNrOiBpc1N0YWNrLFxuICBpc1NldDogaXNTZXQsXG4gIGlzT3JkZXJlZFNldDogaXNPcmRlcmVkU2V0LFxuICBpc1JlY29yZDogaXNSZWNvcmQsXG5cbiAgZ2V0OiBnZXQsXG4gIGdldEluOiBnZXRJbiQxLFxuICBoYXM6IGhhcyxcbiAgaGFzSW46IGhhc0luJDEsXG4gIG1lcmdlOiBtZXJnZSxcbiAgbWVyZ2VEZWVwOiBtZXJnZURlZXAkMSxcbiAgbWVyZ2VXaXRoOiBtZXJnZVdpdGgsXG4gIG1lcmdlRGVlcFdpdGg6IG1lcmdlRGVlcFdpdGgkMSxcbiAgcmVtb3ZlOiByZW1vdmUsXG4gIHJlbW92ZUluOiByZW1vdmVJbixcbiAgc2V0OiBzZXQsXG4gIHNldEluOiBzZXRJbiQxLFxuICB1cGRhdGU6IHVwZGF0ZSQxLFxuICB1cGRhdGVJbjogdXBkYXRlSW4kMSxcbn07XG5cbi8vIE5vdGU6IEl0ZXJhYmxlIGlzIGRlcHJlY2F0ZWRcbnZhciBJdGVyYWJsZSA9IENvbGxlY3Rpb247XG5cbmV4cG9ydCBkZWZhdWx0IEltbXV0YWJsZTtcbmV4cG9ydCB7IENvbGxlY3Rpb24sIEl0ZXJhYmxlLCBMaXN0LCBNYXAsIE9yZGVyZWRNYXAsIE9yZGVyZWRTZXQsIFBhaXJTb3J0aW5nLCBSYW5nZSwgUmVjb3JkLCBSZXBlYXQsIFNlcSwgU2V0LCBTdGFjaywgZnJvbUpTLCBnZXQsIGdldEluJDEgYXMgZ2V0SW4sIGhhcywgaGFzSW4kMSBhcyBoYXNJbiwgaGFzaCwgaXMsIGlzQXNzb2NpYXRpdmUsIGlzQ29sbGVjdGlvbiwgaXNJbW11dGFibGUsIGlzSW5kZXhlZCwgaXNLZXllZCwgaXNMaXN0LCBpc01hcCwgaXNPcmRlcmVkLCBpc09yZGVyZWRNYXAsIGlzT3JkZXJlZFNldCwgaXNQbGFpbk9iamVjdCwgaXNSZWNvcmQsIGlzU2VxLCBpc1NldCwgaXNTdGFjaywgaXNWYWx1ZU9iamVjdCwgbWVyZ2UsIG1lcmdlRGVlcCQxIGFzIG1lcmdlRGVlcCwgbWVyZ2VEZWVwV2l0aCQxIGFzIG1lcmdlRGVlcFdpdGgsIG1lcmdlV2l0aCwgcmVtb3ZlLCByZW1vdmVJbiwgc2V0LCBzZXRJbiQxIGFzIHNldEluLCB1cGRhdGUkMSBhcyB1cGRhdGUsIHVwZGF0ZUluJDEgYXMgdXBkYXRlSW4sIHZlcnNpb24gfTtcbiJdLCJuYW1lcyI6WyJERUxFVEUiLCJTSElGVCIsIlNJWkUiLCJNQVNLIiwiTk9UX1NFVCIsIk1ha2VSZWYiLCJ2YWx1ZSIsIlNldFJlZiIsInJlZiIsIk93bmVySUQiLCJlbnN1cmVTaXplIiwiaXRlciIsInNpemUiLCJ1bmRlZmluZWQiLCJfX2l0ZXJhdGUiLCJyZXR1cm5UcnVlIiwid3JhcEluZGV4IiwiaW5kZXgiLCJ1aW50MzJJbmRleCIsIk5hTiIsIndob2xlU2xpY2UiLCJiZWdpbiIsImVuZCIsImlzTmVnIiwicmVzb2x2ZUJlZ2luIiwicmVzb2x2ZUluZGV4IiwicmVzb2x2ZUVuZCIsImRlZmF1bHRJbmRleCIsIkluZmluaXR5IiwiTWF0aCIsIm1heCIsIm1pbiIsIklTX0NPTExFQ1RJT05fU1lNQk9MIiwiaXNDb2xsZWN0aW9uIiwibWF5YmVDb2xsZWN0aW9uIiwiQm9vbGVhbiIsIklTX0tFWUVEX1NZTUJPTCIsImlzS2V5ZWQiLCJtYXliZUtleWVkIiwiSVNfSU5ERVhFRF9TWU1CT0wiLCJpc0luZGV4ZWQiLCJtYXliZUluZGV4ZWQiLCJpc0Fzc29jaWF0aXZlIiwibWF5YmVBc3NvY2lhdGl2ZSIsIkNvbGxlY3Rpb24iLCJTZXEiLCJLZXllZENvbGxlY3Rpb24iLCJLZXllZFNlcSIsIl9fcHJvdG9fXyIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiSW5kZXhlZENvbGxlY3Rpb24iLCJJbmRleGVkU2VxIiwiU2V0Q29sbGVjdGlvbiIsIlNldFNlcSIsIktleWVkIiwiSW5kZXhlZCIsIlNldCIsIklTX1NFUV9TWU1CT0wiLCJpc1NlcSIsIm1heWJlU2VxIiwiSVNfUkVDT1JEX1NZTUJPTCIsImlzUmVjb3JkIiwibWF5YmVSZWNvcmQiLCJpc0ltbXV0YWJsZSIsIm1heWJlSW1tdXRhYmxlIiwiSVNfT1JERVJFRF9TWU1CT0wiLCJpc09yZGVyZWQiLCJtYXliZU9yZGVyZWQiLCJJVEVSQVRFX0tFWVMiLCJJVEVSQVRFX1ZBTFVFUyIsIklURVJBVEVfRU5UUklFUyIsIlJFQUxfSVRFUkFUT1JfU1lNQk9MIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsIklURVJBVE9SX1NZTUJPTCIsIkl0ZXJhdG9yIiwibmV4dCIsInRvU3RyaW5nIiwiS0VZUyIsIlZBTFVFUyIsIkVOVFJJRVMiLCJpbnNwZWN0IiwidG9Tb3VyY2UiLCJpdGVyYXRvclZhbHVlIiwidHlwZSIsImsiLCJ2IiwiaXRlcmF0b3JSZXN1bHQiLCJkb25lIiwiaXRlcmF0b3JEb25lIiwiaGFzSXRlcmF0b3IiLCJtYXliZUl0ZXJhYmxlIiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0SXRlcmF0b3JGbiIsImlzSXRlcmF0b3IiLCJtYXliZUl0ZXJhdG9yIiwiZ2V0SXRlcmF0b3IiLCJpdGVyYWJsZSIsIml0ZXJhdG9yRm4iLCJjYWxsIiwiaXNFbnRyaWVzSXRlcmFibGUiLCJlbnRyaWVzIiwiaXNLZXlzSXRlcmFibGUiLCJrZXlzIiwiaGFzT3duUHJvcGVydHkiLCJpc0FycmF5TGlrZSIsIk51bWJlciIsImlzSW50ZWdlciIsImxlbmd0aCIsImVtcHR5U2VxdWVuY2UiLCJ0b1NlcSIsInNlcUZyb21WYWx1ZSIsIl9fdG9TdHJpbmciLCJjYWNoZVJlc3VsdCIsIl9jYWNoZSIsIl9faXRlcmF0ZVVuY2FjaGVkIiwiZW50cnlTZXEiLCJ0b0FycmF5IiwiZm4iLCJyZXZlcnNlIiwiY2FjaGUiLCJpIiwiZW50cnkiLCJfX2l0ZXJhdG9yIiwiX19pdGVyYXRvclVuY2FjaGVkIiwidG9LZXllZFNlcSIsImZyb21FbnRyeVNlcSIsImtleWVkU2VxRnJvbVZhbHVlIiwidG9JbmRleGVkU2VxIiwiaW5kZXhlZFNlcUZyb21WYWx1ZSIsIm9mIiwiYXJndW1lbnRzIiwidG9TZXRTZXEiLCJBcnJheVNlcSIsImFycmF5IiwiX2FycmF5IiwiZ2V0Iiwibm90U2V0VmFsdWUiLCJoYXMiLCJpaSIsIk9iamVjdFNlcSIsIm9iamVjdCIsImNvbmNhdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsIl9vYmplY3QiLCJfa2V5cyIsImtleSIsIkNvbGxlY3Rpb25TZXEiLCJjb2xsZWN0aW9uIiwiX2NvbGxlY3Rpb24iLCJpdGVyYXRpb25zIiwic3RlcCIsIkVNUFRZX1NFUSIsInNlcSIsIm1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSIsIlR5cGVFcnJvciIsIklTX01BUF9TWU1CT0wiLCJpc01hcCIsIm1heWJlTWFwIiwiaXNPcmRlcmVkTWFwIiwibWF5YmVPcmRlcmVkTWFwIiwiaXNWYWx1ZU9iamVjdCIsIm1heWJlVmFsdWUiLCJlcXVhbHMiLCJoYXNoQ29kZSIsImlzIiwidmFsdWVBIiwidmFsdWVCIiwidmFsdWVPZiIsImltdWwiLCJhIiwiYiIsImMiLCJkIiwic21pIiwiaTMyIiwiZGVmYXVsdFZhbHVlT2YiLCJoYXNoIiwibyIsImhhc2hOdWxsaXNoIiwiaGFzaE51bWJlciIsIlNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU4iLCJjYWNoZWRIYXNoU3RyaW5nIiwiaGFzaFN0cmluZyIsImhhc2hKU09iaiIsImhhc2hTeW1ib2wiLCJFcnJvciIsIm51bGxpc2giLCJuIiwic3RyaW5nIiwiaGFzaGVkIiwic3RyaW5nSGFzaENhY2hlIiwiU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSIsIlNUUklOR19IQVNIX0NBQ0hFX01BWF9TSVpFIiwiY2hhckNvZGVBdCIsInN5bSIsInN5bWJvbE1hcCIsIm5leHRIYXNoIiwib2JqIiwidXNpbmdXZWFrTWFwIiwid2Vha01hcCIsIlVJRF9IQVNIX0tFWSIsImNhbkRlZmluZVByb3BlcnR5IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJnZXRJRU5vZGVIYXNoIiwic2V0IiwiaXNFeHRlbnNpYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJhcHBseSIsIm5vZGVUeXBlIiwiZSIsIm5vZGUiLCJ1bmlxdWVJRCIsImRvY3VtZW50RWxlbWVudCIsIl9vYmpIYXNoVUlEIiwiV2Vha01hcCIsIlRvS2V5ZWRTZXF1ZW5jZSIsImluZGV4ZWQiLCJ1c2VLZXlzIiwiX2l0ZXIiLCJfdXNlS2V5cyIsInZhbHVlU2VxIiwidGhpcyQxJDEiLCJyZXZlcnNlZFNlcXVlbmNlIiwicmV2ZXJzZUZhY3RvcnkiLCJtYXAiLCJtYXBwZXIiLCJjb250ZXh0IiwibWFwcGVkU2VxdWVuY2UiLCJtYXBGYWN0b3J5IiwiVG9JbmRleGVkU2VxdWVuY2UiLCJpbmNsdWRlcyIsIlRvU2V0U2VxdWVuY2UiLCJGcm9tRW50cmllc1NlcXVlbmNlIiwidmFsaWRhdGVFbnRyeSIsImluZGV4ZWRDb2xsZWN0aW9uIiwiY2FjaGVSZXN1bHRUaHJvdWdoIiwiZmxpcEZhY3RvcnkiLCJmbGlwU2VxdWVuY2UiLCJtYWtlU2VxdWVuY2UiLCJmbGlwIiwiZmlsdGVyRmFjdG9yeSIsInByZWRpY2F0ZSIsImZpbHRlclNlcXVlbmNlIiwiY291bnRCeUZhY3RvcnkiLCJncm91cGVyIiwiZ3JvdXBzIiwiTWFwIiwiYXNNdXRhYmxlIiwidXBkYXRlIiwiYXNJbW11dGFibGUiLCJncm91cEJ5RmFjdG9yeSIsImlzS2V5ZWRJdGVyIiwiT3JkZXJlZE1hcCIsInB1c2giLCJjb2VyY2UiLCJjb2xsZWN0aW9uQ2xhc3MiLCJhcnIiLCJyZWlmeSIsInBhcnRpdGlvbkZhY3RvcnkiLCJzbGljZUZhY3RvcnkiLCJvcmlnaW5hbFNpemUiLCJyZXNvbHZlZEJlZ2luIiwicmVzb2x2ZWRFbmQiLCJyZXNvbHZlZFNpemUiLCJzbGljZVNpemUiLCJzbGljZVNlcSIsInNraXBwZWQiLCJpc1NraXBwaW5nIiwidGFrZVdoaWxlRmFjdG9yeSIsInRha2VTZXF1ZW5jZSIsIml0ZXJhdGluZyIsInNraXBXaGlsZUZhY3RvcnkiLCJza2lwU2VxdWVuY2UiLCJza2lwcGluZyIsImNvbmNhdEZhY3RvcnkiLCJ2YWx1ZXMiLCJpc0tleWVkQ29sbGVjdGlvbiIsIml0ZXJzIiwiZmlsdGVyIiwic2luZ2xldG9uIiwiY29uY2F0U2VxIiwiZmxhdHRlbiIsInJlZHVjZSIsInN1bSIsImZsYXR0ZW5GYWN0b3J5IiwiZGVwdGgiLCJmbGF0U2VxdWVuY2UiLCJzdG9wcGVkIiwiZmxhdERlZXAiLCJjdXJyZW50RGVwdGgiLCJzdGFjayIsInBvcCIsImZsYXRNYXBGYWN0b3J5IiwiaW50ZXJwb3NlRmFjdG9yeSIsInNlcGFyYXRvciIsImludGVycG9zZWRTZXF1ZW5jZSIsInNvcnRGYWN0b3J5IiwiY29tcGFyYXRvciIsImRlZmF1bHRDb21wYXJhdG9yIiwic29ydCIsImZvckVhY2giLCJtYXhGYWN0b3J5IiwibWF4Q29tcGFyZSIsImNvbXAiLCJ6aXBXaXRoRmFjdG9yeSIsImtleUl0ZXIiLCJ6aXBwZXIiLCJ6aXBBbGwiLCJ6aXBTZXF1ZW5jZSIsInNpemVzIiwiaXRlcmF0b3JzIiwiaXNEb25lIiwic3RlcHMiLCJldmVyeSIsInMiLCJzb21lIiwiYXJyQ29weSIsIm9mZnNldCIsImxlbiIsIm5ld0FyciIsImludmFyaWFudCIsImNvbmRpdGlvbiIsImVycm9yIiwiYXNzZXJ0Tm90SW5maW5pdGUiLCJjb2VyY2VLZXlQYXRoIiwia2V5UGF0aCIsImlzUGxhaW5PYmplY3QiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwicGFyZW50UHJvdG8iLCJuZXh0UHJvdG8iLCJpc0RhdGFTdHJ1Y3R1cmUiLCJxdW90ZVN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJTdHJpbmciLCJfaWdub3JlRXJyb3IiLCJzaGFsbG93Q29weSIsImZyb20iLCJ0byIsInJlbW92ZSIsImNvbGxlY3Rpb25Db3B5Iiwic3BsaWNlIiwidXBkYXRlSW4kMSIsInVwZGF0ZXIiLCJ1cGRhdGVkVmFsdWUiLCJ1cGRhdGVJbkRlZXBseSIsImluSW1tdXRhYmxlIiwiZXhpc3RpbmciLCJ3YXNOb3RTZXQiLCJleGlzdGluZ1ZhbHVlIiwibmV3VmFsdWUiLCJzbGljZSIsIm5leHRFeGlzdGluZyIsIm5leHRVcGRhdGVkIiwiZW1wdHlNYXAiLCJzZXRJbiQxIiwic2V0SW4iLCJyZW1vdmVJbiIsImRlbGV0ZUluIiwidXBkYXRlJDEiLCJ1cGRhdGVJbiIsIm1lcmdlJDEiLCJtZXJnZUludG9LZXllZFdpdGgiLCJtZXJnZVdpdGgkMSIsIm1lcmdlciIsImNvbGxlY3Rpb25zIiwiY29sbGVjdGlvbiQxIiwiX19vd25lcklEIiwid2l0aE11dGF0aW9ucyIsIm1lcmdlSW50b0NvbGxlY3Rpb24iLCJvbGRWYWwiLCJtZXJnZSIsInNvdXJjZXMiLCJtZXJnZVdpdGhTb3VyY2VzIiwibWVyZ2VXaXRoIiwibWVyZ2VEZWVwJDEiLCJtZXJnZURlZXBXaXRoU291cmNlcyIsIm1lcmdlRGVlcFdpdGgkMSIsImRlZXBNZXJnZXJXaXRoIiwibWVyZ2VkIiwibWVyZ2VJdGVtIiwiaGFzVmFsIiwibmV4dFZhbCIsImRlZXBNZXJnZXIiLCJvbGRWYWx1ZSIsImFyZU1lcmdlYWJsZSIsIm9sZERhdGFTdHJ1Y3R1cmUiLCJuZXdEYXRhU3RydWN0dXJlIiwib2xkU2VxIiwibmV3U2VxIiwibWVyZ2VEZWVwIiwibWVyZ2VEZWVwV2l0aCIsIm1lcmdlSW4iLCJtIiwibWVyZ2VEZWVwSW4iLCJtdXRhYmxlIiwid2FzQWx0ZXJlZCIsIl9fZW5zdXJlT3duZXIiLCJfX2FsdGVyZWQiLCJrZXlWYWx1ZXMiLCJfcm9vdCIsInVwZGF0ZU1hcCIsImRlbGV0ZUFsbCIsImNsZWFyIiwiX19oYXNoIiwic29ydEJ5IiwiTWFwSXRlcmF0b3IiLCJpdGVyYXRlIiwib3duZXJJRCIsIm1ha2VNYXAiLCJNYXBQcm90b3R5cGUiLCJyZW1vdmVBbGwiLCJyZXN1bHQiLCJBcnJheU1hcE5vZGUiLCJzaGlmdCIsImtleUhhc2giLCJkaWRDaGFuZ2VTaXplIiwiZGlkQWx0ZXIiLCJyZW1vdmVkIiwiaWR4IiwiZXhpc3RzIiwiTUFYX0FSUkFZX01BUF9TSVpFIiwiY3JlYXRlTm9kZXMiLCJpc0VkaXRhYmxlIiwibmV3RW50cmllcyIsIkJpdG1hcEluZGV4ZWROb2RlIiwiYml0bWFwIiwibm9kZXMiLCJiaXQiLCJwb3BDb3VudCIsImtleUhhc2hGcmFnIiwibmV3Tm9kZSIsInVwZGF0ZU5vZGUiLCJNQVhfQklUTUFQX0lOREVYRURfU0laRSIsImV4cGFuZE5vZGVzIiwiaXNMZWFmTm9kZSIsIm5ld0JpdG1hcCIsIm5ld05vZGVzIiwic2V0QXQiLCJzcGxpY2VPdXQiLCJzcGxpY2VJbiIsIkhhc2hBcnJheU1hcE5vZGUiLCJjb3VudCIsIm5ld0NvdW50IiwiTUlOX0hBU0hfQVJSQVlfTUFQX1NJWkUiLCJwYWNrTm9kZXMiLCJIYXNoQ29sbGlzaW9uTm9kZSIsIm1lcmdlSW50b05vZGUiLCJWYWx1ZU5vZGUiLCJrZXlNYXRjaCIsIm1heEluZGV4IiwiX3R5cGUiLCJfcmV2ZXJzZSIsIl9zdGFjayIsIm1hcEl0ZXJhdG9yRnJhbWUiLCJtYXBJdGVyYXRvclZhbHVlIiwic3ViTm9kZSIsIl9fcHJldiIsInByZXYiLCJyb290IiwiRU1QVFlfTUFQIiwibmV3Um9vdCIsIm5ld1NpemUiLCJpZHgxIiwiaWR4MiIsImV4Y2x1ZGluZyIsInBhY2tlZElJIiwicGFja2VkTm9kZXMiLCJpbmNsdWRpbmciLCJleHBhbmRlZE5vZGVzIiwieCIsInZhbCIsImNhbkVkaXQiLCJuZXdBcnJheSIsIm5ld0xlbiIsImFmdGVyIiwiSVNfTElTVF9TWU1CT0wiLCJpc0xpc3QiLCJtYXliZUxpc3QiLCJMaXN0IiwiZW1wdHkiLCJlbXB0eUxpc3QiLCJtYWtlTGlzdCIsIlZOb2RlIiwibGlzdCIsInNldFNpemUiLCJfb3JpZ2luIiwibGlzdE5vZGVGb3IiLCJ1cGRhdGVMaXN0IiwiaW5zZXJ0IiwiX2NhcGFjaXR5IiwiX2xldmVsIiwiX3RhaWwiLCJvbGRTaXplIiwic2V0TGlzdEJvdW5kcyIsInVuc2hpZnQiLCJhcmd1bWVudHMkMSIsInNlcXMiLCJhcmd1bWVudCIsIml0ZXJhdGVMaXN0IiwiRE9ORSIsIkxpc3RQcm90b3R5cGUiLCJyZW1vdmVCZWZvcmUiLCJsZXZlbCIsIm9yaWdpbkluZGV4IiwicmVtb3ZpbmdGaXJzdCIsIm5ld0NoaWxkIiwib2xkQ2hpbGQiLCJlZGl0YWJsZSIsImVkaXRhYmxlVk5vZGUiLCJyZW1vdmVBZnRlciIsInNpemVJbmRleCIsImxlZnQiLCJyaWdodCIsInRhaWxQb3MiLCJnZXRUYWlsT2Zmc2V0IiwidGFpbCIsIml0ZXJhdGVOb2RlT3JMZWFmIiwiaXRlcmF0ZUxlYWYiLCJpdGVyYXRlTm9kZSIsIm9yaWdpbiIsImNhcGFjaXR5IiwiRU1QVFlfTElTVCIsIm5ld1RhaWwiLCJ1cGRhdGVWTm9kZSIsIm5vZGVIYXMiLCJsb3dlck5vZGUiLCJuZXdMb3dlck5vZGUiLCJyYXdJbmRleCIsIm93bmVyIiwib2xkT3JpZ2luIiwib2xkQ2FwYWNpdHkiLCJuZXdPcmlnaW4iLCJuZXdDYXBhY2l0eSIsIm5ld0xldmVsIiwib2Zmc2V0U2hpZnQiLCJvbGRUYWlsT2Zmc2V0IiwibmV3VGFpbE9mZnNldCIsIm9sZFRhaWwiLCJiZWdpbkluZGV4IiwiZW1wdHlPcmRlcmVkTWFwIiwiX21hcCIsIl9saXN0IiwidXBkYXRlT3JkZXJlZE1hcCIsIm5ld01hcCIsIm5ld0xpc3QiLCJtYWtlT3JkZXJlZE1hcCIsIm9tYXAiLCJFTVBUWV9PUkRFUkVEX01BUCIsInRvTWFwIiwiSVNfU1RBQ0tfU1lNQk9MIiwiaXNTdGFjayIsIm1heWJlU3RhY2siLCJTdGFjayIsImVtcHR5U3RhY2siLCJwdXNoQWxsIiwiaGVhZCIsIl9oZWFkIiwicGVlayIsIm1ha2VTdGFjayIsIlN0YWNrUHJvdG90eXBlIiwidW5zaGlmdEFsbCIsIkVNUFRZX1NUQUNLIiwiSVNfU0VUX1NZTUJPTCIsImlzU2V0IiwibWF5YmVTZXQiLCJpc09yZGVyZWRTZXQiLCJtYXliZU9yZGVyZWRTZXQiLCJkZWVwRXF1YWwiLCJub3RBc3NvY2lhdGl2ZSIsImZsaXBwZWQiLCJfIiwiYWxsRXF1YWwiLCJiU2l6ZSIsIm1peGluIiwiY3RvciIsIm1ldGhvZHMiLCJrZXlDb3BpZXIiLCJ0b0pTIiwicmVzdWx0JDEiLCJlbXB0eVNldCIsImFkZCIsImZyb21LZXlzIiwia2V5U2VxIiwiaW50ZXJzZWN0Iiwic2V0cyIsIlNldFByb3RvdHlwZSIsInVuaW9uIiwidXBkYXRlU2V0IiwiZGlkQ2hhbmdlcyIsIm1hcEVudHJpZXMiLCJtYXBwZWQiLCJ0b1JlbW92ZSIsInN1YnRyYWN0IiwiT3JkZXJlZFNldCIsIl9fZW1wdHkiLCJfX21ha2UiLCJtYWtlU2V0IiwiRU1QVFlfU0VUIiwiUmFuZ2UiLCJzdGFydCIsImFicyIsIl9zdGFydCIsIl9lbmQiLCJfc3RlcCIsImNlaWwiLCJFTVBUWV9SQU5HRSIsInNlYXJjaFZhbHVlIiwicG9zc2libGVJbmRleCIsImZsb29yIiwiaW5kZXhPZiIsIm9mZnNldFZhbHVlIiwibGFzdEluZGV4T2YiLCJvdGhlciIsImdldEluJDEiLCJzZWFyY2hLZXlQYXRoIiwiZ2V0SW4iLCJoYXNJbiQxIiwiaGFzSW4iLCJ0b09iamVjdCIsImlzSXRlcmFibGUiLCJ1c2VUdXBsZXMiLCJ0b0pTJDEiLCJ0b09yZGVyZWRNYXAiLCJ0b09yZGVyZWRTZXQiLCJ0b1NldCIsInRvU3RhY2siLCJ0b0xpc3QiLCJfX3RvU3RyaW5nTWFwcGVyIiwiam9pbiIsInJldHVyblZhbHVlIiwicGFydGl0aW9uIiwiZmluZCIsImZpbmRFbnRyeSIsInNpZGVFZmZlY3QiLCJiaW5kIiwiam9pbmVkIiwiaXNGaXJzdCIsInJlZHVjZSQxIiwicmVkdWNlciIsImluaXRpYWxSZWR1Y3Rpb24iLCJyZWR1Y2VSaWdodCIsImJ1dExhc3QiLCJpc0VtcHR5IiwiY291bnRCeSIsImVudHJpZXNTZXF1ZW5jZSIsImVudHJ5TWFwcGVyIiwiZmlsdGVyTm90Iiwibm90IiwiZm91bmQiLCJmaW5kS2V5IiwiZmluZExhc3QiLCJmaW5kTGFzdEVudHJ5IiwiZmluZExhc3RLZXkiLCJmaXJzdCIsImZsYXRNYXAiLCJzZWFyY2hLZXkiLCJncm91cEJ5IiwiaXNTdWJzZXQiLCJpc1N1cGVyc2V0Iiwia2V5T2YiLCJrZXlNYXBwZXIiLCJsYXN0IiwibGFzdEtleU9mIiwibWF4QnkiLCJuZWciLCJkZWZhdWx0TmVnQ29tcGFyYXRvciIsIm1pbkJ5IiwicmVzdCIsInNraXAiLCJhbW91bnQiLCJza2lwTGFzdCIsInNraXBXaGlsZSIsInNraXBVbnRpbCIsInRha2UiLCJ0YWtlTGFzdCIsInRha2VXaGlsZSIsInRha2VVbnRpbCIsImhhc2hDb2xsZWN0aW9uIiwiQ29sbGVjdGlvblByb3RvdHlwZSIsInRvSlNPTiIsImNoYWluIiwiY29udGFpbnMiLCJtYXBLZXlzIiwiS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlIiwiZmluZEluZGV4IiwicmVtb3ZlTnVtIiwibnVtQXJncyIsInNwbGljZWQiLCJmaW5kTGFzdEluZGV4IiwiaW50ZXJwb3NlIiwiaW50ZXJsZWF2ZSIsInppcHBlZCIsImludGVybGVhdmVkIiwiemlwIiwiZGVmYXVsdFppcHBlciIsInppcFdpdGgiLCJJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZSIsIlNldENvbGxlY3Rpb25Qcm90b3R5cGUiLCJyZWR1Y3Rpb24iLCJ1c2VGaXJzdCIsIm9yZGVyZWQiLCJrZXllZCIsImgiLCJoYXNoTWVyZ2UiLCJtdXJtdXJIYXNoT2ZTaXplIiwiZW1wdHlPcmRlcmVkU2V0IiwiT3JkZXJlZFNldFByb3RvdHlwZSIsIm1ha2VPcmRlcmVkU2V0IiwiRU1QVFlfT1JERVJFRF9TRVQiLCJQYWlyU29ydGluZyIsIkxlZnRUaGVuUmlnaHQiLCJSaWdodFRoZW5MZWZ0IiwidGhyb3dPbkludmFsaWREZWZhdWx0VmFsdWVzIiwiZGVmYXVsdFZhbHVlcyIsIlJlY29yZCIsIm5hbWUiLCJoYXNJbml0aWFsaXplZCIsIlJlY29yZFR5cGUiLCJpbmRpY2VzIiwiUmVjb3JkVHlwZVByb3RvdHlwZSIsIl9pbmRpY2VzIiwiX25hbWUiLCJfZGVmYXVsdFZhbHVlcyIsInByb3BOYW1lIiwiY29uc29sZSIsIndhcm4iLCJyZWNvcmROYW1lIiwic2V0UHJvcCIsIl92YWx1ZXMiLCJsIiwiUmVjb3JkUHJvdG90eXBlIiwiZGlzcGxheU5hbWUiLCJzdHIiLCJyZWNvcmRTZXEiLCJuZXdWYWx1ZXMiLCJtYWtlUmVjb3JkIiwiZ2V0RGVzY3JpcHRpdmVOYW1lIiwibGlrZVJlY29yZCIsInJlY29yZCIsIlJlcGVhdCIsInRpbWVzIiwiX3ZhbHVlIiwiRU1QVFlfUkVQRUFUIiwiZnJvbUpTIiwiY29udmVydGVyIiwiZnJvbUpTV2l0aCIsImRlZmF1bHRDb252ZXJ0ZXIiLCJwYXJlbnRWYWx1ZSIsImNvbnZlcnRlZCIsInZlcnNpb24iLCJJbW11dGFibGUiLCJJdGVyYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/immutable/dist/immutable.es.js\n");

/***/ })

};
;